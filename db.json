{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1},{"_id":"themes/fexo/source/sass/styles.scss","path":"sass/styles.scss","modified":1},{"_id":"themes/fexo/source/js/zenscroll.js","path":"js/zenscroll.js","modified":1},{"_id":"themes/fexo/source/js/util.js","path":"js/util.js","modified":1},{"_id":"themes/fexo/source/js/scroll-spy.js","path":"js/scroll-spy.js","modified":1},{"_id":"themes/fexo/source/js/fastclick.js","path":"js/fastclick.js","modified":1},{"_id":"themes/fexo/source/js/bundle.js","path":"js/bundle.js","modified":1},{"_id":"themes/fexo/source/js/app.js","path":"js/app.js","modified":1},{"_id":"themes/fexo/source/images/qr-wechat.png","path":"images/qr-wechat.png","modified":1},{"_id":"themes/fexo/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1},{"_id":"themes/fexo/source/fonts/fontello.woff2","path":"fonts/fontello.woff2","modified":1},{"_id":"themes/fexo/source/fonts/fontello.woff","path":"fonts/fontello.woff","modified":1},{"_id":"themes/fexo/source/fonts/fontello.ttf","path":"fonts/fontello.ttf","modified":1},{"_id":"themes/fexo/source/fonts/fontello.svg","path":"fonts/fontello.svg","modified":1},{"_id":"themes/fexo/source/fonts/fontello.eot","path":"fonts/fontello.eot","modified":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","path":"fonts/calligraffitti-regular-webfont.woff2","modified":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","path":"fonts/calligraffitti-regular-webfont.woff","modified":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","path":"fonts/calligraffitti-regular-webfont.ttf","modified":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","path":"fonts/calligraffitti-regular-webfont.svg","modified":1},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","path":"fonts/calligraffitti-regular-webfont.eot","modified":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","path":"fonts/PoiretOne-Regular.woff","modified":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","path":"fonts/PoiretOne-Regular.ttf","modified":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","path":"fonts/PoiretOne-Regular.svg","modified":1},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","path":"fonts/PoiretOne-Regular.eot","modified":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","path":"fonts/Lobster-Regular.woff","modified":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","path":"fonts/Lobster-Regular.ttf","modified":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","path":"fonts/Lobster-Regular.svg","modified":1},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","path":"fonts/Lobster-Regular.eot","modified":1},{"_id":"themes/fexo/source/css/styles.css.map","path":"css/styles.css.map","modified":1},{"_id":"themes/fexo/source/css/styles.css","path":"css/styles.css","modified":1},{"_id":"themes/fexo/source/images/qr-alipay.png","path":"images/qr-alipay.png","modified":1}],"Cache":[{"_id":"source/CNAME","shasum":"647568195a9af3e53933bebe2e12ff0f647201f9","modified":1467249140000},{"_id":"source/_posts/App-Store上线完整流程/application_loader_login.png","shasum":"d3b0b44aeffa191e54f304c1b283fe9378f453aa","modified":1457330339000},{"_id":"source/_posts/App-Store上线完整流程/create_certSigningRequest_step2.png","shasum":"45aeb702688a46534eab4e7dcfb91def330a990b","modified":1457321993000},{"_id":"source/_posts/App-Store上线完整流程/itunes_connect_step1.png","shasum":"0ec0b597d74e46e186c2cf9a4192b3fd850b561c","modified":1457328412000},{"_id":"source/_posts/App-Store上线完整流程.md","shasum":"b9e4df27010a4abe398b9e74d17f2e4daa9d288b","modified":1464839682000},{"_id":"source/_posts/Block正确使用避免Cycle-Retain和Crash.md","shasum":"a94cbc2c1d41df86d45f88dbe4e5917e2bec3fab","modified":1464839675000},{"_id":"source/_posts/CocoaPods安装和使用教程.md","shasum":"ef53f108add8057966eb4c4d7e3002f02459cbb8","modified":1464841669000},{"_id":"source/_posts/CocoaPods的制作过程.md","shasum":"52965ddcbfe330832df8f743c121bbd637583be3","modified":1467973522000},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/dSYMs.png","shasum":"75de545e626b87d4b2ad2a5455fc9cb00a19b755","modified":1460971844000},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/export.png","shasum":"0316935caacd625cf2e75f075cae793ef9b80da5","modified":1460971335000},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/product.png","shasum":"f214e4bd524ed22ea92ad9a9eb0c5b9e4661bc86","modified":1460971824000},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/problem.png","shasum":"f98c771d6c5abd3a804fb24129e358e38b3db5d4","modified":1460970393000},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/show_in_finder.png","shasum":"8dca97194fb9d9e4062ed4833410f4c8796e4d9a","modified":1460971655000},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/zip.png","shasum":"e231f5e15647a6a0cb7fbb0399d8de1726228f52","modified":1460972142000},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets.md","shasum":"2b6feb0a7f83ff9a9aaf4a1072b74aba458a711a","modified":1461756781000},{"_id":"source/_posts/Github上优秀的Objective-C项目简介.md","shasum":"1b852d91734dc56bd1c379c5fc1c77925cd3ed0f","modified":1464848722000},{"_id":"source/_posts/CocosPods使用过程中遇到的一些问题，以及解决办法.md","shasum":"d8a040f3260eea78699cba58aabe230ba75548c3","modified":1466145478000},{"_id":"source/_posts/Hexo在github上构建免费的博客/hexo-dict.png","shasum":"255bc2cb12d9033eb1b7a94308aa6d91273e62f2","modified":1455940802000},{"_id":"source/_posts/Mac基础：如何让Finder显示隐藏文件和文件夹/bash.png","shasum":"987274dd448834be65c83327d93ea03bbf7be606","modified":1461810131000},{"_id":"source/_posts/Hexo安装新主题apollo.md","shasum":"b8c128cb24c91ed6788510dcecef56e7575cd297","modified":1464840701000},{"_id":"source/_posts/Hexo在github上构建免费的博客.md","shasum":"9ba8ba1db9558d52cefe9d62642dcdc477c26775","modified":1464841439000},{"_id":"source/_posts/Hexo在github上构建免费的博客/hexo-new.png","shasum":"127b749713d588614589b7f3640626361454b26e","modified":1455951767000},{"_id":"source/_posts/Mac基础：如何让Finder显示隐藏文件和文件夹/show.png","shasum":"ca666286a21a28b7985babe9698ba0a82d9b894b","modified":1461810510000},{"_id":"source/_posts/Mac基础：如何让Finder显示隐藏文件和文件夹.md","shasum":"fc86f44bc5581c8635e1f423213be2e74d5a5256","modified":1461828454000},{"_id":"source/_posts/Mac环境中Jenkins停止和启动命令.md","shasum":"2b8824b53424cf5b9f30b644c3d32925e5d26873","modified":1470118810000},{"_id":"source/_posts/Objective-C常用关键字的使用与区别.md","shasum":"7ea48ff0ea56a156995101d572457cd019001b58","modified":1464840479000},{"_id":"source/_posts/Objective-C过滤NSString中的HTML标签.md","shasum":"415658a2e00d79f82a15c159259f7db7cb14e792","modified":1464839858000},{"_id":"source/_posts/RESideMenu在所有界面都会侧滑的问题解决办法.md","shasum":"20625354d1238e8a8e3db4b4c3eaf2eaa7d14377","modified":1464840653000},{"_id":"source/_posts/RXSwift基础/empty.png","shasum":"6c37fedfec79f8089968362a449c770d0cd40b45","modified":1465018601000},{"_id":"source/_posts/NSURLErrorDomain-Code-1002-“unsupported-URL”.md","shasum":"c30674609480a3d7d21abebfbb393d4764be5d9c","modified":1467272485000},{"_id":"source/_posts/Objective-C身份证验证实现.md","shasum":"8d064948f7b19c888b0ba1f7fe4757a0d0921411","modified":1465966773000},{"_id":"source/_posts/RXSwift基础/never.png","shasum":"77fdebc9b39a8664d5268b07d4745c5662a069fe","modified":1465018601000},{"_id":"source/_posts/RXSwift基础.md","shasum":"bd44ca196318f5d91d02f4cc996ab73b91fc1dfd","modified":1465351496000},{"_id":"source/_posts/Swift学习笔记之函数.md","shasum":"d8f19a75c12ff5cae103fa935d904724425723b1","modified":1466155650000},{"_id":"source/_posts/Swift学习笔记之高级运算符.md","shasum":"ae57c86bb4172793e56757b68355acf41b380dfe","modified":1470121450000},{"_id":"source/_posts/Swift学习笔记之闭包.md","shasum":"c6d1fcfaf9f9cd3202234e9a2d0ebb388d31ff21","modified":1464844481000},{"_id":"source/_posts/Swift开源项目汇总.md","shasum":"94d6a2bfef88dc75d308e013dd33e7f3e00c4411","modified":1463815972000},{"_id":"source/_posts/Swift学习笔记之基础部分.md","shasum":"a6aec71ca6b31dcf5a261cb50f7bfd2478500071","modified":1464840033000},{"_id":"source/_posts/iOS上完美编译FFmpeg/1.png","shasum":"ffa855d4a047ebcaf89efafe2b2572dd36b343ec","modified":1459174231000},{"_id":"source/_posts/iOS几种不同传值方式.md","shasum":"5323480857de365f7944ddcd51e4df787297c332","modified":1464840643000},{"_id":"source/_posts/iOS中造成dealloc不调用的原因.md","shasum":"33579c640d054d6046a139277ca1dd0b32d0ba2c","modified":1464840142000},{"_id":"source/_posts/iOS-UIWebView简单使用.md","shasum":"f4e519dbd86e6183864126a30027b17f52ee1ac5","modified":1464840289000},{"_id":"source/_posts/全屏设置setStatusBarOrientation-未生效的解决办法.md","shasum":"f6f706733639b44a08ce3a812ea11a766607b3f0","modified":1467800397000},{"_id":"source/_posts/关于iOS多线程小记.md","shasum":"27ab2f9fa39ac39d184791edf34158fcc4515d04","modified":1461755537000},{"_id":"source/_posts/使用Jenkins构建iOS持续集成自动打包.md","shasum":"cb1c26cc34a4a9900e8d5bbc5386ae6f77f044f2","modified":1463817325000},{"_id":"source/_posts/iOS上完美编译FFmpeg.md","shasum":"3560760ea9cdae666f3eb789783dc8e7caf49cea","modified":1464840224000},{"_id":"source/_posts/关于UItableView的复用.md","shasum":"cb91294c1d9f7ed314973fe02f9c1932246d90fc","modified":1464840183000},{"_id":"source/_posts/关闭iOS系统自动更新提示的方法/thumb_IMG_0890_1024.jpg","shasum":"e5a5f667e73c8cb9db355317089edf1d96d362e6","modified":1463367284000},{"_id":"source/about/index.md","shasum":"bc1e33abe97db8273e6b12f35bb578534dde20a2","modified":1470123420000},{"_id":"source/_posts/初识ReactiveCocoa响应式编程.md","shasum":"250ddc81496a922f373ccb541829fcf674a8bd06","modified":1464068709000},{"_id":"source/baidu_verify_wFUlZEYgwT.html","shasum":"8cf3cc068f7cff1361b5fe37230acab5b99db628","modified":1459826585000},{"_id":"source/category/index.md","shasum":"7f7244fded59157de316a6b1ba4dbb6fc08a2a5c","modified":1470123342000},{"_id":"source/categories/index.md","shasum":"d3606803cd57e4f26ec59197c0255e9e459c8c4f","modified":1461740631000},{"_id":"source/link/index.md","shasum":"357e194d549590b0ff8dcf404137578b10530196","modified":1470123397000},{"_id":"source/project/index.md","shasum":"fdf7ecc245ccfc593aa5b10cfb58ca003f600420","modified":1470123440000},{"_id":"source/search/index.md","shasum":"50c12c2a6300c2d6355834fda046593a02bd9be0","modified":1470123476000},{"_id":"source/tag/index.md","shasum":"34c7b76f347ad9f82a1b085bc6691d24c8fb126b","modified":1470123377000},{"_id":"source/googlec25480101521e91f.html","shasum":"6694f79e4a1addbf4f77e7513a72ff29e6e65947","modified":1459825549000},{"_id":"source/_posts/关闭iOS系统自动更新提示的方法/thumb_IMG_0889_1024.jpg","shasum":"55ecebf0786c44c56fed91c52f946d38d6ec9b97","modified":1463367262000},{"_id":"source/tags/index.md","shasum":"2dd1a12c9b11d7a7a870fd1f1991554759f682b3","modified":1461740567000},{"_id":"source/_posts/App-Store上线完整流程/application_loader_step2.png","shasum":"d750221918bb444e5e620848f1e5d7bc62cfc50a","modified":1457330485000},{"_id":"source/_posts/关闭iOS系统自动更新提示的方法.md","shasum":"bc23244cad013b33da448e115f1c275f198ac6fc","modified":1464839259000},{"_id":"source/_posts/App-Store上线完整流程/build_setting.png","shasum":"a1b8c73575cc5b8e340d386ed9e1763579bf3798","modified":1457323031000},{"_id":"source/_posts/App-Store上线完整流程/developer_center.png","shasum":"2f77e6d0e6a50ae50452236fbe0befcc57c52eb1","modified":1457317963000},{"_id":"source/_posts/App-Store上线完整流程/create_pp_step5.png","shasum":"a1c8c465ece29a3d151a74bb3692977854aefb43","modified":1457322780000},{"_id":"source/_posts/App-Store上线完整流程/itunes_connect_step3.png","shasum":"96934124b29270ced80c24adf06502e97fd7fb12","modified":1457328997000},{"_id":"source/_posts/App-Store上线完整流程/upload_itunes_connect.png","shasum":"1a0227ef9f954e77d862d5dd0cd3d737146e4064","modified":1457329385000},{"_id":"source/_posts/App-Store上线完整流程/itunes_connect_step4.png","shasum":"6c123c017fad7bbe83fc1505cd01337c7555c418","modified":1457330714000},{"_id":"source/_posts/App-Store上线完整流程/itunes_connect_step2.png","shasum":"2ed06cf54889786ab490abe7d11b4bc2f11bfb4a","modified":1457328760000},{"_id":"source/_posts/App-Store上线完整流程/itunes_connect_step5.png","shasum":"04e76730436605d533e21512892523205c54e335","modified":1457330879000},{"_id":"source/_posts/Mac基础：如何让Finder显示隐藏文件和文件夹/finder.png","shasum":"8eaf45417254832271290d1043ea2768152f29cf","modified":1461810248000},{"_id":"source/_posts/Hexo安装新主题apollo/apollo.png","shasum":"76e84d50b93d48566d74a77947f35430e21a9596","modified":1455956940000},{"_id":"source/_posts/RXSwift基础/create.png","shasum":"5a48878fab58c5e594126a43c721f8edae008440","modified":1465018601000},{"_id":"source/_posts/RXSwift基础/just.png","shasum":"fe83de234d6a1e6fe3a04102a3e059d5fba67bcb","modified":1465018601000},{"_id":"themes/fexo/source/sass/pages/_tag.scss","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1469702770000},{"_id":"source/_posts/App-Store上线完整流程/archive.png","shasum":"b7fe83694a65966da3a60bd35e6c7d6d868dc65c","modified":1457323288000},{"_id":"source/_posts/App-Store上线完整流程/archive_step_1.png","shasum":"ad46be33ca981b89a8c530acf934e66237fd0e1c","modified":1457330049000},{"_id":"source/_posts/App-Store上线完整流程/create_certificates_step3.png","shasum":"d851186b031d65f54564bf5a30c52964da74b551","modified":1457321152000},{"_id":"source/_posts/App-Store上线完整流程/create_pp_step3.png","shasum":"8ce566147802de1de8729c00e0dd1c41a5d023c0","modified":1457322627000},{"_id":"source/_posts/App-Store上线完整流程/create_certificates_step2.png","shasum":"be6a4a84a58080396a3d2dbe1a2e5ec8c2f5fa36","modified":1457320977000},{"_id":"source/_posts/App-Store上线完整流程/create_app_id.png","shasum":"ee610f0fc8744d4a21a4e234524b5717c170183e","modified":1457319902000},{"_id":"source/_posts/App-Store上线完整流程/create_pp_step4.png","shasum":"2749c823a187291ae06e35bd1e2f76be3bb701ad","modified":1457322716000},{"_id":"source/_posts/App-Store上线完整流程/create_pp_step2.png","shasum":"d4b489d58d42af637ef3746e710cb1a085d3eb4f","modified":1457322531000},{"_id":"source/_posts/Hexo在github上构建免费的博客/github.png","shasum":"4fd74baa712d3e0035f61fd420152a1836f767f0","modified":1455955179000},{"_id":"source/_posts/Mac基础：如何让Finder显示隐藏文件和文件夹/hidefinder.png","shasum":"42d73f1de8cf1a391f740a56ecc71d833a561b7d","modified":1461810624000},{"_id":"source/_posts/RXSwift基础/catch.png","shasum":"7811d29c918f14b41b30dcfd9486a50ed617bb38","modified":1465018601000},{"_id":"source/_posts/RXSwift基础/deferred.png","shasum":"cc1f2dcfdcfbe6dbcb0f59807ad58c4700bd0b6a","modified":1465018601000},{"_id":"source/_posts/RXSwift基础/doOn.png","shasum":"0dbf4a98a697044dad595dea7f76e1f6a073ca76","modified":1465018601000},{"_id":"source/_posts/RXSwift基础/flatMap.png","shasum":"bf2d87b70176a76895f1ba0be768f3aea7ec31b4","modified":1465018601000},{"_id":"source/_posts/RXSwift基础/takeWhile.png","shasum":"403b7a67053608f490edd0dec3785db731c2da6d","modified":1465018601000},{"_id":"themes/fexo/_config.yml","shasum":"1959a1391dfc623ce4e50bf28ec0bf6fb0e0e76a","modified":1470126795000},{"_id":"themes/fexo/README.md","shasum":"35cd346c229e17ed83609ee94b5d6493c4ab9982","modified":1469702770000},{"_id":"themes/fexo/gulpfile.js","shasum":"5995b9c4e8e18d1670ad30b2881d49fa17e56415","modified":1469702770000},{"_id":"themes/fexo/LICENSE","shasum":"db4cb5aef6072a96721b5428fdd999647c049d55","modified":1469702770000},{"_id":"themes/fexo/languages/no.yml","shasum":"bf11017d77f64fbafb9c99ac219d076b20d53afc","modified":1469702770000},{"_id":"themes/fexo/languages/zh-CN.yml","shasum":"751c74830d5609969f1fd6e7fa933ecd5756117a","modified":1469702770000},{"_id":"themes/fexo/languages/zh-TW.yml","shasum":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/article.ejs","shasum":"c56f02b3344586f984e742732323b809a941282a","modified":1469702770000},{"_id":"themes/fexo/languages/default.yml","shasum":"fd7397be7789b43c1c163ab4faf106318811c2a8","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/baidu-analytics.ejs","shasum":"c19e4abec19c23840fff7f8a51f4aefbb2b7e8ca","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/back-top.ejs","shasum":"47f2b8306b901f0fffc6aa0cfa40db697a0c5aff","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/category-box.ejs","shasum":"497bb978e6bc81a79cd2dc80fa355d57335f0b81","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/category.ejs","shasum":"2429158ff177b8876de765498b54d0c91b3fc551","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/comments.ejs","shasum":"49d044fc7bff2c6a249842b36c3739f01333109e","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/date.ejs","shasum":"163fbd874481cb9e2b6da5282701a3fbaa4e367a","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/disqus.ejs","shasum":"21de7498d235a52337335108fce7446e1a21ea1c","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/donation.ejs","shasum":"65bf93ad8e149033e6f93d673cc85ee223615589","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/duoshuo.ejs","shasum":"a876cf39335d5ad935f01c31e87828b5115d0064","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/item-category-name.ejs","shasum":"8ab52c9b5d5db1d3c1d343ecb405c4e15cd144ac","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/item-post.ejs","shasum":"722e5dbde2d4683eea08f2af922358db45b253b1","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/item-tag.ejs","shasum":"1b4c4e090c33ccfd44b531a5de9af16eec266512","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/item-year.ejs","shasum":"906a6aea44a30e83c4c4e449294c7e4d831c188e","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/modal.ejs","shasum":"022291a0a5c872260b67b01a4aaa5de94978298c","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/page-header.ejs","shasum":"14bad32082d87d7eeb45c0e9079e72f0ae65dbf4","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/pagination.ejs","shasum":"ffbb548aee6e15cae924ee7f922f28b2403e8e45","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/tag-box.ejs","shasum":"33467eb5c760502eb75dcad63a4527a1f68deb95","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/tag-list.ejs","shasum":"8535c40b573744ced738b051383c0feca80eb0e9","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/title.ejs","shasum":"6ab4c0769db4507d7fe1ffee1e69f988309309ff","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/toc.ejs","shasum":"0efd5e3294bb883ff96270e69b05e289e4f17efe","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/component/toolbox.ejs","shasum":"5a3a06aec68cc44df2e62bd66475dbf860792c30","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/duoshuo.ejs","shasum":"728522a31887d5cc896104cc1b4c48b9d2659350","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/head.ejs","shasum":"aaee7fc7a120e9a45e91e95595dde85d770baf84","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/home.ejs","shasum":"988b6b024125852eceac94df278cdeaa662c9d3d","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/load-script.ejs","shasum":"4675c917548817118f4a3c5d84acc98d6c61a1d8","modified":1469702770000},{"_id":"themes/fexo/layout/_partial/style.ejs","shasum":"99c20c0ae1a6876899614b029ce39864bf86f877","modified":1469702770000},{"_id":"themes/fexo/layout/about.ejs","shasum":"e8815233896c044cee92bfc16d20c4b9f5a00922","modified":1469702770000},{"_id":"themes/fexo/layout/layout.ejs","shasum":"baf0f4234963dd9c282a7fe1fc9fd93a6fdb7330","modified":1470122849000},{"_id":"themes/fexo/layout/archive.ejs","shasum":"f70a311fedda4468135aa5914954e9ecd0280a1d","modified":1469702770000},{"_id":"themes/fexo/layout/category.ejs","shasum":"b8c2c9baf4e21e4472b25a717ba61a5457ccddff","modified":1469702770000},{"_id":"themes/fexo/layout/index.ejs","shasum":"9d33cd03e7a8adf8bbc124c248def36c15e681d0","modified":1469702770000},{"_id":"themes/fexo/layout/link.ejs","shasum":"d2659cb6f1f796111a9261a90ccfe209294a0114","modified":1469702770000},{"_id":"themes/fexo/layout/post.ejs","shasum":"075586a9805c24683a154a19e8df9a7e9eab7bcd","modified":1469702770000},{"_id":"themes/fexo/layout/project.ejs","shasum":"ce72621428276d54c15de0a4057144fc164ae5c1","modified":1469702770000},{"_id":"themes/fexo/layout/search.ejs","shasum":"1b1f99b55721d9178d712d4d3c4928322ba3c649","modified":1469702770000},{"_id":"themes/fexo/layout/tag.ejs","shasum":"03aaee19788f09dbb153b108a54aa4899aacd133","modified":1469702770000},{"_id":"themes/fexo/package.json","shasum":"351b5b21f5ea8851103ee1891248be43f3c27027","modified":1469702770000},{"_id":"themes/fexo/source/css/styles.css","shasum":"975f1b389868464f9a99b7fa34827b42e20355e2","modified":1469702770000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.eot","shasum":"2a4ef0d00fb77d16e37c3da429698b029e7d2d2f","modified":1469702770000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.ttf","shasum":"2b186ce205301f7f3abd441f0372b72adcd2aee3","modified":1469702770000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.woff","shasum":"1cebcedde2c52261591bc322b176638798336a24","modified":1469702770000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.eot","shasum":"4c7bcece73621f648fa71d58fa13c28670fed8ca","modified":1469702770000},{"_id":"themes/fexo/source/fonts/fontello.eot","shasum":"7732065eeaec4614e9548955d9bd30ccd7b149c1","modified":1469702770000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff2","shasum":"ba50c427166090361b0dab4c72136c7b451e86d4","modified":1469702770000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.woff","shasum":"1364845a3815740c572e29c83fd8d54f1c1ef5de","modified":1469702770000},{"_id":"themes/fexo/source/fonts/fontello.woff","shasum":"45737fea847f3942ef405f00ea4df940fbb6bbd9","modified":1469702770000},{"_id":"themes/fexo/source/fonts/fontello.ttf","shasum":"e255d37ca14348e9a8532667a757ab552e58caff","modified":1469702770000},{"_id":"themes/fexo/source/fonts/fontello.woff2","shasum":"1dfbc23328582f7cd9bcbe538224f6c762023e43","modified":1469702770000},{"_id":"themes/fexo/source/fonts/fontello.svg","shasum":"33a984f4482a5ba5e7bc67d82e8db63cda4e3ae1","modified":1469702770000},{"_id":"themes/fexo/source/js/bundle.js","shasum":"7da160b15a43ce19273ec85204828bd42628546f","modified":1469702770000},{"_id":"themes/fexo/source/js/app.js","shasum":"a6d6e7fba3d69d0dec2c4d18debe0dc4cc7ab319","modified":1469702770000},{"_id":"themes/fexo/source/js/scroll-spy.js","shasum":"81b81362fcd63592045a673b54ce1edb7a6e3028","modified":1469702770000},{"_id":"themes/fexo/source/js/util.js","shasum":"8136da2bec1faf5fe3e14fa436f501292fca8c07","modified":1469702770000},{"_id":"themes/fexo/source/js/fastclick.js","shasum":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1469702770000},{"_id":"themes/fexo/source/sass/_animate.scss","shasum":"8de97c948cb4b9c9b7a87c0f7332ed534c378e26","modified":1469702770000},{"_id":"themes/fexo/source/js/zenscroll.js","shasum":"bea2a3571555fdae64e8fc56f161f9a4f427b335","modified":1469702770000},{"_id":"themes/fexo/source/sass/_base.scss","shasum":"915bc919ae434a61b58511720300eca8646b6705","modified":1469702770000},{"_id":"themes/fexo/source/sass/_common.scss","shasum":"b1fc97d6d24a92a9a7a9d39be4fe844f5c0f6d44","modified":1469702770000},{"_id":"themes/fexo/source/sass/_fontello.scss","shasum":"f2d6b86bb63459884cf63e8c045fd10c827396eb","modified":1469702770000},{"_id":"themes/fexo/source/sass/_fonts.scss","shasum":"10e188d379782ae2ee10427544919557036d0137","modified":1469702770000},{"_id":"themes/fexo/source/sass/_highlight-js.scss","shasum":"38a5c4d9f3a2943aff9bde1d624d710587e3bc05","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_back-top.scss","shasum":"1c67da7007f4b9d8c65deea3d82c0f579e65f2c2","modified":1469702770000},{"_id":"themes/fexo/source/sass/_normalize.scss","shasum":"e58275a588bb631a37a2988145eea231ed23176b","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_category-box.scss","shasum":"a807145b74d1b98270ea19ae35edd25b4c448bfa","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_comments.scss","shasum":"3e9b61bc08f38f947f54e942986a19a7f95ce723","modified":1469702770000},{"_id":"themes/fexo/source/sass/_type.scss","shasum":"cc7a25654593030f5214d5adf85f12a954c373c5","modified":1469702770000},{"_id":"themes/fexo/source/sass/_variable.scss","shasum":"e403294d093f6b5294938619786a22fde3e7f848","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_donation.scss","shasum":"dd8fb354d6196bf751978ae2215b8f0757c10ed5","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_item-category-name.scss","shasum":"119840d160cd263b57e79e2099a81079d7eeee3d","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_index.scss","shasum":"dc7d816cc77cb46580828e9ded2cfa45ba454226","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_hint.scss","shasum":"2812b4e10313168f2e082b740c60d64a151d94c8","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_item-post.scss","shasum":"1fb2e9be2d2edbb538cfbce7c80d5847f88e2f05","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_item-title.scss","shasum":"cdaca2858abc9428ef01103a7fbea8f095d856aa","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_item-year.scss","shasum":"12c147dd4ab9587cd622083c86c2f6cf07d8e26a","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_list-post.scss","shasum":"43564f6443385bf34e15672d1477d1c7560f5563","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_modal.scss","shasum":"2f0ed96df388ec28445b1ce5c6a61a0a697f9a68","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_page-header.scss","shasum":"893d0595ef48323dce449ef0d17308ce02b36087","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_pagination.scss","shasum":"12c1880c518aee2e3ccf59661d01c308639f8a9e","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_table.scss","shasum":"4899fb31d1be8d5c9c397fcbcfc2ff0c5b2e7f7f","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_tag-box.scss","shasum":"7601951d09a75a7c39493bfa1b1da5ac989d9cda","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_toc.scss","shasum":"3b4c083cb2ba4a88ca35b6d8259ee991c83b3406","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_toolbox-mobile.scss","shasum":"f15b215b9bb103ee1773a01d8badd81bb7643710","modified":1469702770000},{"_id":"themes/fexo/source/sass/component/_toolbox.scss","shasum":"964a480d4e7fad100463195cde2a3f67f9765c23","modified":1469702770000},{"_id":"themes/fexo/source/sass/pages/_about.scss","shasum":"7d61e627ea5376390081e0b93db426ffc6c4dee8","modified":1469702770000},{"_id":"themes/fexo/source/sass/pages/_archive.scss","shasum":"fefd54282a42ebb68b711f1cfefa1f67abbde05b","modified":1469702770000},{"_id":"themes/fexo/source/sass/pages/_category.scss","shasum":"713242d10c0c8687c9e2f287f1beeb38de6cdbad","modified":1469702770000},{"_id":"themes/fexo/source/sass/pages/_home.scss","shasum":"b65bb069ed28fbf223c5bb7e760882f79d20fa46","modified":1469702770000},{"_id":"themes/fexo/source/sass/pages/_index.scss","shasum":"d9fe73a87585abad06a7dd77b67ec7ce6c24402c","modified":1469702770000},{"_id":"themes/fexo/source/sass/pages/_search.scss","shasum":"fd28f01829628c9d21f9391d5067ddcd836dad13","modified":1469702770000},{"_id":"themes/fexo/source/sass/pages/_link.scss","shasum":"d3a249423c7ee88d1cb3a12e03f6c42a0a4d45a1","modified":1469702770000},{"_id":"themes/fexo/source/sass/styles.scss","shasum":"86ebe05d6a2931dd6fceef1e50c31ca996dc20be","modified":1469702770000},{"_id":"source/_posts/App-Store上线完整流程/Identifiers.png","shasum":"f01faa2e96fb54c3bc7efb53f913b5fa3efbf952","modified":1457319467000},{"_id":"source/_posts/App-Store上线完整流程/create_certificates_step1.png","shasum":"c2bea8c43d3c46193607557f7339e0d4113a3c37","modified":1457320658000},{"_id":"source/_posts/App-Store上线完整流程/create_certSigningRequest_step1.png","shasum":"ae9b055b0af55449b3a5eae168f8ef9a874b1dc5","modified":1457321663000},{"_id":"source/_posts/App-Store上线完整流程/create_pp_step1.png","shasum":"bdf170a53cf97efe7684274cfca647e4cb0c1c5f","modified":1457322327000},{"_id":"source/_posts/RXSwift基础/skipWhile.png","shasum":"bfd9212b8ecb8bc0c756d46a55783358d0e43463","modified":1465018601000},{"_id":"source/_posts/RXSwift基础/replay.png","shasum":"eb6031705757cd891198df219b1ed88da3f3e007","modified":1465018601000},{"_id":"source/_posts/RXSwift基础/publish.png","shasum":"2cbcf233af3133222b26812ca4aec3367a386d33","modified":1465018601000},{"_id":"source/_posts/RXSwift基础/retry.png","shasum":"7b4f934a032d35168975dec06c121dab4a2400b2","modified":1465018601000},{"_id":"themes/fexo/source/sass/pages/_post.scss","shasum":"c6f694568af362f9fe1e7e2b9909e47303178116","modified":1469702770000},{"_id":"themes/fexo/source/sass/pages/_project.scss","shasum":"bcbaded3d378bbaa1497f4c3843994ea589f3149","modified":1469702770000},{"_id":"themes/fexo/source/css/styles.css.map","shasum":"61bc0709283224840518b3f864b8552ebf245b9f","modified":1469702770000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.ttf","shasum":"4688935c427ae40dcbf16523bc11d9fc10e359b5","modified":1469702770000},{"_id":"themes/fexo/source/images/qr-wechat.png","shasum":"0bfeb299ae94a110ddc2fb0df064d87c26c9a431","modified":1470126916000},{"_id":"source/_posts/RXSwift基础/switch.png","shasum":"b855c53e603cc2414c568213f13c2d5a3079f1b9","modified":1465018601000},{"_id":"source/_posts/RXSwift基础/toArray.png","shasum":"662d3ee4b06cfd3869e993c698ef16829a8cbcfc","modified":1465018601000},{"_id":"themes/fexo/source/fonts/PoiretOne-Regular.svg","shasum":"e21109783f218cb7849b12e867e0b775ce3fadda","modified":1469702770000},{"_id":"themes/fexo/source/fonts/calligraffitti-regular-webfont.svg","shasum":"76e1e4cee6f2b5d596c635631938ee5eb6ab3e67","modified":1469702770000},{"_id":"source/_posts/App-Store上线完整流程/application_loader_1.png","shasum":"e070fbddd0894334e9ce56743a4c5391c055060e","modified":1457329803000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.woff","shasum":"298b80b1c9f694e1a055d62a5d809863c89baf50","modified":1469702770000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.eot","shasum":"4f0c85f63beb0d95610317e16f1d4acdd2962eee","modified":1469702770000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.ttf","shasum":"50a84291b7012bfdcf9ff5116d6c7aa3f257f37f","modified":1469702770000},{"_id":"themes/fexo/source/images/avatar.jpg","shasum":"66cf837ef6f5d5ae573f3014a5f4822092c6204e","modified":1470120585000},{"_id":"themes/fexo/source/fonts/Lobster-Regular.svg","shasum":"be1cab622c673942fb4d11a23c012227938b4792","modified":1469702770000},{"_id":"themes/fexo/source/images/qr-alipay.png","shasum":"792caf26d006d30bfa92af0090aee885b073edd0","modified":1470126743000}],"Category":[{"name":"其他","_id":"cird7gche000e29weglpvjygj"},{"name":"iOS学习笔记","_id":"cird7gchr000j29webv9h5l7a"},{"name":"常见问题","_id":"cird7gchy000u29wei5squ6n5"},{"name":"Swift学习笔记","_id":"cird7gcih001d29webcfqz2ff"},{"name":"常见错误","_id":"cird7gcjy001z29wefjbaaiyt"},{"name":"Mac基础","_id":"cird7gck2002529wehw2xdceg"}],"Data":[],"Page":[{"title":"标签","date":"2014-12-22T04:39:04.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: 标签\ndate: 2014-12-22 12:39:04\ntype: \"tags\"\ncomments: false\n---","updated":"2016-04-27T07:02:47.000Z","path":"tags/index.html","layout":"page","_id":"cird7gcff000029we3m5vtxbx"},{"title":"Tag","layout":"tag","comments":0,"_content":"","source":"tag/index.md","raw":"---\ntitle: tag\nlayout: tag\ncomments: false\n---\n","date":"2016-08-02T07:36:17.000Z","updated":"2016-08-02T07:36:17.000Z","path":"tag/index.html","_id":"cird7gcfm000129wesmo0q0k6"},{"title":"Search","layout":"search","comments":0,"_content":"","source":"search/index.md","raw":"---\ntitle: search\nlayout: search\ncomments: false\n---\n","date":"2016-08-02T07:37:56.000Z","updated":"2016-08-02T07:37:56.000Z","path":"search/index.html","_id":"cird7gcfp000229wefovcm08h"},{"title":"Project","layout":"project","comments":0,"_content":"","source":"project/index.md","raw":"---\ntitle: project\nlayout: project\ncomments: false\n---\n","date":"2016-08-02T07:37:20.000Z","updated":"2016-08-02T07:37:20.000Z","path":"project/index.html","_id":"cird7gcfr000329wejgp02rxx"},{"title":"Link","layout":"link","comments":0,"_content":"","source":"link/index.md","raw":"---\ntitle: link\nlayout: link\ncomments: false\n---\n","date":"2016-08-02T07:36:37.000Z","updated":"2016-08-02T07:36:37.000Z","path":"link/index.html","_id":"cird7gcft000429web5evbpc2"},{"layout":"false","_content":"google-site-verification: googlec25480101521e91f.html\n","source":"googlec25480101521e91f.html","raw":"layout: false\n---\ngoogle-site-verification: googlec25480101521e91f.html\n","date":"2016-04-18T09:44:05.000Z","updated":"2016-04-05T03:05:49.000Z","path":"googlec25480101521e91f.html","title":"","comments":1,"_id":"cird7gcfw000529wepez05kva"},{"title":"Category","layout":"category","comments":0,"_content":"","source":"category/index.md","raw":"---\ntitle: category\nlayout: category\ncomments: false\n---\n","date":"2016-08-02T07:35:42.000Z","updated":"2016-08-02T07:35:42.000Z","path":"category/index.html","_id":"cird7gcfz000629wejp1vbq0k"},{"title":"Categories","date":"2016-04-27T07:03:22.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-04-27 15:03:22\ntype: \"categories\"\ncomments: false\n---\n","updated":"2016-04-27T07:03:51.000Z","path":"categories/index.html","layout":"page","_id":"cird7gcg1000729we4ic18ox3"},{"layout":"false","_content":"wFUlZEYgwT\n","source":"baidu_verify_wFUlZEYgwT.html","raw":"layout: false\n---\nwFUlZEYgwT\n","date":"2016-04-18T09:44:05.000Z","updated":"2016-04-05T03:23:05.000Z","path":"baidu_verify_wFUlZEYgwT.html","title":"","comments":1,"_id":"cird7gcg3000829we6zyg1ku0"},{"title":"About","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ncomments: false\n---\n","date":"2016-08-02T07:37:00.000Z","updated":"2016-08-02T07:37:00.000Z","path":"about/index.html","_id":"cird7gcg7000929wegmb5n8qn"}],"Post":[{"title":"初识ReactiveCocoa响应式编程","date":"2016-05-24T05:02:01.000Z","_content":"\n\n参考文章\n[使用ReactiveCocoa实现iOS平台响应式编程](http://www.itiger.me/?p=38)\n[ReactiveCocoa与Functional Reactive Programming](http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html)\n[最快让你上手ReactiveCocoa之基础篇](http://www.jianshu.com/p/87ef6720a096)\n[花瓣网李忠：ReactiveCocoa是Cocoa的未来](http://www.infoq.com/cn/news/2014/07/reactiveCocoa-cocoa)\n[ReactiveCocoa 讨论会](http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/)","source":"_posts/初识ReactiveCocoa响应式编程.md","raw":"---\ntitle: 初识ReactiveCocoa响应式编程\ndate: 2016-05-24 13:02:01\ntags:\n   - ReactiveCocoa\n---\n\n\n参考文章\n[使用ReactiveCocoa实现iOS平台响应式编程](http://www.itiger.me/?p=38)\n[ReactiveCocoa与Functional Reactive Programming](http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html)\n[最快让你上手ReactiveCocoa之基础篇](http://www.jianshu.com/p/87ef6720a096)\n[花瓣网李忠：ReactiveCocoa是Cocoa的未来](http://www.infoq.com/cn/news/2014/07/reactiveCocoa-cocoa)\n[ReactiveCocoa 讨论会](http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/)","slug":"初识ReactiveCocoa响应式编程","published":1,"updated":"2016-05-24T05:45:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcg9000a29weu0ltc7um"},{"title":"关闭iOS系统自动更新提示的方法","date":"2016-05-16T02:16:25.000Z","_content":"\n一直以来都被iOS的自动更新困扰，每次苹果推出了最新版本的iOS系统都会提示自动更新，真的很烦。并且公司的测试机不可能全都是一个版本的系统，不然很多不同iOS版本系统的bug根本无法测出来，所以为了保持测试机系统的多样性，我想保持一部分手机系统永不更新，让我自己的手机保持最新系统就行了。\n\n<!-- more -->\n\n## 解决办法\n\n经过一段时间的试验，有如下几个对应方案：\n1. 设置 - 通用 - 用量 - 管理存储空间 - 找到更新包，然后删除它\n2. 设置 - iTunes&App Stores, 找到Updates，关闭\n\n如果以上两个方案还不管用，直接放大招：\n在手机上打开safari，地址栏输入:\n\n```\nhttps://oldcat.me/web/NOOTA9.mobileconfig\n```\n然后回车\n按照要求安装此provision文件即可，然后重启。\n\n{% asset_img thumb_IMG_0889_1024.jpg 安装provision文件%}\n\n重启后打开设置 - 通用 - 软件更新 有惊喜\n\n{% asset_img thumb_IMG_0890_1024.jpg 结果图%}\n","source":"_posts/关闭iOS系统自动更新提示的方法.md","raw":"---\ntitle: 关闭iOS系统自动更新提示的方法\ndate: 2016-05-16 10:16:25\ntags:\n   - iOS系统\ncategories: 其他\n\n---\n\n一直以来都被iOS的自动更新困扰，每次苹果推出了最新版本的iOS系统都会提示自动更新，真的很烦。并且公司的测试机不可能全都是一个版本的系统，不然很多不同iOS版本系统的bug根本无法测出来，所以为了保持测试机系统的多样性，我想保持一部分手机系统永不更新，让我自己的手机保持最新系统就行了。\n\n<!-- more -->\n\n## 解决办法\n\n经过一段时间的试验，有如下几个对应方案：\n1. 设置 - 通用 - 用量 - 管理存储空间 - 找到更新包，然后删除它\n2. 设置 - iTunes&App Stores, 找到Updates，关闭\n\n如果以上两个方案还不管用，直接放大招：\n在手机上打开safari，地址栏输入:\n\n```\nhttps://oldcat.me/web/NOOTA9.mobileconfig\n```\n然后回车\n按照要求安装此provision文件即可，然后重启。\n\n{% asset_img thumb_IMG_0889_1024.jpg 安装provision文件%}\n\n重启后打开设置 - 通用 - 软件更新 有惊喜\n\n{% asset_img thumb_IMG_0890_1024.jpg 结果图%}\n","slug":"关闭iOS系统自动更新提示的方法","published":1,"updated":"2016-06-02T03:47:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gchd000d29weg05tmswh"},{"title":"关于iOS多线程小记","date":"2016-03-30T03:42:06.000Z","_content":"\n这篇文章我将整理一下iOS中的几种多线程方案，以及使用方法和注意事项。当然也会给出几种简单的代码案例，再试实际使用中去感受它们的区别。\n\n## 概述\n\n在了解线程前，我们需要先了解进程。一句话概括线程和进程就是：操作系统可以同时执行多个任务，每个任务就是进程，进程可以同时执行多个任务，每个任务就是线程。对于多线程的优点大致可以总结为以下几点：\n* 进程间不能共享内存，但线程间共享内存非常容易。\n* 系统创建进程需要为该进程重新分配系统资源，但创建线程的代价要小得多，因此使用多线程来实现任务并发比多进程效率高得多。\n\n<!-- more -->\n\n在实际开发过程中多线程是非常有用的，假如用户点击界面上某个按钮的时候，该按钮需要执行的任务需要耗时很长，如果我们直接在UI线程中完成这个任务，在该任务执行完成返回之前，UI线程被该任务阻塞，将无法再相应用户的其它操作。在这段时间内用户对界面上的任何操作将不会被相应（除非按Home键返回），这并不是我们希望看到的结果。一般这个时候我们能够想到的办法就是将耗时的操作放到非UI线程（开启一个线程）中完成，这样UI线程就不会被阻塞，应用也就不会失去相应。\n\niOS系统大致提供了如下3种实现多线程：\n* NSThread\n* NSOperation和NSOperationQueue\n* GCD(Grand Central Dispatch)\n","source":"_posts/关于iOS多线程小记.md","raw":"---\ntitle: 关于iOS多线程小记\ndate: 2016-03-30 11:42:06\ntags:\n  - iOS\n  - 笔记\ncategories: iOS学习笔记\n---\n\n这篇文章我将整理一下iOS中的几种多线程方案，以及使用方法和注意事项。当然也会给出几种简单的代码案例，再试实际使用中去感受它们的区别。\n\n## 概述\n\n在了解线程前，我们需要先了解进程。一句话概括线程和进程就是：操作系统可以同时执行多个任务，每个任务就是进程，进程可以同时执行多个任务，每个任务就是线程。对于多线程的优点大致可以总结为以下几点：\n* 进程间不能共享内存，但线程间共享内存非常容易。\n* 系统创建进程需要为该进程重新分配系统资源，但创建线程的代价要小得多，因此使用多线程来实现任务并发比多进程效率高得多。\n\n<!-- more -->\n\n在实际开发过程中多线程是非常有用的，假如用户点击界面上某个按钮的时候，该按钮需要执行的任务需要耗时很长，如果我们直接在UI线程中完成这个任务，在该任务执行完成返回之前，UI线程被该任务阻塞，将无法再相应用户的其它操作。在这段时间内用户对界面上的任何操作将不会被相应（除非按Home键返回），这并不是我们希望看到的结果。一般这个时候我们能够想到的办法就是将耗时的操作放到非UI线程（开启一个线程）中完成，这样UI线程就不会被阻塞，应用也就不会失去相应。\n\niOS系统大致提供了如下3种实现多线程：\n* NSThread\n* NSOperation和NSOperationQueue\n* GCD(Grand Central Dispatch)\n","slug":"关于iOS多线程小记","published":1,"updated":"2016-04-27T11:12:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gchp000i29we8crezyg2"},{"title":"关于UItableView的复用","date":"2016-04-05T01:26:44.000Z","_content":"\nUITableView是我从开始接触iOS编程到现在最常用的一个控件，没有之一。这篇文章就先不说UITableView的基本用法了，详细有一点iOS基础的人都应该知道，这里主要想理一理UItableView的复用机制。\n\n## 概述\n\n为了更清楚明白的描述UItableView的复用机制，我们先假设UItableView如果没有复用机制。如果UItableVIew没有复用机制，我们要展示10000条数据的的话，那就得生成10000条UItableViewCell，这样将会占用大量的内存，并且性能大家可以想象一下（这个UItableView滑动起来一定是相当的卡顿，非常影响用户体验）。\n\n<!-- more -->\n\n关于UItableView的复用机制大概是这样的：假设一个UItableView要加载10000条数据，但是一个屏幕最大只能展示3条数据（这里屏幕最多能展示的数据条数是根据UItableViewCell的高度来定的）。然后当你向上滑动，想要查看更多的内容，那么肯定需要一个cell放在已经存在的内容下边。这个时候并不会重新去创建一个UItableViewCell放在下面，而是根据cellIdetifier去内存池中拿到与之对应的UItableViewCell。\n\n## 复用方式\n\nUItableView的复用方式有如下四种方式实现\n\n方式一:\n``` objc\nUITableViewCell *cell=[tableView dequeueReusableCellWithIdentifier:cellIdentifier];  \nif (!cell) {\n\tcell=[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier]; \n}\n```\n方式二:UItableViewCell是xib写的\n``` objc\nXXXTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];  \nif (nil == cell) {  \n    cell = [[[NSBundle mainBundle]loadNibNamed:@\"XXXTableViewCell\" owner:self options:nil]lastObject];  \n    cell.selectionStyle=UITableViewCellSelectionStyleNone;  \n    [tableView registerNib:[UINib nibWithNibName:@\"XXXTableViewCell\" bundle:[NSBundle mainBundle]] forCellReuseIdentifier:cellIdentifier];\n}\n```\n方式三:在xib中identifier属性必须写上cellIdentifier ,对应代码中的cellIdentifier\n``` objc\nXXTableViewCell *cell;  \ncell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];  \nif (nil == cell) {  \n    cell= [[[NSBundle mainBundle] loadNibNamed:@\"XXTableViewCell\" owner:nil options:nil] lastObject];  \n}  \nreturn cell;\n```\n方式四：先register cell，然后复用\n``` objc\n#pragma mark - 初始化控件\n\n- (UITableView *)tableView\n{\n    if (!_tableView) {\n        _tableView = [[UITableView alloc]initWithFrame:self.frame style:UITableViewStylePlain];\n        _tableView.backgroundColor = kMainBgColor;\n        _tableView.dataSource = self;\n        _tableView.delegate = self;\n        _tableView.separatorStyle = UITableViewCellSeparatorStyleNone;\n        [_tableView registerClass:[XXXCell_iPhone class] forCellReuseIdentifier:kCellIdentifier_XXXCell];\n        _tableView.tableFooterView = self.loadingFooterView;\n    }\n    return _tableView;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n\t//复用\n    XXXCell_iPhone *cell = [tableView dequeueReusableCellWithIdentifier:kCellIdentifier_XXXCell forIndexPath:indexPath];\n    cell.type = self.type;\n    [cell setExpressOrder:[_list safeObjectAtIndex:indexPath.row] needTopView:indexPath.row == 0];\n    return cell;\n}\n\n```\n\n##  常见问题","source":"_posts/关于UItableView的复用.md","raw":"---\ntitle: 关于UItableView的复用\ndate: 2016-04-05 09:26:44\ntags:\n  - iOS\n  - 笔记\ncategories: iOS学习笔记\n---\n\nUITableView是我从开始接触iOS编程到现在最常用的一个控件，没有之一。这篇文章就先不说UITableView的基本用法了，详细有一点iOS基础的人都应该知道，这里主要想理一理UItableView的复用机制。\n\n## 概述\n\n为了更清楚明白的描述UItableView的复用机制，我们先假设UItableView如果没有复用机制。如果UItableVIew没有复用机制，我们要展示10000条数据的的话，那就得生成10000条UItableViewCell，这样将会占用大量的内存，并且性能大家可以想象一下（这个UItableView滑动起来一定是相当的卡顿，非常影响用户体验）。\n\n<!-- more -->\n\n关于UItableView的复用机制大概是这样的：假设一个UItableView要加载10000条数据，但是一个屏幕最大只能展示3条数据（这里屏幕最多能展示的数据条数是根据UItableViewCell的高度来定的）。然后当你向上滑动，想要查看更多的内容，那么肯定需要一个cell放在已经存在的内容下边。这个时候并不会重新去创建一个UItableViewCell放在下面，而是根据cellIdetifier去内存池中拿到与之对应的UItableViewCell。\n\n## 复用方式\n\nUItableView的复用方式有如下四种方式实现\n\n方式一:\n``` objc\nUITableViewCell *cell=[tableView dequeueReusableCellWithIdentifier:cellIdentifier];  \nif (!cell) {\n\tcell=[[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifier]; \n}\n```\n方式二:UItableViewCell是xib写的\n``` objc\nXXXTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];  \nif (nil == cell) {  \n    cell = [[[NSBundle mainBundle]loadNibNamed:@\"XXXTableViewCell\" owner:self options:nil]lastObject];  \n    cell.selectionStyle=UITableViewCellSelectionStyleNone;  \n    [tableView registerNib:[UINib nibWithNibName:@\"XXXTableViewCell\" bundle:[NSBundle mainBundle]] forCellReuseIdentifier:cellIdentifier];\n}\n```\n方式三:在xib中identifier属性必须写上cellIdentifier ,对应代码中的cellIdentifier\n``` objc\nXXTableViewCell *cell;  \ncell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];  \nif (nil == cell) {  \n    cell= [[[NSBundle mainBundle] loadNibNamed:@\"XXTableViewCell\" owner:nil options:nil] lastObject];  \n}  \nreturn cell;\n```\n方式四：先register cell，然后复用\n``` objc\n#pragma mark - 初始化控件\n\n- (UITableView *)tableView\n{\n    if (!_tableView) {\n        _tableView = [[UITableView alloc]initWithFrame:self.frame style:UITableViewStylePlain];\n        _tableView.backgroundColor = kMainBgColor;\n        _tableView.dataSource = self;\n        _tableView.delegate = self;\n        _tableView.separatorStyle = UITableViewCellSeparatorStyleNone;\n        [_tableView registerClass:[XXXCell_iPhone class] forCellReuseIdentifier:kCellIdentifier_XXXCell];\n        _tableView.tableFooterView = self.loadingFooterView;\n    }\n    return _tableView;\n}\n\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n{\n\t//复用\n    XXXCell_iPhone *cell = [tableView dequeueReusableCellWithIdentifier:kCellIdentifier_XXXCell forIndexPath:indexPath];\n    cell.type = self.type;\n    [cell setExpressOrder:[_list safeObjectAtIndex:indexPath.row] needTopView:indexPath.row == 0];\n    return cell;\n}\n\n```\n\n##  常见问题","slug":"关于UItableView的复用","published":1,"updated":"2016-06-02T04:03:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gchu000p29we82yzuqsg"},{"title":"全屏设置setStatusBarOrientation 未生效的解决办法","date":"2016-07-06T07:21:10.000Z","_content":"\n最近在一个项目中用到了视频播放组件，并且项目要求视频能够边下边播，并且需要实现视频的缓存，如果下次播放就不要再通过网络去访问播放，而是直接读取本地的缓存文件播放。在实现让视频全屏播放的时候遇到了比较难搞的问题，当视频全屏的时候，视频成功旋转过来了，，但是状态栏的方向始终不能旋转过来。\n手动调用了如下代码，但是并没有什么卵用：\n``` objc\n[[UIApplication sharedApplication]setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];\n```\n经过一番搜索，网上给了各种方法，归纳起来大致是这个样子的：\n\n<!-- more -->\n1. 首先在Info.plist中设置View controller-based status bar appearance为NO\n2. 需要旋转的视频ViewController的方法`- (BOOL)shouldAutorotate`要返回NO，不然手动旋转不会生效。\n\n> Tips:本以为到了这里问题就应该已经解决了，but问题并没有得到解决,覆写`- (BOOL)shouldAutorotate`方法并为生效，或许此时你一定会说:\"WTF?\"\n\n最后的原因是:<span style=\"textColor:'#00ff00'\">由于UIViewController放置在Navigation中，而由于Navigation不人性化的设计，navigation的- (BOOL)shouldAutorotate是不会根据显示ViewController的- (BOOL)shouldAutorotate设置的值来改变的。</span>\n\n最后最终的解决办法是将下面这段代码放在AppDelegate.m的最后面，这个时候NavigationController就会根据你显示的ViewController改变返回值了，然后再去ViewController覆写方法，返回NO，方法生效了！\n``` objc\n@implementation UINavigationController (Rotation)  \n\n- (BOOL)shouldAutorotate  \n{  \n    return [[self.viewControllers lastObject] shouldAutorotate];  \n}  \n\n- (NSUInteger)supportedInterfaceOrientations  \n{  \n    return [[self.viewControllers lastObject] supportedInterfaceOrientations];  \n}  \n\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {  \n    return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];  \n}  \n@end  \n```\n","source":"_posts/全屏设置setStatusBarOrientation-未生效的解决办法.md","raw":"---\ntitle: 全屏设置setStatusBarOrientation 未生效的解决办法\ndate: 2016-07-06 15:21:10\ntags:\n  - StatusBar\ncategories: 常见问题\n---\n\n最近在一个项目中用到了视频播放组件，并且项目要求视频能够边下边播，并且需要实现视频的缓存，如果下次播放就不要再通过网络去访问播放，而是直接读取本地的缓存文件播放。在实现让视频全屏播放的时候遇到了比较难搞的问题，当视频全屏的时候，视频成功旋转过来了，，但是状态栏的方向始终不能旋转过来。\n手动调用了如下代码，但是并没有什么卵用：\n``` objc\n[[UIApplication sharedApplication]setStatusBarOrientation:UIInterfaceOrientationLandscapeRight];\n```\n经过一番搜索，网上给了各种方法，归纳起来大致是这个样子的：\n\n<!-- more -->\n1. 首先在Info.plist中设置View controller-based status bar appearance为NO\n2. 需要旋转的视频ViewController的方法`- (BOOL)shouldAutorotate`要返回NO，不然手动旋转不会生效。\n\n> Tips:本以为到了这里问题就应该已经解决了，but问题并没有得到解决,覆写`- (BOOL)shouldAutorotate`方法并为生效，或许此时你一定会说:\"WTF?\"\n\n最后的原因是:<span style=\"textColor:'#00ff00'\">由于UIViewController放置在Navigation中，而由于Navigation不人性化的设计，navigation的- (BOOL)shouldAutorotate是不会根据显示ViewController的- (BOOL)shouldAutorotate设置的值来改变的。</span>\n\n最后最终的解决办法是将下面这段代码放在AppDelegate.m的最后面，这个时候NavigationController就会根据你显示的ViewController改变返回值了，然后再去ViewController覆写方法，返回NO，方法生效了！\n``` objc\n@implementation UINavigationController (Rotation)  \n\n- (BOOL)shouldAutorotate  \n{  \n    return [[self.viewControllers lastObject] shouldAutorotate];  \n}  \n\n- (NSUInteger)supportedInterfaceOrientations  \n{  \n    return [[self.viewControllers lastObject] supportedInterfaceOrientations];  \n}  \n\n- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {  \n    return [[self.viewControllers lastObject] preferredInterfaceOrientationForPresentation];  \n}  \n@end  \n```\n","slug":"全屏设置setStatusBarOrientation-未生效的解决办法","published":1,"updated":"2016-07-06T10:19:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gchw000t29we1yv7u11m"},{"title":"使用Jenkins构建iOS持续集成自动打包","date":"2016-05-21T07:48:50.000Z","_content":"\n> 持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。\n\n### 为什么使用持续集成\n1、减少重复繁琐的打包过程\n2、任何时间、任何地点测试都可以获取到新包\n3、增强项目的可见性\n\n<!-- more -->\n\n参考文档：\n[一步一步构建iOS持续集成:Jenkins+GitLab+蒲公英+FTP](http://www.jianshu.com/p/c69deb29720d#)\n[使用 Xcodebuild + Jenkins + Apache 做 iOS 持续集成](http://rannie.github.io/ios/2014/12/29/xcodebuild-jenkins-ci.html)","source":"_posts/使用Jenkins构建iOS持续集成自动打包.md","raw":"---\ntitle: 使用Jenkins构建iOS持续集成自动打包\ndate: 2016-05-21 15:48:50\ntags:\n   - Jenkins\n---\n\n> 持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。\n\n### 为什么使用持续集成\n1、减少重复繁琐的打包过程\n2、任何时间、任何地点测试都可以获取到新包\n3、增强项目的可见性\n\n<!-- more -->\n\n参考文档：\n[一步一步构建iOS持续集成:Jenkins+GitLab+蒲公英+FTP](http://www.jianshu.com/p/c69deb29720d#)\n[使用 Xcodebuild + Jenkins + Apache 做 iOS 持续集成](http://rannie.github.io/ios/2014/12/29/xcodebuild-jenkins-ci.html)","slug":"使用Jenkins构建iOS持续集成自动打包","published":1,"updated":"2016-05-21T07:55:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gci0000y29wey49njots"},{"title":"iOS几种不同传值方式","date":"2016-03-17T07:17:32.000Z","_content":"\n关于iOS的传值方式我所知道的一共有一下6种方式：\n* 属性传值\n* 代理传值\n* block传值\n* 单例传值\n* 通知传值\n* NSUserDefault保存数据传值\n\n以上六种方式都可以实现iOS不同对象之间的传值，但是针对不同的情况，我们会采取不同的传值方式。\n\n<!-- more -->\n\n## 属性传值\n\n属性传值一般常用在页面中，从一个页面传值到另一个页面。例如从A页面跳转到B页面，如果需要将A页面中的某个值传递到B页面中，这个时候用到最简单的传值方式就是属性传值。\n\n下面是一个简单例子实现将AViewController中UItextFiled中的值传到BViewController中Label中。\nAViewController.m中的代码如下：\n``` objc\n#import \"AViewController.h\"\n#import \"BViewController.h\"\n\n@interface AViewController ()\n\n//定义输入框\n@property (nonatomic, strong) UITextField *textField;\n\n@end\n\n@implementation AViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    \n    [self.view addSubview:self.textField];\n    //定义点击跳转的按钮\n    UIButton *pushBtn = [[UIButton alloc]initWithFrame:CGRectMake(20, 150, 100, 30)];\n    pushBtn.titleLabel.font = [UIFont systemFontOfSize:12];\n    [pushBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n    [pushBtn setTitle:@\"push显示\" forState:UIControlStateNormal];\n    [pushBtn setBackgroundColor:[UIColor yellowColor]];\n    [pushBtn addTarget:self action:@selector(pushAction) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:pushBtn];\n}\n\n- (void)pushAction {\n    //定义跳转页面，并给B页面str赋值\n    BViewController *vc = [[BViewController alloc]init];\n    vc.str = self.textField.text;\n    [self.navigationController pushViewController:vc animated:YES];\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n- (UITextField *)textField {\n    if (!_textField) {\n        _textField = [[UITextField alloc]initWithFrame:CGRectMake(20, 100, 280, 30)];\n        _textField.borderStyle = UITextBorderStyleRoundedRect;\n    }\n    return _textField;\n}\n```\n\nBViewController.h文件中，声明被赋值的属性\n``` objc\n#import <UIKit/UIKit.h>\n\n@interface BViewController : UIViewController\n\n@property (nonatomic, copy) NSString *str;\n\n@end\n```\nBViewController.m中显示AViewController传递过来的属性值\n``` objc\n#import \"BViewController.h\"\n\n@interface BViewController ()\n\n@end\n\n@implementation BViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    self.view.backgroundColor = [UIColor whiteColor];\n    \n    UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(20, 100, 100, 20)];\n    label.font = [UIFont systemFontOfSize:14];\n    label.textColor = [UIColor blackColor];\n    //显示AViewController传递过来的值\n    label.text = self.str;\n    [self.view addSubview:label];\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n```\n\n## 代理传值\n","source":"_posts/iOS几种不同传值方式.md","raw":"---\ntitle: iOS几种不同传值方式\ndate: 2016-03-17 15:17:32\ntags:\n  - iOS\n  - 笔记\n---\n\n关于iOS的传值方式我所知道的一共有一下6种方式：\n* 属性传值\n* 代理传值\n* block传值\n* 单例传值\n* 通知传值\n* NSUserDefault保存数据传值\n\n以上六种方式都可以实现iOS不同对象之间的传值，但是针对不同的情况，我们会采取不同的传值方式。\n\n<!-- more -->\n\n## 属性传值\n\n属性传值一般常用在页面中，从一个页面传值到另一个页面。例如从A页面跳转到B页面，如果需要将A页面中的某个值传递到B页面中，这个时候用到最简单的传值方式就是属性传值。\n\n下面是一个简单例子实现将AViewController中UItextFiled中的值传到BViewController中Label中。\nAViewController.m中的代码如下：\n``` objc\n#import \"AViewController.h\"\n#import \"BViewController.h\"\n\n@interface AViewController ()\n\n//定义输入框\n@property (nonatomic, strong) UITextField *textField;\n\n@end\n\n@implementation AViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    \n    [self.view addSubview:self.textField];\n    //定义点击跳转的按钮\n    UIButton *pushBtn = [[UIButton alloc]initWithFrame:CGRectMake(20, 150, 100, 30)];\n    pushBtn.titleLabel.font = [UIFont systemFontOfSize:12];\n    [pushBtn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n    [pushBtn setTitle:@\"push显示\" forState:UIControlStateNormal];\n    [pushBtn setBackgroundColor:[UIColor yellowColor]];\n    [pushBtn addTarget:self action:@selector(pushAction) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:pushBtn];\n}\n\n- (void)pushAction {\n    //定义跳转页面，并给B页面str赋值\n    BViewController *vc = [[BViewController alloc]init];\n    vc.str = self.textField.text;\n    [self.navigationController pushViewController:vc animated:YES];\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n\n- (UITextField *)textField {\n    if (!_textField) {\n        _textField = [[UITextField alloc]initWithFrame:CGRectMake(20, 100, 280, 30)];\n        _textField.borderStyle = UITextBorderStyleRoundedRect;\n    }\n    return _textField;\n}\n```\n\nBViewController.h文件中，声明被赋值的属性\n``` objc\n#import <UIKit/UIKit.h>\n\n@interface BViewController : UIViewController\n\n@property (nonatomic, copy) NSString *str;\n\n@end\n```\nBViewController.m中显示AViewController传递过来的属性值\n``` objc\n#import \"BViewController.h\"\n\n@interface BViewController ()\n\n@end\n\n@implementation BViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n    self.view.backgroundColor = [UIColor whiteColor];\n    \n    UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(20, 100, 100, 20)];\n    label.font = [UIFont systemFontOfSize:14];\n    label.textColor = [UIColor blackColor];\n    //显示AViewController传递过来的值\n    label.text = self.str;\n    [self.view addSubview:label];\n}\n\n- (void)didReceiveMemoryWarning {\n    [super didReceiveMemoryWarning];\n    // Dispose of any resources that can be recreated.\n}\n```\n\n## 代理传值\n","slug":"iOS几种不同传值方式","published":1,"updated":"2016-06-02T04:10:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gci2001129we9ls6n292"},{"title":"iOS中造成dealloc不调用的原因","date":"2016-04-06T04:18:32.000Z","_content":"\n## 问题描述\n\n最近在一个项目中用到了地图，发现在地图页面和上一个页面间反复切换回出现内存爆增的情况，就像吃了炫迈一样根本停不下来（直到app内存爆表，app闪退收场）。造成这一结果的根本原因是地图的mapView没有释放，导致每次打开地图界面的时候内存中都重新加载了一个地图mapView。于是在网上搜索了一番找到了解决办法，只需要在地图的ViewController中dealloc方法中释放掉mapView就行了。具体代码如下:\n``` objc\n- (void)dealloc {\n    [_mapView release];\n    [super dealloc];\n}\n\n//并且在界面将要显示的时候设置代理，将要消失的时候取消代理\n- (void)viewWillAppear:(BOOL)animated {\n    _mapView.delegate = self;\n}\n\n- (void)viewWillDisappear:(BOOL)animated {\n    _mapView.delegate = nil;\n}\n\n```\n\n<!-- more -->\n\n以上给出的方法确实是对的，可以解决反复切换地图页面和地图上一级页面内存暴增造成的闪退问题。但是这里要说的不是这个问题，而是一个新的问题，我在dealloc中打了断点，但是dealloc根本就没有执行，所以mapView也就根本就没有释放，内存还是一样在暴增。为什么ViewController已经被pop了，而ViewController的dealloc方法却没有被调用？（按理说ViewController被pop的时候它的dealloc的方法应该被调用才对）。\n\n## 解决办法\n\n通过Google搜索终于在晚上找到了答案（大家就不要用百度，想要快速准确的找到自己想要的答案推荐大家用google）。造成ViewController不释放的原因可能有很多。遇到dealloc不调用的时候只需要检查您的ViewController中是否存在以下几个问题：\n\n1. <b>ViewController中存在NSTimer</b>\n\n    如果你的ViewController中有NSTimer，那么你就要注意了，因为当你调用\n``` objc\n[NSTimer scheduledTimerWithTimeInterval:1.0 \n                                 target:self \n                               selector:@selector(updateTime:) \n                               userInfo:nil \n                                repeats:YES];\n```\n    时，这个<a style=\"color: #FF00EE\">target:self</a>就增加了ViewController的return count，如果你不将这个timer invalidate，将别想调用dealloc。\n\n2. <b>ViewController中有关的代理</b>\n\n    一个比较隐秘的因素，你去找找与这个类有关的代理，有没有强引用属性？比如一个代理的delegate应该是 assign 的现在是retain，(╯‵□′)╯︵┻━┻，就是这个，它会影响你不让你调用dealloc，不信，就试试吧。（这个我还没有遇到过）。\n\n3. <b>ViewController中有Block</b>\n\n    这个就是我我上面不进入dealloc的真正原因，Block体内使用实例变量也会造成循环引用，使得拥有这个实例的对象不能释放。\n    例如你这个类叫OneViewController,有个属性是NSString *name; 如果你在block体中使用了self.name，那样子的话这个类就没法释放。\n    要解决这个问题，MRC下只需\n``` objc\n__block Viewcontroller *weakSelf = self;\n```\n    ARC下将__block 换为 __weak\n\n目前我所知道的就以上三种情况，如果有什么错误的地方或者还存在的一些情况，欢迎大家来补充。","source":"_posts/iOS中造成dealloc不调用的原因.md","raw":"---\ntitle: iOS中造成dealloc不调用的原因\ndate: 2016-04-06 12:18:32\ntags:\n---\n\n## 问题描述\n\n最近在一个项目中用到了地图，发现在地图页面和上一个页面间反复切换回出现内存爆增的情况，就像吃了炫迈一样根本停不下来（直到app内存爆表，app闪退收场）。造成这一结果的根本原因是地图的mapView没有释放，导致每次打开地图界面的时候内存中都重新加载了一个地图mapView。于是在网上搜索了一番找到了解决办法，只需要在地图的ViewController中dealloc方法中释放掉mapView就行了。具体代码如下:\n``` objc\n- (void)dealloc {\n    [_mapView release];\n    [super dealloc];\n}\n\n//并且在界面将要显示的时候设置代理，将要消失的时候取消代理\n- (void)viewWillAppear:(BOOL)animated {\n    _mapView.delegate = self;\n}\n\n- (void)viewWillDisappear:(BOOL)animated {\n    _mapView.delegate = nil;\n}\n\n```\n\n<!-- more -->\n\n以上给出的方法确实是对的，可以解决反复切换地图页面和地图上一级页面内存暴增造成的闪退问题。但是这里要说的不是这个问题，而是一个新的问题，我在dealloc中打了断点，但是dealloc根本就没有执行，所以mapView也就根本就没有释放，内存还是一样在暴增。为什么ViewController已经被pop了，而ViewController的dealloc方法却没有被调用？（按理说ViewController被pop的时候它的dealloc的方法应该被调用才对）。\n\n## 解决办法\n\n通过Google搜索终于在晚上找到了答案（大家就不要用百度，想要快速准确的找到自己想要的答案推荐大家用google）。造成ViewController不释放的原因可能有很多。遇到dealloc不调用的时候只需要检查您的ViewController中是否存在以下几个问题：\n\n1. <b>ViewController中存在NSTimer</b>\n\n    如果你的ViewController中有NSTimer，那么你就要注意了，因为当你调用\n``` objc\n[NSTimer scheduledTimerWithTimeInterval:1.0 \n                                 target:self \n                               selector:@selector(updateTime:) \n                               userInfo:nil \n                                repeats:YES];\n```\n    时，这个<a style=\"color: #FF00EE\">target:self</a>就增加了ViewController的return count，如果你不将这个timer invalidate，将别想调用dealloc。\n\n2. <b>ViewController中有关的代理</b>\n\n    一个比较隐秘的因素，你去找找与这个类有关的代理，有没有强引用属性？比如一个代理的delegate应该是 assign 的现在是retain，(╯‵□′)╯︵┻━┻，就是这个，它会影响你不让你调用dealloc，不信，就试试吧。（这个我还没有遇到过）。\n\n3. <b>ViewController中有Block</b>\n\n    这个就是我我上面不进入dealloc的真正原因，Block体内使用实例变量也会造成循环引用，使得拥有这个实例的对象不能释放。\n    例如你这个类叫OneViewController,有个属性是NSString *name; 如果你在block体中使用了self.name，那样子的话这个类就没法释放。\n    要解决这个问题，MRC下只需\n``` objc\n__block Viewcontroller *weakSelf = self;\n```\n    ARC下将__block 换为 __weak\n\n目前我所知道的就以上三种情况，如果有什么错误的地方或者还存在的一些情况，欢迎大家来补充。","slug":"iOS中造成dealloc不调用的原因","published":1,"updated":"2016-06-02T04:02:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gci4001429wemx4g7aj8"},{"title":"iOS上完美编译FFmpeg","date":"2016-03-28T13:50:00.000Z","_content":"\n## 问题描述\n\n最新在使用FFmpeg的时候遇到了如下的报错信息，但是现在一直都还未找到解决办法。\n``` bash\nUndefined symbols for architecture arm64:\n  \"_avcodec_close\", referenced from:\n      CH264Decoder::~CH264Decoder() in H264Decoder.o\n  \"_av_init_packet\", referenced from:\n      CH264Decoder::DecoderFrame(unsigned char*, int, int&, int&) in H264Decoder.o\n  \"_av_malloc\", referenced from:\n      CH264Decoder::CreateYUVTab_16() in H264Decoder.o\n  \"_av_free\", referenced from:\n      CH264Decoder::DeleteYUVTab() in H264Decoder.o\n      CH264Decoder::~CH264Decoder() in H264Decoder.o\n  \"_av_register_all\", referenced from:\n      CH264Decoder::CH264Decoder() in H264Decoder.o\n  \"_avcodec_find_decoder\", referenced from:\n      CH264Decoder::CH264Decoder() in H264Decoder.o\n  \"_avcodec_decode_video2\", referenced from:\n      CH264Decoder::DecoderFrame(unsigned char*, int, int&, int&) in H264Decoder.o\n  \"_avcodec_open2\", referenced from:\n      CH264Decoder::CH264Decoder() in H264Decoder.o\n  \"_avcodec_alloc_context3\", referenced from:\n      CH264Decoder::CH264Decoder() in H264Decoder.o\n  \"_avcodec_alloc_frame\", referenced from:\n      CH264Decoder::CH264Decoder() in H264Decoder.o\nld: symbol(s) not found for architecture arm64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n```\n\n<!-- more -->\n\n## 解决办法\n\n解决办法，直接上图\n\n{% asset_img 1.png 解决办法%}","source":"_posts/iOS上完美编译FFmpeg.md","raw":"---\ntitle: iOS上完美编译FFmpeg\ndate: 2016-03-28 21:50:00\ntags:\n---\n\n## 问题描述\n\n最新在使用FFmpeg的时候遇到了如下的报错信息，但是现在一直都还未找到解决办法。\n``` bash\nUndefined symbols for architecture arm64:\n  \"_avcodec_close\", referenced from:\n      CH264Decoder::~CH264Decoder() in H264Decoder.o\n  \"_av_init_packet\", referenced from:\n      CH264Decoder::DecoderFrame(unsigned char*, int, int&, int&) in H264Decoder.o\n  \"_av_malloc\", referenced from:\n      CH264Decoder::CreateYUVTab_16() in H264Decoder.o\n  \"_av_free\", referenced from:\n      CH264Decoder::DeleteYUVTab() in H264Decoder.o\n      CH264Decoder::~CH264Decoder() in H264Decoder.o\n  \"_av_register_all\", referenced from:\n      CH264Decoder::CH264Decoder() in H264Decoder.o\n  \"_avcodec_find_decoder\", referenced from:\n      CH264Decoder::CH264Decoder() in H264Decoder.o\n  \"_avcodec_decode_video2\", referenced from:\n      CH264Decoder::DecoderFrame(unsigned char*, int, int&, int&) in H264Decoder.o\n  \"_avcodec_open2\", referenced from:\n      CH264Decoder::CH264Decoder() in H264Decoder.o\n  \"_avcodec_alloc_context3\", referenced from:\n      CH264Decoder::CH264Decoder() in H264Decoder.o\n  \"_avcodec_alloc_frame\", referenced from:\n      CH264Decoder::CH264Decoder() in H264Decoder.o\nld: symbol(s) not found for architecture arm64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n```\n\n<!-- more -->\n\n## 解决办法\n\n解决办法，直接上图\n\n{% asset_img 1.png 解决办法%}","slug":"iOS上完美编译FFmpeg","published":1,"updated":"2016-06-02T04:03:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gci6001529wec85ab83u"},{"title":"iOS UIWebView简单使用","date":"2016-03-26T07:44:12.000Z","_content":"\nUIVebView可以帮你在App中创建一个网页浏览器，来加载一些网页展示页面。现在我们可能会看到很多的app中或多或多或少都有嵌入一些h5的页面，对于一些复杂的页面有h5来展示时一种不错的办法。\n\n下面我想简单记录一下UIWebView的简单使用。\n\n1. 创建UIWebView\n``` objc\nCGRect bouds = [[UIScreen manScreen]applicationFrame];  \nUIWebView* webView = [[UIWebView alloc]initWithFrame:bounds]; \n```\n2. 设置相关属性\n``` objc\nwebView.scalespageToFit = YES;\t    //自动对页面进行缩放以适应屏幕  \nwebView.detectsPhoneNumbers = YES;  //自动检测网页上的电话号码，单击可以拨打 \n```\n\n<!-- more -->\n\n3. 显示UIWebView到UIViewController上\n``` objc\n[self.view addSubview:webView];\n```\n4. 加载内容\n\n    加载一个完整的网页的内容\n``` objc\nNSURL* url = [NSURL URLWithString:@\"http://www.youku.com\"];//创建URL  \nNSURLRequest* request = [NSURLRequest requestWithURL:url]; //创建NSURLRequest  \n[webView loadRequest:request];                             //加载  \n```\n    加载本地网页资源\n``` objc\nNSURL* url = [NSURL   fileURLWithPath:filePath];          //创建URL  \nNSURLRequest* request = [NSURLRequest requestWithURL:url];//创建NSURLRequest  \n[webView loadRequest:request];                            //加载  \n```\n    加载带标签的htmlString，你可以提供一个基础URL,来指导UIWebView对象如何跟随链加载远程资源\n``` objc\n[self.webContentView loadHTMLString:@\"<a>hahhaha</a>\" baseURL:nil];//显示带标签的字符串\n```\n5. 导航\n\n    UIWebView内部会管理浏览器的导航动作，通过goForward和goBack方法你可以控制前进与后退动作\n``` objc\n[webView goBack];          //后退\n[webView goForward];       //前进\n[webView reload];          //重载  \n[webView stopLoading];     //取消载入内容\n```\n6. UIWebViewDelegate委托代理\n\n    UIWebViewDelegate的一组代理方法在特定时间会得到通知，要使用这些方法必须先设定webView的委托\n``` objc\nwebView.delegate = self;\n```\n    具体的一些委托方法有\n``` objc\n/**\n *  当网页视图被指示载入内容而得到通知。应当返回YES，这样会进行加载\n *  通过导航类型参数可以得到请求发起的原因，可以是以下任意值：\n *  UIWebViewNavigationTypeLinkClicked\n *  UIWebViewNavigationTypeFormSubmitted\n *  UIWebViewNavigationTypeBackForward\n *  UIWebViewNavigationTypeReload\n *  UIWebViewNavigationTypeFormResubmitted\n *  UIWebViewNavigationTypeOther\n */\n-(BOOL)webView:(UIWebView*)webView \nshouldStartLoadWithRequest:(NSURLRequest*) reuqest \nnavigationType:(UIWebViewNavigationType)navigationType;  \n\n//当网页视图已经开始加载一个请求后，得到通知。\n-(void)webViewDidStartLoad:(UIWebView*)webView;\n\n//当网页视图结束加载一个请求之后，得到通知。 \n-(void)webViewDidFinishLoad:(UIWebView*)webView;\n\n//当在请求加载中发生错误时，得到通知。会提供一个NSSError对象，以标识所发生错误类型。\n-(void)webView:(UIWebView*)webView  DidFailLoadWithError:(NSError*)error;  \n\n```","source":"_posts/iOS-UIWebView简单使用.md","raw":"---\ntitle: iOS UIWebView简单使用\ndate: 2016-03-26 15:44:12\ntags:\n---\n\nUIVebView可以帮你在App中创建一个网页浏览器，来加载一些网页展示页面。现在我们可能会看到很多的app中或多或多或少都有嵌入一些h5的页面，对于一些复杂的页面有h5来展示时一种不错的办法。\n\n下面我想简单记录一下UIWebView的简单使用。\n\n1. 创建UIWebView\n``` objc\nCGRect bouds = [[UIScreen manScreen]applicationFrame];  \nUIWebView* webView = [[UIWebView alloc]initWithFrame:bounds]; \n```\n2. 设置相关属性\n``` objc\nwebView.scalespageToFit = YES;\t    //自动对页面进行缩放以适应屏幕  \nwebView.detectsPhoneNumbers = YES;  //自动检测网页上的电话号码，单击可以拨打 \n```\n\n<!-- more -->\n\n3. 显示UIWebView到UIViewController上\n``` objc\n[self.view addSubview:webView];\n```\n4. 加载内容\n\n    加载一个完整的网页的内容\n``` objc\nNSURL* url = [NSURL URLWithString:@\"http://www.youku.com\"];//创建URL  \nNSURLRequest* request = [NSURLRequest requestWithURL:url]; //创建NSURLRequest  \n[webView loadRequest:request];                             //加载  \n```\n    加载本地网页资源\n``` objc\nNSURL* url = [NSURL   fileURLWithPath:filePath];          //创建URL  \nNSURLRequest* request = [NSURLRequest requestWithURL:url];//创建NSURLRequest  \n[webView loadRequest:request];                            //加载  \n```\n    加载带标签的htmlString，你可以提供一个基础URL,来指导UIWebView对象如何跟随链加载远程资源\n``` objc\n[self.webContentView loadHTMLString:@\"<a>hahhaha</a>\" baseURL:nil];//显示带标签的字符串\n```\n5. 导航\n\n    UIWebView内部会管理浏览器的导航动作，通过goForward和goBack方法你可以控制前进与后退动作\n``` objc\n[webView goBack];          //后退\n[webView goForward];       //前进\n[webView reload];          //重载  \n[webView stopLoading];     //取消载入内容\n```\n6. UIWebViewDelegate委托代理\n\n    UIWebViewDelegate的一组代理方法在特定时间会得到通知，要使用这些方法必须先设定webView的委托\n``` objc\nwebView.delegate = self;\n```\n    具体的一些委托方法有\n``` objc\n/**\n *  当网页视图被指示载入内容而得到通知。应当返回YES，这样会进行加载\n *  通过导航类型参数可以得到请求发起的原因，可以是以下任意值：\n *  UIWebViewNavigationTypeLinkClicked\n *  UIWebViewNavigationTypeFormSubmitted\n *  UIWebViewNavigationTypeBackForward\n *  UIWebViewNavigationTypeReload\n *  UIWebViewNavigationTypeFormResubmitted\n *  UIWebViewNavigationTypeOther\n */\n-(BOOL)webView:(UIWebView*)webView \nshouldStartLoadWithRequest:(NSURLRequest*) reuqest \nnavigationType:(UIWebViewNavigationType)navigationType;  \n\n//当网页视图已经开始加载一个请求后，得到通知。\n-(void)webViewDidStartLoad:(UIWebView*)webView;\n\n//当网页视图结束加载一个请求之后，得到通知。 \n-(void)webViewDidFinishLoad:(UIWebView*)webView;\n\n//当在请求加载中发生错误时，得到通知。会提供一个NSSError对象，以标识所发生错误类型。\n-(void)webView:(UIWebView*)webView  DidFailLoadWithError:(NSError*)error;  \n\n```","slug":"iOS-UIWebView简单使用","published":1,"updated":"2016-06-02T04:04:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gci9001629wet9ry6umr"},{"title":"Swift开源项目汇总","date":"2016-04-11T07:06:52.000Z","_content":"> 拥有着苹果先天生态优势的Swift自发布以来，各种优秀的开源项目便层出不穷。我站在个人的角度，将Swift开源项目做了一个甄别、筛选，从工具、存储、网络、界面、框架到Demo以及完整应用等，满满的干货。\n\n虽然现在对Swift还停留在入门水平，但是还是觉得有必要去网上收集一些优秀的Swift开源项目。\n\n## 界面类\n\n* [TextFieldEffects](https://github.com/raulriera/TextFieldEffects)\n你不觉得标准的UITextField有一点无聊吗？我也是——所以对TextFieldEffects说hello吧！\n\n* [FloatLabelFields](https://github.com/FahimF/FloatLabelFields)\n带浮动标签的输入框\n\n<!-- more -->\n* [MGSwipeTableCell](https://github.com/MortimerGoro/MGSwipeTableCell)\n另一个UI组件，在很多app里都常见，苹果应该考虑在iOS标准库里加入类似的东西。可滑动的table cell，这是这个pod最好的描述。\n\n* [LTMorphingLabel](https://github.com/lexrus/LTMorphingLabel)\n有超赞特效效果的Label\n\n* [Instructions](https://github.com/ephread/Instructions)\n操作指引框架\n\n* [Onboard](https://github.com/mamaral/Onboard)\n启动导航界面，很方便的集成\n\n* [SnapKit](https://github.com/SnapKit/SnapKit)\nSwift布局框架 在代码中纯手工创建约束灰常痛苦，但幸运的是我们有了SnapKit，在board中用上它，你可以简单直观地编写约束了\n\n## 工具类\n* [PermissionScope](https://github.com/nickoneill/PermissionScope)\n用这个库可以在询问用户前，就告知用户所需的系统权限，为用户带来更好的体验。接受度更高—>更多活跃用户->更高的留存率->数据更好->下载率更高\n\n* [Quick](https://github.com/Quick/Quick)\nSwift里的单元测试。\n\n* [IAPHelper](https://github.com/saturngod/IAPHelper)\napp内购带给我们很多陈词滥调的代码，用这个库就不需要了，把最有关交易金钱的普遍的任务从iOS用户到你的（或者你的公司的）钱包简单包装起来。\n\n* [SwiftyJSON](https://github.com/SwiftyJSON/SwiftyJSON)\nGitHub上最为开发者认可的JSON解析类\n\n* [Dollar](https://github.com/ankurp/Dollar)\nSwift版Lo-Dash(或underscore)函数式工具库\n\n* [XCGLogger](https://github.com/DaveWoodCom/XCGLogger)\n功能完整的日志管理类库\n\n* [Surge](https://github.com/mattt/Surge)\n基于苹果Accelerate高性能计算框架封装库\n\n* [Async](https://github.com/duemunk/Async)\n简洁的后台执行代码封装库\n\n* [Siren](https://github.com/ArtSabintsev/Siren)\n当应用更新时，通知用户并提供App Store链接\n\n* [BrightFutures](https://github.com/Thomvis/BrightFutures)\n漫长或复杂计算由独立线程异步来完成\n\n* [AEXML](https://github.com/tadija/AEXML)\n简单又易于的XML解析类及示例\n\n* [AMScrollingNavbar](https://github.com/andreamazz/AMScrollingNavbar)\nswift语言编写 上下滑动时动态隐藏标题栏\n\n## 存储类\n\n* [SQLite.swift](https://github.com/stephencelis/SQLite.swift)\nswift版本简单、轻量，使用上最SQL的SQLite封装库\n\n## 网络类\n\n* [Alamofire](https://github.com/Alamofire/Alamofire)\nAFNetworking网络基础库Swift语言版\n\n* [RxAlamofire](https://github.com/RxSwiftCommunity/RxAlamofire)\n对 Alamofire的封装，很是强大\n\n## 基础工具类以及Category\n\n* [BFKit Swift版本](https://github.com/FabrizioBrancati/BFKit-Swift)\n国外的一个大神写的很好用的分类，比较齐全\n\n## 图片类\n\n* [AlamofireImage](https://github.com/Alamofire/AlamofireImage)\nswift版本的SDWebImage\n\n* [ImageScout](https://github.com/kaishin/ImageScout)\n最小网络代价获得图片大小及类型\n\n* [DominantColor](https://github.com/indragiek/DominantColor)\n提取图片主色示例项目\n\n* [Toucan](https://github.com/gavinbunney/Toucan)\n小而美的图片变换及处理类\n\n* [gifu](https://github.com/kaishin/gifu)\n高性能GIF显示类库\n\n* [HanekeSwift](https://github.com/Haneke/HanekeSwift)\n轻量带缓存高性能图片加载组件\n\n## 框架类\n\n* [ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)\nReactiveCocoa带给我们一种完全不同的编程方式/结构，基于值的信号和流。这是完全的头脑风暴，首先你需要忘记你曾经学习的来理解它是如何工作的。这不是一个简单的任务，但是是有回报的。\n\n* [Spring](https://github.com/MengTo/Spring)\n\n* [Cartography](https://github.com/robb/Cartography)\n基于代码级的自动布局封装框架\n\n* [MMWormhole](https://github.com/mutualmobile/MMWormhole)\niOS扩展与宿主应用的通讯框架\n\n## 示例项目\n\n* [Design-Patterns-In-Swift](https://github.com/ochococo/Design-Patterns-In-Swift)\n如何使用常用设计模式及示例\n\n* [hamburger-button](https://github.com/robb/hamburger-button)\n无论设计还是代码，都进行了精雕细琢\n\n## 完整项目\n\n* [edhita](https://github.com/tnantoka/edhita)\n支持Markdown, HTML预览的文本编辑器\n\n* [firefox-ios](https://github.com/mozilla/firefox-ios)\n来自Mozilla开发团队大型纯Swift项目\n\n* [SwiftWeather](https://github.com/JakeLin/SwiftWeather)\n清新淡雅持续改进天气预报项目","source":"_posts/Swift开源项目汇总.md","raw":"---\ntitle: Swift开源项目汇总\ndate: 2016-04-11 15:06:52\ntags:\n  - iOS\n  - Swift\n---\n> 拥有着苹果先天生态优势的Swift自发布以来，各种优秀的开源项目便层出不穷。我站在个人的角度，将Swift开源项目做了一个甄别、筛选，从工具、存储、网络、界面、框架到Demo以及完整应用等，满满的干货。\n\n虽然现在对Swift还停留在入门水平，但是还是觉得有必要去网上收集一些优秀的Swift开源项目。\n\n## 界面类\n\n* [TextFieldEffects](https://github.com/raulriera/TextFieldEffects)\n你不觉得标准的UITextField有一点无聊吗？我也是——所以对TextFieldEffects说hello吧！\n\n* [FloatLabelFields](https://github.com/FahimF/FloatLabelFields)\n带浮动标签的输入框\n\n<!-- more -->\n* [MGSwipeTableCell](https://github.com/MortimerGoro/MGSwipeTableCell)\n另一个UI组件，在很多app里都常见，苹果应该考虑在iOS标准库里加入类似的东西。可滑动的table cell，这是这个pod最好的描述。\n\n* [LTMorphingLabel](https://github.com/lexrus/LTMorphingLabel)\n有超赞特效效果的Label\n\n* [Instructions](https://github.com/ephread/Instructions)\n操作指引框架\n\n* [Onboard](https://github.com/mamaral/Onboard)\n启动导航界面，很方便的集成\n\n* [SnapKit](https://github.com/SnapKit/SnapKit)\nSwift布局框架 在代码中纯手工创建约束灰常痛苦，但幸运的是我们有了SnapKit，在board中用上它，你可以简单直观地编写约束了\n\n## 工具类\n* [PermissionScope](https://github.com/nickoneill/PermissionScope)\n用这个库可以在询问用户前，就告知用户所需的系统权限，为用户带来更好的体验。接受度更高—>更多活跃用户->更高的留存率->数据更好->下载率更高\n\n* [Quick](https://github.com/Quick/Quick)\nSwift里的单元测试。\n\n* [IAPHelper](https://github.com/saturngod/IAPHelper)\napp内购带给我们很多陈词滥调的代码，用这个库就不需要了，把最有关交易金钱的普遍的任务从iOS用户到你的（或者你的公司的）钱包简单包装起来。\n\n* [SwiftyJSON](https://github.com/SwiftyJSON/SwiftyJSON)\nGitHub上最为开发者认可的JSON解析类\n\n* [Dollar](https://github.com/ankurp/Dollar)\nSwift版Lo-Dash(或underscore)函数式工具库\n\n* [XCGLogger](https://github.com/DaveWoodCom/XCGLogger)\n功能完整的日志管理类库\n\n* [Surge](https://github.com/mattt/Surge)\n基于苹果Accelerate高性能计算框架封装库\n\n* [Async](https://github.com/duemunk/Async)\n简洁的后台执行代码封装库\n\n* [Siren](https://github.com/ArtSabintsev/Siren)\n当应用更新时，通知用户并提供App Store链接\n\n* [BrightFutures](https://github.com/Thomvis/BrightFutures)\n漫长或复杂计算由独立线程异步来完成\n\n* [AEXML](https://github.com/tadija/AEXML)\n简单又易于的XML解析类及示例\n\n* [AMScrollingNavbar](https://github.com/andreamazz/AMScrollingNavbar)\nswift语言编写 上下滑动时动态隐藏标题栏\n\n## 存储类\n\n* [SQLite.swift](https://github.com/stephencelis/SQLite.swift)\nswift版本简单、轻量，使用上最SQL的SQLite封装库\n\n## 网络类\n\n* [Alamofire](https://github.com/Alamofire/Alamofire)\nAFNetworking网络基础库Swift语言版\n\n* [RxAlamofire](https://github.com/RxSwiftCommunity/RxAlamofire)\n对 Alamofire的封装，很是强大\n\n## 基础工具类以及Category\n\n* [BFKit Swift版本](https://github.com/FabrizioBrancati/BFKit-Swift)\n国外的一个大神写的很好用的分类，比较齐全\n\n## 图片类\n\n* [AlamofireImage](https://github.com/Alamofire/AlamofireImage)\nswift版本的SDWebImage\n\n* [ImageScout](https://github.com/kaishin/ImageScout)\n最小网络代价获得图片大小及类型\n\n* [DominantColor](https://github.com/indragiek/DominantColor)\n提取图片主色示例项目\n\n* [Toucan](https://github.com/gavinbunney/Toucan)\n小而美的图片变换及处理类\n\n* [gifu](https://github.com/kaishin/gifu)\n高性能GIF显示类库\n\n* [HanekeSwift](https://github.com/Haneke/HanekeSwift)\n轻量带缓存高性能图片加载组件\n\n## 框架类\n\n* [ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)\nReactiveCocoa带给我们一种完全不同的编程方式/结构，基于值的信号和流。这是完全的头脑风暴，首先你需要忘记你曾经学习的来理解它是如何工作的。这不是一个简单的任务，但是是有回报的。\n\n* [Spring](https://github.com/MengTo/Spring)\n\n* [Cartography](https://github.com/robb/Cartography)\n基于代码级的自动布局封装框架\n\n* [MMWormhole](https://github.com/mutualmobile/MMWormhole)\niOS扩展与宿主应用的通讯框架\n\n## 示例项目\n\n* [Design-Patterns-In-Swift](https://github.com/ochococo/Design-Patterns-In-Swift)\n如何使用常用设计模式及示例\n\n* [hamburger-button](https://github.com/robb/hamburger-button)\n无论设计还是代码，都进行了精雕细琢\n\n## 完整项目\n\n* [edhita](https://github.com/tnantoka/edhita)\n支持Markdown, HTML预览的文本编辑器\n\n* [firefox-ios](https://github.com/mozilla/firefox-ios)\n来自Mozilla开发团队大型纯Swift项目\n\n* [SwiftWeather](https://github.com/JakeLin/SwiftWeather)\n清新淡雅持续改进天气预报项目","slug":"Swift开源项目汇总","published":1,"updated":"2016-05-21T07:32:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcic001729we70midtax"},{"title":"Swift学习笔记之高级运算符","date":"2016-08-02T07:01:30.000Z","_content":"\n除了基本运算符外，Swift还提供了许多可以对数值进行复杂运算的高级运算符。这些高级运算符包含了在C和objc中已经被大家熟知的位运算符和位移运算符。\n\n与C语言和objc的算数运算符不同，Swift中的算数运算符默认是不会溢出的。所有溢出行为都会被捕获并报告位错误。如果想让系统允许溢出行为，可以选择使用Swift中另一套默认支持溢出的运算符，比如溢出运算符（`&+`）,所有的溢出运算符都是以`&`开头的。\n\n## 位运算符\n\n位运算符可以操作数据结构中每个独立的比特位，它通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源和原始数据也十分有用，比如自定义通信协议传输的数据进行编码和解码。\n\n<!-- more -->\n\n### 按位取反运算符\n\n按位取反运算符（`~`）可以对一个数值的全部比特位进行取反：\n\n{% asset_img bitwiseNOT_2x.png 按位取反运算 %}\n按位取反运算符是一个前缀运算符，需要直接放在运算的数之前，并且它们之间不能加空格。\n\n``` swift\nlet initialBits: UInt8 = 0b00001111   //十进制等于15\nlet invertedBits = ~initialBits       //等于 0b11110000，十进制为240\n```\n\n### 按位与运算符\n\n按位与运算符（`&`）可以对两个数的比特位进行合并。它返回一个新的数，只有当两个数对应位都为`1`的时候，新数的对应位才为`1`。\n\n{% asset_img bitwiseAND_2x.png 按位与运算 %}\n在下面的示例当中，`firstBits` 和 `lastBits` 中间 4 个位的值都为 1。按位与运算符对它们进行了运算，得到二进制数值 `00111100`，等价于无符号十进制数的 60：\n``` swift\nlet firstBits: UInt8 = 0b11111100\nlet lastBits: UInt8  = 0b00111111\nlet middleBits = firstBits & lastBits // 等于 00111100\n```\n\n### 按位或运算符\n\n按位或运算符(`|`)可以对两个数的比特位进行比较，它返回一个新的数，如果两个对应的比特位中有任意一个为`1`时，新数对应位就为`1`。\n\n{% asset_img bitwiseOR_2x.png 按位或运算 %}\n\n在下面的示例中，`someBits` 和 `moreBits` 不同的位会被设置为 `1`。接位或运算符对它们进行了运算，得到二进制数值 `11111110`，等价于无符号十进制数的 `254`：\n``` swift\nlet someBits: UInt8 = 0b10110010\nlet moreBits: UInt8 = 0b01011110\nlet combinedbits = someBits | moreBits // 等于 11111110\n```\n\n### 按位异或运算符\n\n按位异或运算符(`^`)可以对两个数的比特位进行比较，它返回一个新的数，当两个数对应比特位不相同时，新数的对应位就为`1`：\n\n{% asset_img bitwiseXOR_2x.png 按位异或运算 %}\n\n在下面的示例当中，`firstBits` 和 `otherBits` 都有一个自己的位为 `1` 而对方的对应位为 `0` 的位。 按位异或运算符将新数的这两个位都设置为 `1`，同时将其它位都设置为 `0`：\n``` swift\nlet firstBits: UInt8 = 0b00010100\nlet otherBits: UInt8 = 0b00000101\nlet outputBits = firstBits ^ otherBits // 等于 00010001\n```\n\n### 按位左移、右移运算符\n\n按位左移运算符（`<<`）和按位右移运算符（`>>`）可以对一个数的所有位进行指定位数的左移和右移。对一个数的左移和右移一位相当于对一个数乘以2或者除以2。\n\n#### 无符号整数的位移运算\n\n对无符号的整数进行位移的规则如下：\n* 已经存在的位按指定的位数进行左移和右移\n* 任何因移动超出整型存储范围的位都会被丢弃\n* 用`0`来填充位移后产生的空白\n这种方法称为逻辑位移。\n\n以下这张图展示了 `11111111 << 1`（即把 `11111111` 向左移动 `1` 位），和 `11111111 >> 1`（即把 `11111111` 向右移动 `1` 位）的结果。蓝色的部分是被移位的，灰色的部分是被抛弃的，橙色的部分则是被填充进来的：\n\n{% asset_img bitshiftUnsigned_2x.png 按位左移、右移运算 %}\n\n下面的代码演示了 Swift 中的移位运算：\n``` swift\nlet shiftBits: UInt8 = 4 // 即二进制的 00000100\nshiftBits << 1           // 00001000\nshiftBits << 2           // 00010000\nshiftBits << 5           // 10000000\nshiftBits << 6           // 00000000\nshiftBits >> 2           // 00000001\n```\n\n还可以使用位移运算对其它数据类型进行编码和解码。\n\n#### 有符号整数的位移运算\n\n对比无符号整数，有符号整数的位移运算相对就要复杂得多，这种复杂性源于有符号整数的二进制表现新式。\n有符号整数使用第一个比特位（通常称为符号位）来表示这个数的正负。符号为`0`代表正数，为`1`代表负数。其余的比特位（通常称为数值位）存储了实际的值。\n\n{% asset_img bitshiftSignedFour_2x.png  bitshiftSignedFour_2x %}\n\n符号位为 `0`，说明这是一个正数，另外 7 位则代表了十进制数值 4 的二进制表示。\n\n负数的存储方式略有不同。它存储的值的绝对值等于 `2` 的 `n` 次方减去它的实际值（也就是数值位表示的值），这里的 `n` 为数值位的比特位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 `2` 的 `7` 次方，即 `128`。\n这是值为 `-4` 的 `Int8` 型整数的二进制位表现形式：\n\n{% asset_img bitshiftSignedMinusFour_2x.png bitshiftSignedMinusFour_2x %}\n\n这次的符号位为 `1`，说明这是一个负数，另外 7 个位则代表了数值 `124`（即 `128 - 4`）的二进制表示。负数的表示通常被称为二进制补码表示，用这种方法表示负数乍看起来有点奇怪，但它有一下几个优点。\n* 如果想对`-1`和`-4`进行加法运算，我们只需要将这两个数的全部8个比特位相加，并且将计算结果中超出8位的值丢弃,其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：\n{% asset_img bitshiftSignedAddition_2x.png 有符号相加%}\n\n* 当对整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 `0`。\n{% asset_img bitshiftSigned_2x.png 有符号位移 %}\n这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为<b>算术移位</b>。\n由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 `0`。在移位的过程中保持符号位不变，意味着负整数在接近 `0` 的过程中会一直保持为负。\n\n## 溢出运算符\n在默认情况下，当向一个整数赋予超过它容量的值时，Swift默认会报错，而不是产生一个无效的数。这个行为为我们在运算过大或者过小的数的时候提供了额外的安全性。\n例如`Int16`型整数能容纳的有符号整数范围是`-32768`到`32767`,当一个为Int16型变量的值超出了这个范围时，系统会报错：\n``` swift\nvar potentialOverflow = Int16.max // potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数\npotentialOverflow += 1            // 这里会报错\n```\n溢出运算符可以让数值溢出的时候采取截断处理，而非报错。可以使用Swift提供的三个溢出运算符来让系统支持整数溢出运算。这些运算符都是以`&`开头的：\n* 溢出加法 `&+`\n* 溢出减法 `&-`\n* 溢出乘法 `&*`\n\n### 无符号数值上溢\n\n数值有可能出现上溢或者下溢。\n这个示例演示了但我们对一个无符号整数使用溢出加法(`&+`)进行上溢运算时会发生什么：\n``` swift\nvar unsignedOverflow = UInt8.max\n// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255\nunsignedOverflow = unsignedOverflow &+ 1\n// 此时 unsignedOverflow 等于 0\n```\n`unsignedOverflow` 被初始化为 `UInt8` 所能容纳的最大整数（`255`，以二进制表示即 `11111111`）。然后使用了溢出加法运算符（`&+`）对其进行加 1 运算。这使得它的二进制表示正好超出 UInt8 所能容纳的位数，也就导致了数值的溢出，如下图所示。数值溢出后，留在 `UInt8` 边界内的值是 `00000000`，也就是十进制数值的 0。\n{% asset_img overflowAddition_2x.png 上溢 %}\n\n### 无符号数值下溢\n\n同样的，当我们对一个无符号整数使用溢出减法(`&-`)进行下溢运算时也会产生类似的现象：\n``` swift\nvar unsignedOverflow = UInt8.min\n// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0\nunsignedOverflow = unsignedOverflow &- 1\n// 此时 unsignedOverflow 等于 255\n```\n`UInt8` 型整数能容纳的最小值是 `0`，以二进制表示即 `00000000`。当使用溢出减法运算符对其进行减 1 运算时，数值会产生下溢并被截断为 `11111111`， 也就是十进制数值的 `255`。\n{% asset_img overflowUnsignedSubtraction_2x.png 下溢 %}\n\n### 有符号数值溢出\n\n溢出也会发生在有符号整型数值上。在对有符号整型数值进行溢出加法或溢出减法运算时，符号位也需要参与计算。比如下面的例子：\n``` swift\nvar signedOverflow = Int8.min\n// signedOverflow 等于 Int8 所能容纳的最小整数 -128\nsignedOverflow = signedOverflow &- 1\n// 此时 signedOverflow 等于 127\n```\n`Int8`型整数能容纳的最小值是`－128`，以二进制表示即`10000000`。当使用溢出减法运算符对其进行减`1`运算时，符号位被翻转，得到二进制数值`01111111`，也就是十进制的`127`，这个值也是`Int8`型整数所能容纳的最大值。\n\n{% asset_img overflowSignedSubtraction_2x.png 有符数值溢出%}\n\n对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。\n\n## 运算符函数\n类和结构体可以为现有的运算符提供自定义的实现，这通常被称为运算符重载。\n\n下面一个例子展示了如何为自定义的结构体实现加法运算符(`+`)。算数运算符是一个双目运算符，因为它可以对两个值进行运算，同时它还是中缀运算符，因为它出现在两个值中间。\n\n例子中定义了一个名为 `Vector2D` 的结构体用来表示二维坐标向量 `(x, y)`，紧接着定义了一个可以对两个 `Vector2D` 结构体进行相加的运算符函数：\n``` swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\nfunc + (left: Vector2D, right: Vector2D) -> Vector2D {\n    return Vector2D(x: left.x + right.x, y: left.y + right.y)\n}\n```\n该运算符函数被定义为一个全局函数，并且函数的名字与它要进行重载的 `+` 名字一致。因为算术加法运算符是双目运算符，所以这个运算符函数接收两个类型为 `Vector2D` 的参数，同时有一个 `Vector2D` 类型的返回值。\n\n在这个实现中，输入参数分别被命名为 `left` 和 `right`，代表在 + 运算符左边和右边的两个 `Vector2D` 实例。函数返回了一个新的 `Vector2D` 实例，这个实例的 `x` 和 `y` 分别等于作为参数的两个实例的 `x` 和 `y` 的值之和。\n\n这个函数被定义成全局的，而不是 `Vector2D` 结构体的成员方法，所以任意两个 `Vector2D` 实例都可以使用这个中缀运算符：\n``` swift\nlet vector = Vector2D(x: 3.0, y: 1.0)\nlet anotherVector = Vector2D(x: 2.0, y: 4.0)\nlet combinedVector = vector + anotherVector\n// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)\n```\n\n### 前缀和后缀运算符\n上个例子演示了一个双目中缀运算符的自定义实现。类与结构体也能提供标准单目运算符的实现。单目运算符只运算一个值。当运算符出现在值之前时，它就是前缀的（例如 `-a`），而当它出现在值之后时，它就是后缀的（例如 `b!`）。\n\n要实现前缀或者后缀运算符，需要在声明运算符函数的时候在`func`关键字之前指定`prefix`或者`postfix`修饰符。\n``` swift\nprefix func - (vector: Vector2D) -> Vector2D {\n    return Vector2D(x: -vector.x, y: -vector.y)\n}\n```\n这段代码为 `Vector2D` 类型实现了单目负号运算符。由于该运算符是前缀运算符，所以这个函数需要加上 `prefix` 修饰符。\n\n对于简单数值，单目负号运算符可以对它们的正负性进行改变。对于 `Vector2D` 来说，该运算将其 `x` 和 `y` 属性的正负性都进行了改变：\n``` swift\nlet positive = Vector2D(x: 3.0, y: 4.0)\nlet negative = -positive\n// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例\nlet alsoPositive = -negative\n// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例\n```\n\n### 复合赋值运算符\n复合赋值运算符将赋值运算符（`=`）与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符（`+=`）。在实现的时候，需要把运算符的左参数设置成 `inout` 类型，因为这个参数的值会在运算符函数内直接被修改。\n``` swift\nfunc += (inout left: Vector2D, right: Vector2D) {\n    left = left + right\n}\n```\n因为加法运算在之前已经定义过了，所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数，用它来对左值和右值进行相加，并再次赋值给左值：\n``` swift\nvar original = Vector2D(x: 1.0, y: 2.0)\nlet vectorToAdd = Vector2D(x: 3.0, y: 4.0)\noriginal += vectorToAdd\n// original 的值现在为 (4.0, 6.0)\n```\n\n> 注：不能对默认的赋值运算符（`=`）进行重载。只有组合赋值运算符可以被重载。同样地，也无法对三目条件运算符 （`a ? b : c`） 进行重载。\n\n### 等价运算符\n\n自定义的类和结构体没有对等价运算符进行默认实现，等价运算符通常被称为“相等”运算符（`==`）与“不等”运算符（`!=`）。对于自定义类型，Swift 无法判断其是否“相等”，因为“相等”的含义取决于这些自定义类型在你的代码中所扮演的角色。\n\n为了使用等价运算符能对自定义的类型进行判等运算，需要为其提供自定义实现，实现的方法与其它中缀运算符一样：\n``` swift\nfunc == (left: Vector2D, right: Vector2D) -> Bool {\n    return (left.x == right.x) && (left.y == right.y)\n}\nfunc != (left: Vector2D, right: Vector2D) -> Bool {\n    return !(left == right)\n}\n```\n\n## 自定义运算符\n\n除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。\n新的运算符要使用 `operator` 关键字在全局作用域内进行定义，同时还要指定 `prefix`、`infix` 或者 `postfix` 修饰符：\n``` swift\nprefix operator +++ {}\n```\n上面的代码定义了一个新的名为 `+++` 的前缀运算符。对于这个运算符，在 Swift 中并没有意义，因此我们针对 `Vector2D` 的实例来定义它的意义。对这个示例来讲，`+++` 被实现为“前缀双自增”运算符。它使用了前面定义的复合加法运算符来让矩阵对自身进行相加，从而让 `Vector2D` 实例的 `x` 属性和 `y` 属性的值翻倍：\n``` swift\nprefix func +++ (inout vector: Vector2D) -> Vector2D {\n    vector += vector\n    return vector\n}\n```\n","source":"_posts/Swift学习笔记之高级运算符.md","raw":"---\ntitle: Swift学习笔记之高级运算符\ndate: 2016-08-02 15:01:30\ntags:\n---\n\n除了基本运算符外，Swift还提供了许多可以对数值进行复杂运算的高级运算符。这些高级运算符包含了在C和objc中已经被大家熟知的位运算符和位移运算符。\n\n与C语言和objc的算数运算符不同，Swift中的算数运算符默认是不会溢出的。所有溢出行为都会被捕获并报告位错误。如果想让系统允许溢出行为，可以选择使用Swift中另一套默认支持溢出的运算符，比如溢出运算符（`&+`）,所有的溢出运算符都是以`&`开头的。\n\n## 位运算符\n\n位运算符可以操作数据结构中每个独立的比特位，它通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源和原始数据也十分有用，比如自定义通信协议传输的数据进行编码和解码。\n\n<!-- more -->\n\n### 按位取反运算符\n\n按位取反运算符（`~`）可以对一个数值的全部比特位进行取反：\n\n{% asset_img bitwiseNOT_2x.png 按位取反运算 %}\n按位取反运算符是一个前缀运算符，需要直接放在运算的数之前，并且它们之间不能加空格。\n\n``` swift\nlet initialBits: UInt8 = 0b00001111   //十进制等于15\nlet invertedBits = ~initialBits       //等于 0b11110000，十进制为240\n```\n\n### 按位与运算符\n\n按位与运算符（`&`）可以对两个数的比特位进行合并。它返回一个新的数，只有当两个数对应位都为`1`的时候，新数的对应位才为`1`。\n\n{% asset_img bitwiseAND_2x.png 按位与运算 %}\n在下面的示例当中，`firstBits` 和 `lastBits` 中间 4 个位的值都为 1。按位与运算符对它们进行了运算，得到二进制数值 `00111100`，等价于无符号十进制数的 60：\n``` swift\nlet firstBits: UInt8 = 0b11111100\nlet lastBits: UInt8  = 0b00111111\nlet middleBits = firstBits & lastBits // 等于 00111100\n```\n\n### 按位或运算符\n\n按位或运算符(`|`)可以对两个数的比特位进行比较，它返回一个新的数，如果两个对应的比特位中有任意一个为`1`时，新数对应位就为`1`。\n\n{% asset_img bitwiseOR_2x.png 按位或运算 %}\n\n在下面的示例中，`someBits` 和 `moreBits` 不同的位会被设置为 `1`。接位或运算符对它们进行了运算，得到二进制数值 `11111110`，等价于无符号十进制数的 `254`：\n``` swift\nlet someBits: UInt8 = 0b10110010\nlet moreBits: UInt8 = 0b01011110\nlet combinedbits = someBits | moreBits // 等于 11111110\n```\n\n### 按位异或运算符\n\n按位异或运算符(`^`)可以对两个数的比特位进行比较，它返回一个新的数，当两个数对应比特位不相同时，新数的对应位就为`1`：\n\n{% asset_img bitwiseXOR_2x.png 按位异或运算 %}\n\n在下面的示例当中，`firstBits` 和 `otherBits` 都有一个自己的位为 `1` 而对方的对应位为 `0` 的位。 按位异或运算符将新数的这两个位都设置为 `1`，同时将其它位都设置为 `0`：\n``` swift\nlet firstBits: UInt8 = 0b00010100\nlet otherBits: UInt8 = 0b00000101\nlet outputBits = firstBits ^ otherBits // 等于 00010001\n```\n\n### 按位左移、右移运算符\n\n按位左移运算符（`<<`）和按位右移运算符（`>>`）可以对一个数的所有位进行指定位数的左移和右移。对一个数的左移和右移一位相当于对一个数乘以2或者除以2。\n\n#### 无符号整数的位移运算\n\n对无符号的整数进行位移的规则如下：\n* 已经存在的位按指定的位数进行左移和右移\n* 任何因移动超出整型存储范围的位都会被丢弃\n* 用`0`来填充位移后产生的空白\n这种方法称为逻辑位移。\n\n以下这张图展示了 `11111111 << 1`（即把 `11111111` 向左移动 `1` 位），和 `11111111 >> 1`（即把 `11111111` 向右移动 `1` 位）的结果。蓝色的部分是被移位的，灰色的部分是被抛弃的，橙色的部分则是被填充进来的：\n\n{% asset_img bitshiftUnsigned_2x.png 按位左移、右移运算 %}\n\n下面的代码演示了 Swift 中的移位运算：\n``` swift\nlet shiftBits: UInt8 = 4 // 即二进制的 00000100\nshiftBits << 1           // 00001000\nshiftBits << 2           // 00010000\nshiftBits << 5           // 10000000\nshiftBits << 6           // 00000000\nshiftBits >> 2           // 00000001\n```\n\n还可以使用位移运算对其它数据类型进行编码和解码。\n\n#### 有符号整数的位移运算\n\n对比无符号整数，有符号整数的位移运算相对就要复杂得多，这种复杂性源于有符号整数的二进制表现新式。\n有符号整数使用第一个比特位（通常称为符号位）来表示这个数的正负。符号为`0`代表正数，为`1`代表负数。其余的比特位（通常称为数值位）存储了实际的值。\n\n{% asset_img bitshiftSignedFour_2x.png  bitshiftSignedFour_2x %}\n\n符号位为 `0`，说明这是一个正数，另外 7 位则代表了十进制数值 4 的二进制表示。\n\n负数的存储方式略有不同。它存储的值的绝对值等于 `2` 的 `n` 次方减去它的实际值（也就是数值位表示的值），这里的 `n` 为数值位的比特位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 `2` 的 `7` 次方，即 `128`。\n这是值为 `-4` 的 `Int8` 型整数的二进制位表现形式：\n\n{% asset_img bitshiftSignedMinusFour_2x.png bitshiftSignedMinusFour_2x %}\n\n这次的符号位为 `1`，说明这是一个负数，另外 7 个位则代表了数值 `124`（即 `128 - 4`）的二进制表示。负数的表示通常被称为二进制补码表示，用这种方法表示负数乍看起来有点奇怪，但它有一下几个优点。\n* 如果想对`-1`和`-4`进行加法运算，我们只需要将这两个数的全部8个比特位相加，并且将计算结果中超出8位的值丢弃,其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：\n{% asset_img bitshiftSignedAddition_2x.png 有符号相加%}\n\n* 当对整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 `0`。\n{% asset_img bitshiftSigned_2x.png 有符号位移 %}\n这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为<b>算术移位</b>。\n由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 `0`。在移位的过程中保持符号位不变，意味着负整数在接近 `0` 的过程中会一直保持为负。\n\n## 溢出运算符\n在默认情况下，当向一个整数赋予超过它容量的值时，Swift默认会报错，而不是产生一个无效的数。这个行为为我们在运算过大或者过小的数的时候提供了额外的安全性。\n例如`Int16`型整数能容纳的有符号整数范围是`-32768`到`32767`,当一个为Int16型变量的值超出了这个范围时，系统会报错：\n``` swift\nvar potentialOverflow = Int16.max // potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数\npotentialOverflow += 1            // 这里会报错\n```\n溢出运算符可以让数值溢出的时候采取截断处理，而非报错。可以使用Swift提供的三个溢出运算符来让系统支持整数溢出运算。这些运算符都是以`&`开头的：\n* 溢出加法 `&+`\n* 溢出减法 `&-`\n* 溢出乘法 `&*`\n\n### 无符号数值上溢\n\n数值有可能出现上溢或者下溢。\n这个示例演示了但我们对一个无符号整数使用溢出加法(`&+`)进行上溢运算时会发生什么：\n``` swift\nvar unsignedOverflow = UInt8.max\n// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255\nunsignedOverflow = unsignedOverflow &+ 1\n// 此时 unsignedOverflow 等于 0\n```\n`unsignedOverflow` 被初始化为 `UInt8` 所能容纳的最大整数（`255`，以二进制表示即 `11111111`）。然后使用了溢出加法运算符（`&+`）对其进行加 1 运算。这使得它的二进制表示正好超出 UInt8 所能容纳的位数，也就导致了数值的溢出，如下图所示。数值溢出后，留在 `UInt8` 边界内的值是 `00000000`，也就是十进制数值的 0。\n{% asset_img overflowAddition_2x.png 上溢 %}\n\n### 无符号数值下溢\n\n同样的，当我们对一个无符号整数使用溢出减法(`&-`)进行下溢运算时也会产生类似的现象：\n``` swift\nvar unsignedOverflow = UInt8.min\n// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0\nunsignedOverflow = unsignedOverflow &- 1\n// 此时 unsignedOverflow 等于 255\n```\n`UInt8` 型整数能容纳的最小值是 `0`，以二进制表示即 `00000000`。当使用溢出减法运算符对其进行减 1 运算时，数值会产生下溢并被截断为 `11111111`， 也就是十进制数值的 `255`。\n{% asset_img overflowUnsignedSubtraction_2x.png 下溢 %}\n\n### 有符号数值溢出\n\n溢出也会发生在有符号整型数值上。在对有符号整型数值进行溢出加法或溢出减法运算时，符号位也需要参与计算。比如下面的例子：\n``` swift\nvar signedOverflow = Int8.min\n// signedOverflow 等于 Int8 所能容纳的最小整数 -128\nsignedOverflow = signedOverflow &- 1\n// 此时 signedOverflow 等于 127\n```\n`Int8`型整数能容纳的最小值是`－128`，以二进制表示即`10000000`。当使用溢出减法运算符对其进行减`1`运算时，符号位被翻转，得到二进制数值`01111111`，也就是十进制的`127`，这个值也是`Int8`型整数所能容纳的最大值。\n\n{% asset_img overflowSignedSubtraction_2x.png 有符数值溢出%}\n\n对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。\n\n## 运算符函数\n类和结构体可以为现有的运算符提供自定义的实现，这通常被称为运算符重载。\n\n下面一个例子展示了如何为自定义的结构体实现加法运算符(`+`)。算数运算符是一个双目运算符，因为它可以对两个值进行运算，同时它还是中缀运算符，因为它出现在两个值中间。\n\n例子中定义了一个名为 `Vector2D` 的结构体用来表示二维坐标向量 `(x, y)`，紧接着定义了一个可以对两个 `Vector2D` 结构体进行相加的运算符函数：\n``` swift\nstruct Vector2D {\n    var x = 0.0, y = 0.0\n}\nfunc + (left: Vector2D, right: Vector2D) -> Vector2D {\n    return Vector2D(x: left.x + right.x, y: left.y + right.y)\n}\n```\n该运算符函数被定义为一个全局函数，并且函数的名字与它要进行重载的 `+` 名字一致。因为算术加法运算符是双目运算符，所以这个运算符函数接收两个类型为 `Vector2D` 的参数，同时有一个 `Vector2D` 类型的返回值。\n\n在这个实现中，输入参数分别被命名为 `left` 和 `right`，代表在 + 运算符左边和右边的两个 `Vector2D` 实例。函数返回了一个新的 `Vector2D` 实例，这个实例的 `x` 和 `y` 分别等于作为参数的两个实例的 `x` 和 `y` 的值之和。\n\n这个函数被定义成全局的，而不是 `Vector2D` 结构体的成员方法，所以任意两个 `Vector2D` 实例都可以使用这个中缀运算符：\n``` swift\nlet vector = Vector2D(x: 3.0, y: 1.0)\nlet anotherVector = Vector2D(x: 2.0, y: 4.0)\nlet combinedVector = vector + anotherVector\n// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)\n```\n\n### 前缀和后缀运算符\n上个例子演示了一个双目中缀运算符的自定义实现。类与结构体也能提供标准单目运算符的实现。单目运算符只运算一个值。当运算符出现在值之前时，它就是前缀的（例如 `-a`），而当它出现在值之后时，它就是后缀的（例如 `b!`）。\n\n要实现前缀或者后缀运算符，需要在声明运算符函数的时候在`func`关键字之前指定`prefix`或者`postfix`修饰符。\n``` swift\nprefix func - (vector: Vector2D) -> Vector2D {\n    return Vector2D(x: -vector.x, y: -vector.y)\n}\n```\n这段代码为 `Vector2D` 类型实现了单目负号运算符。由于该运算符是前缀运算符，所以这个函数需要加上 `prefix` 修饰符。\n\n对于简单数值，单目负号运算符可以对它们的正负性进行改变。对于 `Vector2D` 来说，该运算将其 `x` 和 `y` 属性的正负性都进行了改变：\n``` swift\nlet positive = Vector2D(x: 3.0, y: 4.0)\nlet negative = -positive\n// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例\nlet alsoPositive = -negative\n// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例\n```\n\n### 复合赋值运算符\n复合赋值运算符将赋值运算符（`=`）与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符（`+=`）。在实现的时候，需要把运算符的左参数设置成 `inout` 类型，因为这个参数的值会在运算符函数内直接被修改。\n``` swift\nfunc += (inout left: Vector2D, right: Vector2D) {\n    left = left + right\n}\n```\n因为加法运算在之前已经定义过了，所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数，用它来对左值和右值进行相加，并再次赋值给左值：\n``` swift\nvar original = Vector2D(x: 1.0, y: 2.0)\nlet vectorToAdd = Vector2D(x: 3.0, y: 4.0)\noriginal += vectorToAdd\n// original 的值现在为 (4.0, 6.0)\n```\n\n> 注：不能对默认的赋值运算符（`=`）进行重载。只有组合赋值运算符可以被重载。同样地，也无法对三目条件运算符 （`a ? b : c`） 进行重载。\n\n### 等价运算符\n\n自定义的类和结构体没有对等价运算符进行默认实现，等价运算符通常被称为“相等”运算符（`==`）与“不等”运算符（`!=`）。对于自定义类型，Swift 无法判断其是否“相等”，因为“相等”的含义取决于这些自定义类型在你的代码中所扮演的角色。\n\n为了使用等价运算符能对自定义的类型进行判等运算，需要为其提供自定义实现，实现的方法与其它中缀运算符一样：\n``` swift\nfunc == (left: Vector2D, right: Vector2D) -> Bool {\n    return (left.x == right.x) && (left.y == right.y)\n}\nfunc != (left: Vector2D, right: Vector2D) -> Bool {\n    return !(left == right)\n}\n```\n\n## 自定义运算符\n\n除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。\n新的运算符要使用 `operator` 关键字在全局作用域内进行定义，同时还要指定 `prefix`、`infix` 或者 `postfix` 修饰符：\n``` swift\nprefix operator +++ {}\n```\n上面的代码定义了一个新的名为 `+++` 的前缀运算符。对于这个运算符，在 Swift 中并没有意义，因此我们针对 `Vector2D` 的实例来定义它的意义。对这个示例来讲，`+++` 被实现为“前缀双自增”运算符。它使用了前面定义的复合加法运算符来让矩阵对自身进行相加，从而让 `Vector2D` 实例的 `x` 属性和 `y` 属性的值翻倍：\n``` swift\nprefix func +++ (inout vector: Vector2D) -> Vector2D {\n    vector += vector\n    return vector\n}\n```\n","slug":"Swift学习笔记之高级运算符","published":1,"updated":"2016-08-02T07:04:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcif001b29wetlg3hlgg"},{"title":"Swift学习笔记之闭包","date":"2016-06-01T01:20:16.000Z","_content":"\n## 概述\n\n一般来说，在学习一个新的东西前我们都需要先了解这个东西的定义。在Swift中的闭包是什么呢？\n> 闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift中的闭包与C和objc中的代码块(blocks)以及其它一些语言中的匿名函数比较相似。\n\n闭包可以捕获和存储其所在上下文中任意常量和变量的引用。这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift 会为您管理在捕获过程中涉及到的所有内存操作。\n\n<!-- more -->\n\n全局和嵌套函数其实也是特殊的闭包，闭包采取如下三种形式之一：\n* 全局函数是一个有名字但不会捕获任何值的闭包\n* 嵌套函数是一个有名字并可以捕获其封闭函数内值的闭包\n* 闭包表达式是一个利用轻量级语法\t所写的可以捕获其上下文中变量或常量值的匿名闭包\n\nSwift表达式拥有简洁的风格，并鼓励在常见场景进行语法优化，主要有如下优化方式\n* 利用上下文推断判断参数和返回值类型\n* 隐式返回单表达式闭包，即单表达式可以省略`return`关键字\n* 参数名称缩写\n* 尾随（Trailing）闭包语法\n\n## 闭包表达式\n\n闭包表达式是一种利用简洁语法构建内联闭包的方式，闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过几次迭代展示了`sort`方法定义和语法优化的方式。每一次都用更简洁的方式描述了相同的功能。\n\n### sort方法\n\nSwift标准库提供了名为`sort`的方法，会根据您提供的用于排序的闭包函数将已知类型数组中的值进行排序。一旦排序完成，`sort`方法会返回一个与原数组大小相同，包含同类型元素且元素已正确排序的新数组。原数组并不会被`sort`方法修改。\n\n``` Swift\t\nlet names = [\"Jay\", \"Vae\", \"Jvaeyhcd\", \"Tom\", \"Jack\"]\n\nfunc sortFun(s1:String, s2:String) -> Bool {\n    return s1 > s2\n}\n\nvar sortedNames = names.sort(sortFun)\n```\n该例子是对一个`String`类型的数组进行排序，因此排序闭包函数类型需为`(String,String)->Bool`。提供排序闭包函数的方式是写一个符合其类型要求的普通函数，并将其作为`sort`的参数传入。然而，这是一个相当冗长的方式，本质上只是写一个单表达式函数（`s1 > s2`）。下面例子中，利用闭包表达式可以更好地构建一个内联排序闭包。\n\n### 闭包表达式语法\n\n闭包表达式语法一般如下：\n``` Swift\n{ (parameters) -> returnType in\n    statements\n}\n```\n闭包表达式可以使用变量、常量以及`inout`类型作为参数，但是不能提供默认值。也可以在参数列表的最后使用可变参数，元组也可以作为参数和返回值。\n\n下面例子展示了上面`sortFun(_:_:)`函数对应的闭包表达式版本的代码：\n``` Swift\nsortedNames = names.sort({\n    (s1:String, s2:String)->Bool in\n    return s1 < s2\n})\n```\n需要注意的是内联闭包参数和返回值类型申明与`sortFun(_:_:)`类型申明相同。两种方式中，都写成了`(s1:String, s2:String)->Bool`。然而在内联表达式中，函数和返回值类型都写在大括号内，而不是大括号外。\n闭包函数体部分由关键字`in`引入。该关键字表示闭包的参数和返回值类型都已定义完成，闭包函数体即将开始。由于这个闭包函数体部分如此短，以至于可以将其写成一行代码：\n``` Swift\nsortedNames = names.sort({(s1:String, s2:String) -> Bool in return s1 < s2})\n```\n该例中`sort(_:)`方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。\n\n### 根据上下文推断类型\n\n因为排序闭包函数是作为`sort(_:)`方法参数传入的，Swift可判断其参数和返回值的类型。`sort(_:)`方法被一个字符串数组调用，此参数必须是`(String, String)->Bool`类型的函数。这意味着`(String, String)`和`Bool`类型并不是必须作为闭包表达式定义的一部分。因为所有类型都可以被正确判断，返回箭头(`->`)和围绕在周围的括号也可以被省略：\n\n``` Swift\nsortedNames = names.sort({s1, s2 in return s1 > s2})\n```\n实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，都可以推断出闭包的参数和返回值类型。 这意味着闭包作为函数或者方法的参数时，您几乎不需要利用完整格式构造内联闭包。\n\n尽管如此，您仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则可以采用完整格式的闭包。\n\n### 单表达式闭包隐式返回\n单行表达式闭包可以通过省略`return`关键字来隐式返回单行表达式的结果，如上面版本代码可以改写为：\n``` Swift\nsortedNames = names.sort({s1, s2 in s1 > s2})\n```\n在这个例子中，`sort(_:)`方法的参数类型明确了闭包必须返回一个`Bool`类型值。因为闭包函数体只包含了一个单一表达式（`s1 > s2`），该表达式返回`Bool`类型值，因此这里没有歧义，`return`关键字可以省略。\n\n### 参数名称缩写\nSwift自动为内联包提供了参数名称缩写功能，你可以直接通过`$0`,`$1`,`$2`来顺序调用闭包的参数，以此类推。如果您在闭包表达式中使用参数名缩写，你可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行推断。`in`关键字同样也可以被省略，因此闭包表达式完全由闭包函数体构成：\n``` Swift\nsortedNames = names.sort({$0 > $1})\n```\n在这个例子中，`$0`和`$1`表示闭包中第一个和第二个`String`类型的参数。\n\n### 运算符函数\n实际上还有更简单的方式来实现上面例子中的闭包表达式。Swift中`String`类型定义了关于大于符号(`>`)的字符串实现，其作为一个函数接收两个`String`类型的参数并返回`Bool`类型的值。而这正好与`sort(_:)`方法的参数需要的函数类型相符合。因此，您可以简单地传递一个大于号，Swift 可以自动推断出您想使用大于号的字符串函数实现：\n``` Swift\nsortedNames = names.sort(>)\n```\n\n## 尾随闭包\n\n如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。尾随闭包是一个书写在函数括号后的闭包表达式，函数支持将其作为最后一个参数调用：\n``` Swift\nfunc someFunctionThatTakesAClosure(closure: () -> Void) {\n    // 函数体部分\n}\n\n// 以下是不使用尾随闭包进行函数调用\nsomeFunctionThatTakesAClosure({\n    // 闭包主体部分\n})\n\n// 以下是使用尾随闭包进行函数调用\nsomeFunctionThatTakesAClosure() {\n    // 闭包主体部分\n}\n```\n\n所以上面`sort(_:)`方法参数字符串排序闭包可以改写为\n``` Swift\nsortedNumbers = numbers.sort{$0 > $1}\n```\n如果函数只需要闭包表达式一个参数，当使用尾随闭包时可以把`()`省略\n``` Swift\nsortedNumbers = numbers.sort(){$0 > $1}\n```\n当闭包非常长以至于不能在一行进行书写，尾随闭包变得非常有用。举个例子来说，Swifte的`Array`类型有一个`map(_:)`方法，其获取一个闭包表达式作为唯一参数。该闭包函数会为数组中的额每一个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。当提供给数组的闭包用于数组每个元素后，`map(_:)`方法将返回一个新的数组，数组中包含了与原数组中的元素一一对应的映射后的值。\n``` Swift\nlet digitNames = [\n    0:\"Zero\", 1:\"One\", 2:\"Two\", 3:\"Three\", 4:\"Four\",\n    5:\"Five\", 6:\"Six\", 7:\"Seven\", 8:\"Eight\", 9:\"Nine\"\n]\n\nnumbers = [34, 65, 89]\n\nlet strings = numbers.map {\n    (number) -> String in\n    \n    var number = number\n    var output = \"\"\n    \n    while number > 0 {\n        output = digitNames[number % 10]! + output\n        number /= 10\n    }\n    \n    return output\n}\n\nprint(strings)\n```\n上面示例代码展示了如何在`map(_:)`方法中使用尾随闭包将`Int`类型的数组`[34, 65, 89]`转换为包含对应`String`类型值的数组`[\"ThreeFour\", \"SixFive\", \"EightNine\"]`。\n`map(_:)`为数组中每一个元素调用了闭包表达式。您不需要指定闭包的输入参数`number`的类型，因为可以通过要映射的数组类型进行推断。\n在该例中，局部变量`number`的值由闭包中的`numbe`r参数获得,因此可以在闭包函数体内对其进行修改，(闭包或者函数的参数总是固定的),闭包表达式指定了返回类型为`String`，以表明存储映射值的新数组类型为`String`。\n\n闭包表达式在每次被调用的时候创建了一个叫做`output`的字符串并返回。其使用求余运算符（`number % 10`）计算最后一位数字并利用`digitNames`字典获取所映射的字符串。\n\n> 注：字典digitNames下标后跟着一个叹号（`!`），因为字典下标返回一个可选值（optional value），表明该键不存在时会查找失败。在上例中，由于可以确定`number % 10`总是digitNames字典的有效下标，因此叹号可以用于强制解包 (force-unwrap) 存储在下标的可选类型的返回值中的`String`类型的值。\n\n## 捕获值\n闭包可以在其被定义的上下文中捕获常量或者变量。即使定义这些常量或变量的作用域已经不在，闭包仍然可以在闭包函数体内引用和修改这些值。Swift中可捕获值的最简单的形势就是嵌套函数，也就是定义在其它函数内的函数。嵌套函数可以捕获其外部函数所有的参数以及常量和变量。\n\n举个例子：\n``` Swift\nfunc makeIncrementor(forIncrement amount: Int) -> () -> Int {\n    var runningTotal = 0\n    func incrementor() -> Int {\n        runningTotal += amount\n        return runningTotal\n    }\n    return incrementor\n}\n\nlet incrementByOne = makeIncrementor(forIncrement: 1)\nincrementByOne()//返回1\nincrementByOne()//返回2\n\nlet incrementByTen = makeIncrementor(forIncrement: 10)\nincrementByTen()//返回10\nincrementByOne()//返回3\n```\n上面例子中有一个叫`makeIncrementor`的函数，它包含了一个叫`incrementor`的嵌套函数。嵌套函数`incrementor`从上下文捕获了两个值`runningTotal`和`amount`，捕获值后`makeIncrementor`将`incrementor`作为闭包返回。每次调用`incrementor`时，它会以`amount`作为增量增加`runningTotal`的值。\n`makeIncrementor`函数返回类型为`() -> Int`，这意味着它返回的是一个函数，而不是一个简单类型的值。该函数在每次调用时不接受参数，只返回一个`Int`类型的值。\n`makeIncrementer(forIncrement:)`又一个`Int`类型的参数，其外部参数名为`forIncrement`，内部参数名为`amount`，该参数表示每次`incrementor`被调用时`runningTotal`将要增加的量。\n嵌套函数`incrementor`用来执行实际的增加操作，使`runningTotal`增加`amount`，并将其返回。\n如果我们单独看`incrementor()`这个函数，会发现不同寻常\n``` Swift\nfunc incrementor() -> Int {\n    runningTotal += amount\n    return runningTotal\n}\n```\n`incrementor()`并没有接受任何参数，但是在函数体内访问了`runningTotal`和`amount`，这是因为它从外围函数捕获了`runningTotal`和`amount`变量的引用。捕获引用保证了`runningTotal`和`amount`变量在调用完`makeIncrementor`或不会消失，并且保证在下一次执行`incrementer`函数时`runningTotal`依然存在。\n> 注：为了优化，如果一个值是不可变的，Swift可能会改为捕获并保存一份对值的拷贝。Swift也会负责被捕获变量的所有内存管理工作。\n\n``` Swift\nlet incrementByOne = makeIncrementor(forIncrement: 1)\nincrementByOne()//返回1\nincrementByOne()//返回2\n\nlet incrementByTen = makeIncrementor(forIncrement: 10)\nincrementByTen()//返回10\nincrementByOne()//返回3\nincrementByTen()//返回20\n```\n如果您创建了另一个`incrementor`，它会有属于它自己的一个全新、独立的`runningTotal`变量的引用：\n再次调用原来的`incrementByOne`会在原来的变量`runningTotal`上继续增加值，该变量和`incrementByTen`中捕获的变量没有任何联系。\n> 注：如果您将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，您将创建一个在闭包和该实例间的循环强引用。Swift 使用捕获列表来打破这种循环强引用。\n\n## 闭包是引用类型\n上面的例子中，`incrementByOne`和`incrementByTen`是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量值。这是因为函数和闭包都是引用类型。\n无论你将函数或者闭包赋值给一个常量还是变量，实际上都是将常量或者变量的值设置为对应函数或闭包的引用。。上面的示例中，指向闭包的引用`incrementByTen`是一个常量，而非闭包内容本身。\n这也意味着如果您将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：\n``` Swift\nlet alsoIncrementByTen = incrementByTen\nalsoIncrementByTen()//返回30\n```\n\n## 非逃逸闭包\n当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注`@noescape`，用来指明这个闭包时不允许“逃逸”出这个函数的。将闭包标注`@noescape`能使编译器知道这个闭包的生命周期（闭包只能在函数体中被执行，不能脱离函数体执行，所以编译器明确知道运行时的上下文），从而可以进行一些比较激进的优化。\n`Array`中提供的`sort(_:)`方法接受一个用来进行元素比较的闭包作为函数，这个参数被标注了`@noescape`，因为它确保自己在排序结束后就没用了。\n``` Swift\nfunc someFunctionWithNoescapeClosure(@noescape closure: () -> Void) {\n    closure()\n}\n```\n`someFunctionWithNoescapeClosure`定义了一个传入非逃逸闭包的函数。\n一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。比如，很多启动异步操作的函数接受一个闭包参数作为completion handler。这类函数会在异步操作开始之后立即返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：\n``` Swift\nvar completionHandlers:[() -> Void] = []\nfunc someFunctionWithEscapingClosure(completionHandler:()->Void) -> Void {\n    completionHandlers.append(completionHandler)\n}\n```\n`someFunctionWithEscapingClosure(_:)`函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你试图将这个参数标注为`@noescape`将会得到一个编译错误。\n将闭包标注为`@noescape`使你能在闭包中隐式地引用`self`。\n``` Swift\nclass ExClass {\n    var x = 1\n    func doSomething() -> Void {\n        someFunctionWithEscapingClosure({self.x = 120})\n        someFunctionWithEscapingClosure({self.x = 10})\n        someFunctionWithNoescapeClosure({x = 20})\n    }\n}\n\nlet instance = ExClass()\ninstance.doSomething()\nprint(instance.x)\n\ncompletionHandlers.first?()\nprint(instance.x)\n\ncompletionHandlers.last?()\nprint(instance.x)\n```","source":"_posts/Swift学习笔记之闭包.md","raw":"---\ntitle: Swift学习笔记之闭包\ndate: 2016-06-01 09:20:16\ntags:\n  - Swift\n  - 闭包\ncategories: Swift学习笔记\n---\n\n## 概述\n\n一般来说，在学习一个新的东西前我们都需要先了解这个东西的定义。在Swift中的闭包是什么呢？\n> 闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift中的闭包与C和objc中的代码块(blocks)以及其它一些语言中的匿名函数比较相似。\n\n闭包可以捕获和存储其所在上下文中任意常量和变量的引用。这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift 会为您管理在捕获过程中涉及到的所有内存操作。\n\n<!-- more -->\n\n全局和嵌套函数其实也是特殊的闭包，闭包采取如下三种形式之一：\n* 全局函数是一个有名字但不会捕获任何值的闭包\n* 嵌套函数是一个有名字并可以捕获其封闭函数内值的闭包\n* 闭包表达式是一个利用轻量级语法\t所写的可以捕获其上下文中变量或常量值的匿名闭包\n\nSwift表达式拥有简洁的风格，并鼓励在常见场景进行语法优化，主要有如下优化方式\n* 利用上下文推断判断参数和返回值类型\n* 隐式返回单表达式闭包，即单表达式可以省略`return`关键字\n* 参数名称缩写\n* 尾随（Trailing）闭包语法\n\n## 闭包表达式\n\n闭包表达式是一种利用简洁语法构建内联闭包的方式，闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过几次迭代展示了`sort`方法定义和语法优化的方式。每一次都用更简洁的方式描述了相同的功能。\n\n### sort方法\n\nSwift标准库提供了名为`sort`的方法，会根据您提供的用于排序的闭包函数将已知类型数组中的值进行排序。一旦排序完成，`sort`方法会返回一个与原数组大小相同，包含同类型元素且元素已正确排序的新数组。原数组并不会被`sort`方法修改。\n\n``` Swift\t\nlet names = [\"Jay\", \"Vae\", \"Jvaeyhcd\", \"Tom\", \"Jack\"]\n\nfunc sortFun(s1:String, s2:String) -> Bool {\n    return s1 > s2\n}\n\nvar sortedNames = names.sort(sortFun)\n```\n该例子是对一个`String`类型的数组进行排序，因此排序闭包函数类型需为`(String,String)->Bool`。提供排序闭包函数的方式是写一个符合其类型要求的普通函数，并将其作为`sort`的参数传入。然而，这是一个相当冗长的方式，本质上只是写一个单表达式函数（`s1 > s2`）。下面例子中，利用闭包表达式可以更好地构建一个内联排序闭包。\n\n### 闭包表达式语法\n\n闭包表达式语法一般如下：\n``` Swift\n{ (parameters) -> returnType in\n    statements\n}\n```\n闭包表达式可以使用变量、常量以及`inout`类型作为参数，但是不能提供默认值。也可以在参数列表的最后使用可变参数，元组也可以作为参数和返回值。\n\n下面例子展示了上面`sortFun(_:_:)`函数对应的闭包表达式版本的代码：\n``` Swift\nsortedNames = names.sort({\n    (s1:String, s2:String)->Bool in\n    return s1 < s2\n})\n```\n需要注意的是内联闭包参数和返回值类型申明与`sortFun(_:_:)`类型申明相同。两种方式中，都写成了`(s1:String, s2:String)->Bool`。然而在内联表达式中，函数和返回值类型都写在大括号内，而不是大括号外。\n闭包函数体部分由关键字`in`引入。该关键字表示闭包的参数和返回值类型都已定义完成，闭包函数体即将开始。由于这个闭包函数体部分如此短，以至于可以将其写成一行代码：\n``` Swift\nsortedNames = names.sort({(s1:String, s2:String) -> Bool in return s1 < s2})\n```\n该例中`sort(_:)`方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。\n\n### 根据上下文推断类型\n\n因为排序闭包函数是作为`sort(_:)`方法参数传入的，Swift可判断其参数和返回值的类型。`sort(_:)`方法被一个字符串数组调用，此参数必须是`(String, String)->Bool`类型的函数。这意味着`(String, String)`和`Bool`类型并不是必须作为闭包表达式定义的一部分。因为所有类型都可以被正确判断，返回箭头(`->`)和围绕在周围的括号也可以被省略：\n\n``` Swift\nsortedNames = names.sort({s1, s2 in return s1 > s2})\n```\n实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，都可以推断出闭包的参数和返回值类型。 这意味着闭包作为函数或者方法的参数时，您几乎不需要利用完整格式构造内联闭包。\n\n尽管如此，您仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则可以采用完整格式的闭包。\n\n### 单表达式闭包隐式返回\n单行表达式闭包可以通过省略`return`关键字来隐式返回单行表达式的结果，如上面版本代码可以改写为：\n``` Swift\nsortedNames = names.sort({s1, s2 in s1 > s2})\n```\n在这个例子中，`sort(_:)`方法的参数类型明确了闭包必须返回一个`Bool`类型值。因为闭包函数体只包含了一个单一表达式（`s1 > s2`），该表达式返回`Bool`类型值，因此这里没有歧义，`return`关键字可以省略。\n\n### 参数名称缩写\nSwift自动为内联包提供了参数名称缩写功能，你可以直接通过`$0`,`$1`,`$2`来顺序调用闭包的参数，以此类推。如果您在闭包表达式中使用参数名缩写，你可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行推断。`in`关键字同样也可以被省略，因此闭包表达式完全由闭包函数体构成：\n``` Swift\nsortedNames = names.sort({$0 > $1})\n```\n在这个例子中，`$0`和`$1`表示闭包中第一个和第二个`String`类型的参数。\n\n### 运算符函数\n实际上还有更简单的方式来实现上面例子中的闭包表达式。Swift中`String`类型定义了关于大于符号(`>`)的字符串实现，其作为一个函数接收两个`String`类型的参数并返回`Bool`类型的值。而这正好与`sort(_:)`方法的参数需要的函数类型相符合。因此，您可以简单地传递一个大于号，Swift 可以自动推断出您想使用大于号的字符串函数实现：\n``` Swift\nsortedNames = names.sort(>)\n```\n\n## 尾随闭包\n\n如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。尾随闭包是一个书写在函数括号后的闭包表达式，函数支持将其作为最后一个参数调用：\n``` Swift\nfunc someFunctionThatTakesAClosure(closure: () -> Void) {\n    // 函数体部分\n}\n\n// 以下是不使用尾随闭包进行函数调用\nsomeFunctionThatTakesAClosure({\n    // 闭包主体部分\n})\n\n// 以下是使用尾随闭包进行函数调用\nsomeFunctionThatTakesAClosure() {\n    // 闭包主体部分\n}\n```\n\n所以上面`sort(_:)`方法参数字符串排序闭包可以改写为\n``` Swift\nsortedNumbers = numbers.sort{$0 > $1}\n```\n如果函数只需要闭包表达式一个参数，当使用尾随闭包时可以把`()`省略\n``` Swift\nsortedNumbers = numbers.sort(){$0 > $1}\n```\n当闭包非常长以至于不能在一行进行书写，尾随闭包变得非常有用。举个例子来说，Swifte的`Array`类型有一个`map(_:)`方法，其获取一个闭包表达式作为唯一参数。该闭包函数会为数组中的额每一个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。当提供给数组的闭包用于数组每个元素后，`map(_:)`方法将返回一个新的数组，数组中包含了与原数组中的元素一一对应的映射后的值。\n``` Swift\nlet digitNames = [\n    0:\"Zero\", 1:\"One\", 2:\"Two\", 3:\"Three\", 4:\"Four\",\n    5:\"Five\", 6:\"Six\", 7:\"Seven\", 8:\"Eight\", 9:\"Nine\"\n]\n\nnumbers = [34, 65, 89]\n\nlet strings = numbers.map {\n    (number) -> String in\n    \n    var number = number\n    var output = \"\"\n    \n    while number > 0 {\n        output = digitNames[number % 10]! + output\n        number /= 10\n    }\n    \n    return output\n}\n\nprint(strings)\n```\n上面示例代码展示了如何在`map(_:)`方法中使用尾随闭包将`Int`类型的数组`[34, 65, 89]`转换为包含对应`String`类型值的数组`[\"ThreeFour\", \"SixFive\", \"EightNine\"]`。\n`map(_:)`为数组中每一个元素调用了闭包表达式。您不需要指定闭包的输入参数`number`的类型，因为可以通过要映射的数组类型进行推断。\n在该例中，局部变量`number`的值由闭包中的`numbe`r参数获得,因此可以在闭包函数体内对其进行修改，(闭包或者函数的参数总是固定的),闭包表达式指定了返回类型为`String`，以表明存储映射值的新数组类型为`String`。\n\n闭包表达式在每次被调用的时候创建了一个叫做`output`的字符串并返回。其使用求余运算符（`number % 10`）计算最后一位数字并利用`digitNames`字典获取所映射的字符串。\n\n> 注：字典digitNames下标后跟着一个叹号（`!`），因为字典下标返回一个可选值（optional value），表明该键不存在时会查找失败。在上例中，由于可以确定`number % 10`总是digitNames字典的有效下标，因此叹号可以用于强制解包 (force-unwrap) 存储在下标的可选类型的返回值中的`String`类型的值。\n\n## 捕获值\n闭包可以在其被定义的上下文中捕获常量或者变量。即使定义这些常量或变量的作用域已经不在，闭包仍然可以在闭包函数体内引用和修改这些值。Swift中可捕获值的最简单的形势就是嵌套函数，也就是定义在其它函数内的函数。嵌套函数可以捕获其外部函数所有的参数以及常量和变量。\n\n举个例子：\n``` Swift\nfunc makeIncrementor(forIncrement amount: Int) -> () -> Int {\n    var runningTotal = 0\n    func incrementor() -> Int {\n        runningTotal += amount\n        return runningTotal\n    }\n    return incrementor\n}\n\nlet incrementByOne = makeIncrementor(forIncrement: 1)\nincrementByOne()//返回1\nincrementByOne()//返回2\n\nlet incrementByTen = makeIncrementor(forIncrement: 10)\nincrementByTen()//返回10\nincrementByOne()//返回3\n```\n上面例子中有一个叫`makeIncrementor`的函数，它包含了一个叫`incrementor`的嵌套函数。嵌套函数`incrementor`从上下文捕获了两个值`runningTotal`和`amount`，捕获值后`makeIncrementor`将`incrementor`作为闭包返回。每次调用`incrementor`时，它会以`amount`作为增量增加`runningTotal`的值。\n`makeIncrementor`函数返回类型为`() -> Int`，这意味着它返回的是一个函数，而不是一个简单类型的值。该函数在每次调用时不接受参数，只返回一个`Int`类型的值。\n`makeIncrementer(forIncrement:)`又一个`Int`类型的参数，其外部参数名为`forIncrement`，内部参数名为`amount`，该参数表示每次`incrementor`被调用时`runningTotal`将要增加的量。\n嵌套函数`incrementor`用来执行实际的增加操作，使`runningTotal`增加`amount`，并将其返回。\n如果我们单独看`incrementor()`这个函数，会发现不同寻常\n``` Swift\nfunc incrementor() -> Int {\n    runningTotal += amount\n    return runningTotal\n}\n```\n`incrementor()`并没有接受任何参数，但是在函数体内访问了`runningTotal`和`amount`，这是因为它从外围函数捕获了`runningTotal`和`amount`变量的引用。捕获引用保证了`runningTotal`和`amount`变量在调用完`makeIncrementor`或不会消失，并且保证在下一次执行`incrementer`函数时`runningTotal`依然存在。\n> 注：为了优化，如果一个值是不可变的，Swift可能会改为捕获并保存一份对值的拷贝。Swift也会负责被捕获变量的所有内存管理工作。\n\n``` Swift\nlet incrementByOne = makeIncrementor(forIncrement: 1)\nincrementByOne()//返回1\nincrementByOne()//返回2\n\nlet incrementByTen = makeIncrementor(forIncrement: 10)\nincrementByTen()//返回10\nincrementByOne()//返回3\nincrementByTen()//返回20\n```\n如果您创建了另一个`incrementor`，它会有属于它自己的一个全新、独立的`runningTotal`变量的引用：\n再次调用原来的`incrementByOne`会在原来的变量`runningTotal`上继续增加值，该变量和`incrementByTen`中捕获的变量没有任何联系。\n> 注：如果您将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，您将创建一个在闭包和该实例间的循环强引用。Swift 使用捕获列表来打破这种循环强引用。\n\n## 闭包是引用类型\n上面的例子中，`incrementByOne`和`incrementByTen`是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量值。这是因为函数和闭包都是引用类型。\n无论你将函数或者闭包赋值给一个常量还是变量，实际上都是将常量或者变量的值设置为对应函数或闭包的引用。。上面的示例中，指向闭包的引用`incrementByTen`是一个常量，而非闭包内容本身。\n这也意味着如果您将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：\n``` Swift\nlet alsoIncrementByTen = incrementByTen\nalsoIncrementByTen()//返回30\n```\n\n## 非逃逸闭包\n当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注`@noescape`，用来指明这个闭包时不允许“逃逸”出这个函数的。将闭包标注`@noescape`能使编译器知道这个闭包的生命周期（闭包只能在函数体中被执行，不能脱离函数体执行，所以编译器明确知道运行时的上下文），从而可以进行一些比较激进的优化。\n`Array`中提供的`sort(_:)`方法接受一个用来进行元素比较的闭包作为函数，这个参数被标注了`@noescape`，因为它确保自己在排序结束后就没用了。\n``` Swift\nfunc someFunctionWithNoescapeClosure(@noescape closure: () -> Void) {\n    closure()\n}\n```\n`someFunctionWithNoescapeClosure`定义了一个传入非逃逸闭包的函数。\n一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。比如，很多启动异步操作的函数接受一个闭包参数作为completion handler。这类函数会在异步操作开始之后立即返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：\n``` Swift\nvar completionHandlers:[() -> Void] = []\nfunc someFunctionWithEscapingClosure(completionHandler:()->Void) -> Void {\n    completionHandlers.append(completionHandler)\n}\n```\n`someFunctionWithEscapingClosure(_:)`函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你试图将这个参数标注为`@noescape`将会得到一个编译错误。\n将闭包标注为`@noescape`使你能在闭包中隐式地引用`self`。\n``` Swift\nclass ExClass {\n    var x = 1\n    func doSomething() -> Void {\n        someFunctionWithEscapingClosure({self.x = 120})\n        someFunctionWithEscapingClosure({self.x = 10})\n        someFunctionWithNoescapeClosure({x = 20})\n    }\n}\n\nlet instance = ExClass()\ninstance.doSomething()\nprint(instance.x)\n\ncompletionHandlers.first?()\nprint(instance.x)\n\ncompletionHandlers.last?()\nprint(instance.x)\n```","slug":"Swift学习笔记之闭包","published":1,"updated":"2016-06-02T05:14:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcih001c29weqo440j03"},{"title":"Swift学习笔记之基础部分","date":"2016-04-29T02:07:32.000Z","_content":"\n\n> 本文所有知识都来至于网上以及官方的学习资料，本文不做任何商业用途，只是自己的一个学习笔记，如有侵权请及时告知我。\n\n## 概述\nSwift 是一门开发 iOS, OS X 和 watchOS 应用的新语言(传说以后还可以用于开始Android应用)。然而，如果你有 C 或者 objc 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的（如果没有 C 或者 objc 相关开发经验也没有关系，大家都说Swift比较通俗易懂更加容易上手）。\n\n<!-- more -->\nSwift包含了C 和objc上所有的数据类型，`Int`表示整型值；`Double`和`Float`表示浮点型值；`Bool`是布尔型值；`String`是字符串型值。此外Swift还提供了三个基本的集合类型，`Array`，`Set`和`Dictionary`。\n除了我们熟悉的类型，Swift 还增加了 objc 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。\n\nSwift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。可选有点像在 objc 中使用`nil`，但是它可以用在任何类型上，不仅仅是类。可选类型比 objc 中的nil指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。\n\nSwift 是一门类型安全的语言，可选类型就是一个很好的例子。Swift 可以让你清楚地知道值的类型。如果你的代码期望得到一个String，类型安全会阻止你不小心传入一个`Int`。你可以在开发阶段尽早发现并修正错误。\n\n## 常量和变量\n常量的值一旦设定就不能改变，而变量的值可以随意更改。\n\n## 声明常量和变量\n常量和变量必须在使用前声明，用`let`来声明常量，用`var`来声明变量。下面的例子展示了如何用常量和变量\n\n``` swift\nlet maxNumberOfLoginTimes = 10\nvar currentLoginTimes = 0\n```\n\n这两行代码可以理解为：\n`maxNumberOfLoginTimes`声明为一个常量，它的值是10并且不可再被改变，`currentLoginAttempt`申明为一个初始值为0的变量。\n我们可以在一行中声明多个常量或者多个变量，用逗号隔开：\n``` swift\nvar x = 0.0, y = 0.0\nlet a = 1, b = 2\n```\n> 注意：如果你的代码中有不需要改变的值，请使用`let`关键字将它声明为常量。只将需要改变的值声明为变量。与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：\n\n``` swift\nlet languageName = \"Swift\"\nlanguageName = \"Swift++\"\n// 这会报编译时错误 - languageName 不可改变\n```\n\n## 类型标注\n\n当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。\n这个例子给`welcomeMessage`变量添加了类型标注，表示这个变量可以存储`String`类型的值：\n``` swift\nvar welcomeMessage: String\n```\n声明中的冒号代表着“是...类型”，所以这行代码可以被理解为：\n“声明一个类型为`String`，名字为`welcomeMessage`的变量。”\n“类型为`String`”的意思是“可以存储任意`String`类型的值。”\n`welcomeMessage`变量现在可以被设置成任意字符串：\n``` swift\nwelcomeMessage = \"Hello\"\n```\n你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：\n``` swift\nvar red, green, blue: Double\n```\n> 注意：一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考类型安全和类型推断。在上面的例子中，没有给`welcomeMessage`赋初始值，所以变量`welcomeMessage`的类型是通过一个类型标注指定的，而不是通过初始值推断的。\n\n## 常量和变量的命名\n你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：\n``` swift\nlet π = 3.14159\nlet 你好 = \"你好世界\"\nlet 🐶🐮 = \"dogcow\"\n```\n常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。\n\n一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。\n> 注意：如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。\n\n## 输出常量和变量\n你可以用`print(_:separator:terminator:)`函数来输出当前常量或变量的值:\n``` swift\nvar friendlyWelcome = \"Bonjour!\"\nprint(friendlyWelcome)\n// 输出 \"Bonjour!\"\n```\n`print(_:separator:terminator:)`是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，`print(_:separator:terminator:)`将会输出内容到“console”面板上。separator和terminator参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给terminator参数--例如，`print(someValue, terminator:\"\")`。\n\nSwift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：\n``` swift\nprint(\"The current value of friendlyWelcome is \\(friendlyWelcome)\")\n// 输出 \"The current value of friendlyWelcome is Bonjour!\n```\n\n## 注释\n请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。\n与 C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：\n``` swift\n/* 这是第一个多行注释的开头\n/* 这是第二个被嵌套的多行注释 */\n这是第一个多行注释的结尾 */\n```\n通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。\n当然Swift的单行注释和多行注释和C语言的类似。\n``` swift\n// 这是一个单行注释\n/* 这是一个,\n多行注释 */\n```\n\n## 分号\n与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（;），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：\n``` swift\nlet cat = \"🐱\"; print(cat)\n// 输出 \"🐱\"\n```\n## 整数\n整数就是没有小数部分的数字，比如42和-23。整数可以是有符号（正、负、零）或者无符号（正、零）。\n\nSwift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是`UInt8`，32位有符号整数类型是`Int32`。就像 Swift 的其他类型一样，整数类型采用大写命名法。\n\n## 整数范围\n你可以访问不同整数类型的`min`和`max`属性来获取对应类型的最小值和最大值：\n``` swift\nlet minValue = UInt8.min  // minValue 为 0，是 UInt8 类型\nlet maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型\n```\n`min`和`max`所传回值的类型，正是其所对的整数类型(如上例`UInt8`, 所传回的类型是`UInt8`)，可用在表达式中相同类型值旁。\n\n## Int\n一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同：\n* 在32位平台上，`Int`和`Int32`长度相同。\n* 在64位平台上，`Int`和`Int64`长度相同。\n除非你需要特定长度的整数，一般来说使用`Int`就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，`Int`可以存储的整数范围也可以达到-2,147,483,648~2,147,483,647，大多数时候这已经足够大了。\n\n## UInt\nSwift 也提供了一个特殊的无符号类型`UInt`，长度与当前平台的原生字长相同：\n* 在32位平台上，`UInt`和`UInt32`长度相同。\n* 在64位平台上，`UInt`和`UInt64`长度相同。\n> 注意：尽量不要使用`UInt`，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用`Int`，即使你要存储的值已知是非负的。统一使用Int可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断\n\n## 浮点数\n浮点数是有小数部分的数字，比如`3.14159`，`0.1`和`-273.15`。\n\n浮点类型比整数类型表示的范围更大，可以存储比`Int`类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：\n* `Double`表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。\n* `Float`表示32位浮点数。精度要求不高的话可以使用此类型。\n\n## 类型安全和类型推断\nSwift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个`String`，你绝对不可能不小心传进去一个`Int`。\n\n由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查（type checks），并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。\n\n当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用类型推断（type inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。\n\n因为有类型推断，和 C 或者 objc 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。\n\n当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。（字面量就是会直接出现在你代码中的值，比如`42`和`3.14159`。）\n\n例如，如果你给一个新常量赋值`42`并且没有标明类型，Swift 可以推断出常量类型是Int，因为你给它赋的初始值看起来像一个整数：\n``` swift\nlet meaningOfLife = 42\n// meaningOfLife 会被推测为 Int 类型\n```\n同理，如果你没有给浮点字面量标明类型，Swift 会推断你想要的是`Double`：\n``` swift\nlet pi = 3.14159\n// pi 会被推测为 Double 类型\n```\n当推断浮点数的类型时，Swift 总是会选择`Double`而不是`Float`。\n如果表达式中同时出现了整数和浮点数，会被推断为`Double`类型：\n``` swift\nlet anotherPi = 3 + 0.14159\n// anotherPi 会被推测为 Double 类型\n```\n原始值`3`没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为`Double`类型。\n\n## 数值型字面量\n整数字面量可以被写作：\n* 一个十进制数，没有前缀\n* 一个二进制数，前缀是`0b`\n* 一个八进制数，前缀是`0o`\n* 一个十六进制数，前缀是`0x`\n\n下面的所有整数字面量的十进制值都是16:\n``` swift\nlet decimalInteger = 16\nlet binaryInteger = 0b10000       // 二进制的16\nlet octalInteger = 0o20           // 八进制的16\nlet hexadecimalInteger = 0x10     // 十六进制的16\n```\n浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是`0x`）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。十进制浮点数也可以有一个可选的指数（exponent)，通过大写或者小写的 `e` 来指定；十六进制浮点数必须有一个指数，通过大写或者小写的 `p` 来指定。\n如果一个十进制数的指数为`exp`，那这个数相当于基数和10^exp的乘积：\n* `1.25e2` 表示 1.25 × 10^2，等于 `125.0`。\n* `1.25e-2` 表示 1.25 × 10^-2，等于 `0.0125`。\n\n如果一个十六进制数的指数为`exp`，那这个数相当于基数和2^exp的乘积：\n* `0xFp2` 表示 15 × 2^2，等于 `60.0`。\n* `0xFp-2` 表示 15 × 2^-2，等于 `3.75`。\n\n下面的这些浮点字面量都等于十进制的`12.1875`：\n``` swift\nlet decimalDouble = 12.1875\nlet exponentDouble = 1.21875e1\nlet hexadecimalDouble = 0xC.3p0\n```\n数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：\n``` swift\nlet paddedDouble = 000123.456\nlet oneMillion = 1_000_000\nlet justOverOneMillion = 1_000_000.000_000_1\n```\n\n## 数值型类型转换\n\n通常来讲，即使代码中的整数常量和变量已知非负，也请使用`Int`类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。\n\n只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。\n\n## 整数转换\n不同整数类型的变量和常量可以存储不同范围的数字。`Int8`类型的常量或者变量可以存储的数字范围是-128~127，而`UInt8`类型的常量或者变量能存储的数字范围是0~255。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：\n``` swift\nlet cannotBeNegative: UInt8 = -1\n// UInt8 类型不能存储负数，所以会报错\nlet tooBig: Int8 = Int8.max + 1\n// Int8 类型不能存储超过最大值的数，所以会报错\n```\n由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。\n\n要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量`twoThousand`是`UInt16`类型，然而常量`one`是`UInt8`类型。它们不能直接相加，因为它们类型不同。所以要调用`UInt16(one)`来创建一个新的`UInt16`数字并用`one`的值来初始化，然后使用这个新数字来计算：\n``` swift\nlet twoThousand: UInt16 = 2_000\nlet one: UInt8 = 1\nlet twoThousandAndOne = twoThousand + UInt16(one)\n```\n现在两个数字的类型都是`UInt16`，可以进行相加。目标常量`twoThousandAndOne`的类型被推断为`UInt16`，因为它是两个`UInt16`值的和。\n\n`SomeType(ofInitialValue)`是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，`UInt16`有一个构造器，可以接受一个`UInt8`类型的值，所以这个构造器可以用现有的`UInt8`来创建一个新的`UInt16`。注意，你并不能传入任意类型的值，只能传入`UInt16`内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型）。\n\n## 整数和浮点数转换\n整数和浮点数的转换必须显式指定类型：\n``` swift\nlet three = 3\nlet pointOneFourOneFiveNine = 0.14159\nlet pi = Double(three) + pointOneFourOneFiveNine\n// pi 等于 3.14159，所以被推测为 Double 类型\n```\n这个例子中，常量`three`的值被用来创建一个`Double`类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。\n浮点数到整数的反向转换同样行，整数类型可以用`Double`或者`Float`类型来初始化：\n``` swift\nlet integerPi = Int(pi)\n// integerPi 等于 3，所以被推测为 Int 类型\n```\n当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说`4.75`会变成`4`，`-3.9`会变成`-3`。\n> 注意：结合数字类常量和变量不同于结合数字类字面量。字面量`3`可以直接和字面量`0.14159`相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。\n\n## 类型别名\n\n类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用`typealias`关键字来定义类型别名。\n\n当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：\n``` swift\ntypealias AudioSample = UInt16\n```\n定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：\n``` swift\nvar maxAmplitudeFound = AudioSample.min\n// maxAmplitudeFound 现在是 0\n```\n本例中，`AudioSample`被定义为`UInt16`的一个别名。因为它是别名，`AudioSample.min`实际上是`UInt16.min`，所以会给`maxAmplitudeFound`赋一个初值`0`。\n\n## 布尔值\nSwift 有一个基本的布尔（Boolean）类型，叫做`Bool`。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，`true`和`false`：\n``` swift\nlet orangesAreOrange = true\nlet turnipsAreDelicious = false\n```\n`orangesAreOrange`和`turnipsAreDelicious`的类型会被推断为`Bool`，因为它们的初值是布尔字面量。就像之前提到的`Int`和`Double`一样，如果你创建变量的时候给它们赋值`true`或者`false`，那你不需要将常量或者变量声明为`Bool`类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断，这让 Swift 代码更加简洁并且可读性更高。\n当你编写条件语句比如`if`语句的时候，布尔值非常有用：\n``` swift\nif turnipsAreDelicious {\n    print(\"Mmm, tasty turnips!\")\n} else {\n    print(\"Eww, turnips are horrible.\")\n}\n// 输出 \"Eww, turnips are horrible.\"\n```\n如果你在需要使用`Bool`类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：\n``` swift\nlet i = 1\nif i {\n    // 这个例子不会通过编译，会报错\n}\n```\n然而，下面的例子是合法的：\n``` swift\nlet i = 1\nif i == 1 {\n    // 这个例子会编译成功\n}\n```\n`i == 1`的比较结果是`Bool`类型，所以第二个例子可以通过类型检查。\n\n和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。\n\n## 元组\n\n元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。\n\n下面这个例子中，`(404, \"Not Found\")`是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个`404 Not Found`状态码。\n``` swift\nlet http404Error = (404, \"Not Found\")\n// http404Error 的类型是 (Int, String)，值是 (404, \"Not Found\")\n```\n`(404, \"Not Found\")`元组把一个`Int`值和一个`String`值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为`(Int, String)`的元组”。\n你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为`(Int, Int, Int)`或者`(String, Bool)`或者其他任何你想要的组合的元组。\n你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：\n``` swift\nlet (statusCode, statusMessage) = http404Error\nprint(\"The status code is \\(statusCode)\")\n// 输出 \"The status code is 404\"\nprint(\"The status message is \\(statusMessage)\")\n// 输出 \"The status message is Not Found\"\n```\n如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（`_`）标记：\n``` swift\nlet (justTheStatusCode, _) = http404Error\nprint(\"The status code is \\(justTheStatusCode)\")\n// 输出 \"The status code is 404\"\n```\n此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：\n``` swift\nprint(\"The status code is \\(http404Error.0)\")\n// 输出 \"The status code is 404\"\nprint(\"The status message is \\(http404Error.1)\")\n// 输出 \"The status message is Not Found\"\n```\n你可以在定义元组的时候给单个元素命名：\n``` swift\nlet http200Status = (statusCode: 200, description: \"OK\")\n```\n给元组中的元素命名后，你可以通过名字来获取这些元素的值：\n``` swift\nprint(\"The status code is \\(http200Status.statusCode)\")\n// 输出 \"The status code is 200\"\nprint(\"The status message is \\(http200Status.description)\")\n// 输出 \"The status message is OK\"\n```\n作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个`(Int, String)`元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。\n> 注意：元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。\n\n## 可选类型\n\n使用可选类型（optionals）来处理值可能缺失的情况。\n来看一个例子。Swift 的`Int`类型有一种构造器，作用是将一个`String`值转换成一个`Int`值。然而，并不是所有的字符串都可以转换成一个整数。字符串`\"123\"`可以被转换成数字`123`，但是字符串`\"hello, world\"`不行。\n\n下面的例子使用这种构造器来尝试将一个`String`转换成`Int`：\n``` swift\nlet possibleNumber = \"123\"\nlet convertedNumber = Int(possibleNumber)\n// convertedNumber 被推测为类型 \"Int?\"， 或者类型 \"optional Int\"\n```\n因为该构造器可能会失败，所以它返回一个可选类型（optional）`Int`，而不是一个`Int`。一个可选的`Int`被写作`Int?`而不是`Int`。问号暗示包含的值是可选类型，也就是说可能包含`Int`值也可能不包含值。（不能包含其他任何值比如`Bool`值或者`String`值。只能是\t`Int`或者什么都没有。）\n\n## nil\n你可以给可选变量赋值为`nil`来表示它没有值：\n``` swift\nvar serverResponseCode: Int? = 404\n// serverResponseCode 包含一个可选的 Int 值 404\nserverResponseCode = nil\n// serverResponseCode 现在不包含值\n```\n> 注意：`nil`不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。\n\n如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为`nil`：\n``` swift\nvar surveyAnswer: String?\n// surveyAnswer 被自动设置为 nil\n```\n> 注意：Swift 的`nil`和 objc 中的`nil`并不一样。在 objc 中，`nil`是一个指向不存在对象的指针。在 Swift 中，`nil`不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为`nil`，不只是对象类型。\n\n## if 语句以及强制解析\n你可以使用`if`语句和`nil`比较来判断一个可选值是否包含值。你可以使用“相等”(`==`)或“不等”(`!=`)来执行比较。\n\n如果可选类型有值，它将不等于`nil`:\n``` swift\nif convertedNumber != nil {\n    print(\"convertedNumber contains some integer value.\")\n}\n// 输出 \"convertedNumber contains some integer value.\"\n```\n当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（`!`）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）：\n``` swift\nif convertedNumber != nil {\n    print(\"convertedNumber has an integer value of \\(convertedNumber!).\")\n}\n// 输出 \"convertedNumber has an integer value of 123.\"\n```\n> 注意：使用`!`来获取一个不存在的可选值会导致运行时错误。使用`!`来强制解析值之前，一定要确定可选包含一个非`nil`的值。\n\n## 可选绑定\n\n使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在`if`和`while`语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。\n\n像下面这样在`if`语句中写一个可选绑定：\n``` swift\nif let constantName = someOptional {\n    statements\n}\n```\n你可以像上面这样使用可选绑定来重写`possibleNumber`这个例子：\n``` swift\nif let actualNumber = Int(possibleNumber) {\n    print(\"\\'\\(possibleNumber)\\' has an integer value of \\(actualNumber)\")\n} else {\n    print(\"\\'\\(possibleNumber)\\' could not be converted to an integer\")\n}\n// 输出 \"'123' has an integer value of 123\"\n```\n这段代码可以被理解为：“如果`Int(possibleNumber)`返回的可选`Int`包含一个值，创建一个叫做`actualNumber`的新常量并将可选包含的值赋给它。”\n\n如果转换成功，`actualNumber`常量可以在`if`语句的第一个分支中使用。它已经被可选类型 包含的 值初始化过，所以不需要再使用!后缀来获取它的值。在这个例子中，`actualNumber`只被用来输出转换结果。\n\n你可以在可选绑定中使用常量和变量。如果你想在`if`语句的第一个分支中操作`actualNumber`的值，你可以改成`if var actualNumber`，这样可选类型包含的值就会被赋给一个变量而非常量。\n\n你可以包含多个可选绑定在`if`语句中，并使用`where`子句做布尔值判断。\n``` swift\nif let firstNumber = Int(\"4\"), secondNumber = Int(\"42\") where firstNumber < secondNumber {\n    print(\"\\(firstNumber) < \\(secondNumber)\")\n}\n// prints \"4 < 42\"\n```\n\n## 隐式解析可选类型\n\n如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过if语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。\n\n有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型_总会_有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。\n\n这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（`String?`）改成感叹号（`String!`）来声明一个隐式解析可选类型。\n\n当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。\n\n一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型`String`和隐式解析可选类型`String`之间的区别：\n``` swift\nlet possibleString: String? = \"An optional string.\"\nlet forcedString: String = possibleString! // 需要惊叹号来获取值\n\nlet assumedString: String! = \"An implicitly unwrapped optional string.\"\nlet implicitString: String = assumedString  // 不需要感叹号\n```\n你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。\n\n> 注意：如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。\n\n你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：\n``` swift\nif assumedString != nil {\n    print(assumedString)\n}\n// 输出 \"An implicitly unwrapped optional string.\"\n```\n你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：\n``` swift\nif let definiteString = assumedString {\n    print(definiteString)\n}\n// 输出 \"An implicitly unwrapped optional string.\"\n```\n> 注意：如果一个变量之后可能变成`nil`的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是`nil`的话，请使用普通可选类型。\n\n## 错误处理\n你可以使用错误处理（error handling）来应对程序执行中可能会遇到的错误条件。相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。\n``` swift\nfunc canThrowAnError() throws {\n    // 这个函数有可能抛出错误\n}\n```\n一个函数可以通过在声明中添加`throws`关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置`try`关键词。\n``` swift\ndo {\n    try canThrowAnError()\n    // 没有错误消息抛出\n} catch {\n    // 有一个错误消息抛出\n}\n```\n一个`do`语句创建了一个新的包含作用域,使得错误能被传播到一个或多个`catch`从句。\n这里有一个错误处理如何用来应对不同错误条件的例子。\n``` swift\nfunc makeASandwich() throws {\n    // ...\n}\n\ndo {\n    try makeASandwich()\n    eatASandwich()\n} catch Error.OutOfCleanDishes {\n    washDishes()\n} catch Error.MissingIngredients(let ingredients) {\n    buyGroceries(ingredients)\n}\n```\n在此例中，`makeASandwich()`（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为`makeASandwich()`抛出错误，函数调用被包裹在`try`表达式中。将函数包裹在一个`do`语句中,任何被抛出的错误会被传播到提供的`catch`从句中。\n\n如果没有错误被抛出, `eatASandwich()`函数会被调用。如果一个匹配`Error.OutOfCleanDishes`的错误被抛出,`washDishes`函数会被调用。如果一个匹配`Error.MissingIngredients`的错误被抛出，`buyGroceries(_:)`函数会随着被`catch`所捕捉到的关联值[`String`]被调用。\n\n## 断言\n可选类型可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能没办法继续执行。这时，你可以在你的代码中触发一个断言（assertion）来结束代码运行并通过调试来找到值缺失的原因。\n\n## 使用断言进行调试\n断言会在运行时判断一个逻辑条件是否为`true`。从字面意思来说，断言“断言”一个条件是否为真。你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。如果条件判断为`true`，代码运行会继续进行；如果条件判断为`false`，代码执行结束，你的应用被终止。\n\n如果你的代码在调试环境下触发了一个断言，比如你在 Xcode 中构建并运行一个应用，你可以清楚地看到不合法的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。\n\n你可以使用全局`assert(_:_file:line:)`函数来写一个断言。向这个函数传入一个结果为`true`或者`false`的表达式以及一条信息，当表达式的结果为`false`的时候这条信息会被显示：\n``` swift\nlet age = -3\nassert(age >= 0, \"A person's age cannot be less than zero\")\n// 因为 age < 0，所以断言会触发\n```\n在这个例子中，只有`age >= 0`为`true`的时候，即`age`的值非负的时候，代码才会继续执行。如果`age`的值是负数，就像代码中那样，`age >= 0为false`，断言被触发，终止应用。\n\n如果不需要断言信息，可以省略，就像这样：\n``` swift\nassert(age >= 0)\n```\n> 注意：当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置选项来 build 时，断言会被禁用。\n\n## 何时使用断言\n当条件可能为假时使用断言，但是最终一定要_保证_条件为真，这样你的代码才能继续运行。断言的适用情景：\n* 整数类型的下标索引被传入一个自定义下标实现，但是下标索引值可能太小或者太大。\n* 需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。\n* 一个可选值现在是`nil`，但是后面的代码运行需要一个非`nil`值。\n\n> 注意：断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。","source":"_posts/Swift学习笔记之基础部分.md","raw":"---\ntitle: Swift学习笔记之基础部分\ndate: 2016-04-29 10:07:32\ntags:\n  - Swift\ncategories: Swift学习笔记\n---\n\n\n> 本文所有知识都来至于网上以及官方的学习资料，本文不做任何商业用途，只是自己的一个学习笔记，如有侵权请及时告知我。\n\n## 概述\nSwift 是一门开发 iOS, OS X 和 watchOS 应用的新语言(传说以后还可以用于开始Android应用)。然而，如果你有 C 或者 objc 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的（如果没有 C 或者 objc 相关开发经验也没有关系，大家都说Swift比较通俗易懂更加容易上手）。\n\n<!-- more -->\nSwift包含了C 和objc上所有的数据类型，`Int`表示整型值；`Double`和`Float`表示浮点型值；`Bool`是布尔型值；`String`是字符串型值。此外Swift还提供了三个基本的集合类型，`Array`，`Set`和`Dictionary`。\n除了我们熟悉的类型，Swift 还增加了 objc 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。\n\nSwift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。可选有点像在 objc 中使用`nil`，但是它可以用在任何类型上，不仅仅是类。可选类型比 objc 中的nil指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。\n\nSwift 是一门类型安全的语言，可选类型就是一个很好的例子。Swift 可以让你清楚地知道值的类型。如果你的代码期望得到一个String，类型安全会阻止你不小心传入一个`Int`。你可以在开发阶段尽早发现并修正错误。\n\n## 常量和变量\n常量的值一旦设定就不能改变，而变量的值可以随意更改。\n\n## 声明常量和变量\n常量和变量必须在使用前声明，用`let`来声明常量，用`var`来声明变量。下面的例子展示了如何用常量和变量\n\n``` swift\nlet maxNumberOfLoginTimes = 10\nvar currentLoginTimes = 0\n```\n\n这两行代码可以理解为：\n`maxNumberOfLoginTimes`声明为一个常量，它的值是10并且不可再被改变，`currentLoginAttempt`申明为一个初始值为0的变量。\n我们可以在一行中声明多个常量或者多个变量，用逗号隔开：\n``` swift\nvar x = 0.0, y = 0.0\nlet a = 1, b = 2\n```\n> 注意：如果你的代码中有不需要改变的值，请使用`let`关键字将它声明为常量。只将需要改变的值声明为变量。与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：\n\n``` swift\nlet languageName = \"Swift\"\nlanguageName = \"Swift++\"\n// 这会报编译时错误 - languageName 不可改变\n```\n\n## 类型标注\n\n当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。\n这个例子给`welcomeMessage`变量添加了类型标注，表示这个变量可以存储`String`类型的值：\n``` swift\nvar welcomeMessage: String\n```\n声明中的冒号代表着“是...类型”，所以这行代码可以被理解为：\n“声明一个类型为`String`，名字为`welcomeMessage`的变量。”\n“类型为`String`”的意思是“可以存储任意`String`类型的值。”\n`welcomeMessage`变量现在可以被设置成任意字符串：\n``` swift\nwelcomeMessage = \"Hello\"\n```\n你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：\n``` swift\nvar red, green, blue: Double\n```\n> 注意：一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考类型安全和类型推断。在上面的例子中，没有给`welcomeMessage`赋初始值，所以变量`welcomeMessage`的类型是通过一个类型标注指定的，而不是通过初始值推断的。\n\n## 常量和变量的命名\n你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：\n``` swift\nlet π = 3.14159\nlet 你好 = \"你好世界\"\nlet 🐶🐮 = \"dogcow\"\n```\n常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。\n\n一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。\n> 注意：如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。\n\n## 输出常量和变量\n你可以用`print(_:separator:terminator:)`函数来输出当前常量或变量的值:\n``` swift\nvar friendlyWelcome = \"Bonjour!\"\nprint(friendlyWelcome)\n// 输出 \"Bonjour!\"\n```\n`print(_:separator:terminator:)`是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，`print(_:separator:terminator:)`将会输出内容到“console”面板上。separator和terminator参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给terminator参数--例如，`print(someValue, terminator:\"\")`。\n\nSwift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：\n``` swift\nprint(\"The current value of friendlyWelcome is \\(friendlyWelcome)\")\n// 输出 \"The current value of friendlyWelcome is Bonjour!\n```\n\n## 注释\n请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。\n与 C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：\n``` swift\n/* 这是第一个多行注释的开头\n/* 这是第二个被嵌套的多行注释 */\n这是第一个多行注释的结尾 */\n```\n通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。\n当然Swift的单行注释和多行注释和C语言的类似。\n``` swift\n// 这是一个单行注释\n/* 这是一个,\n多行注释 */\n```\n\n## 分号\n与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（;），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：\n``` swift\nlet cat = \"🐱\"; print(cat)\n// 输出 \"🐱\"\n```\n## 整数\n整数就是没有小数部分的数字，比如42和-23。整数可以是有符号（正、负、零）或者无符号（正、零）。\n\nSwift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是`UInt8`，32位有符号整数类型是`Int32`。就像 Swift 的其他类型一样，整数类型采用大写命名法。\n\n## 整数范围\n你可以访问不同整数类型的`min`和`max`属性来获取对应类型的最小值和最大值：\n``` swift\nlet minValue = UInt8.min  // minValue 为 0，是 UInt8 类型\nlet maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型\n```\n`min`和`max`所传回值的类型，正是其所对的整数类型(如上例`UInt8`, 所传回的类型是`UInt8`)，可用在表达式中相同类型值旁。\n\n## Int\n一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同：\n* 在32位平台上，`Int`和`Int32`长度相同。\n* 在64位平台上，`Int`和`Int64`长度相同。\n除非你需要特定长度的整数，一般来说使用`Int`就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，`Int`可以存储的整数范围也可以达到-2,147,483,648~2,147,483,647，大多数时候这已经足够大了。\n\n## UInt\nSwift 也提供了一个特殊的无符号类型`UInt`，长度与当前平台的原生字长相同：\n* 在32位平台上，`UInt`和`UInt32`长度相同。\n* 在64位平台上，`UInt`和`UInt64`长度相同。\n> 注意：尽量不要使用`UInt`，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用`Int`，即使你要存储的值已知是非负的。统一使用Int可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断\n\n## 浮点数\n浮点数是有小数部分的数字，比如`3.14159`，`0.1`和`-273.15`。\n\n浮点类型比整数类型表示的范围更大，可以存储比`Int`类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：\n* `Double`表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。\n* `Float`表示32位浮点数。精度要求不高的话可以使用此类型。\n\n## 类型安全和类型推断\nSwift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个`String`，你绝对不可能不小心传进去一个`Int`。\n\n由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查（type checks），并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。\n\n当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用类型推断（type inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。\n\n因为有类型推断，和 C 或者 objc 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。\n\n当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。（字面量就是会直接出现在你代码中的值，比如`42`和`3.14159`。）\n\n例如，如果你给一个新常量赋值`42`并且没有标明类型，Swift 可以推断出常量类型是Int，因为你给它赋的初始值看起来像一个整数：\n``` swift\nlet meaningOfLife = 42\n// meaningOfLife 会被推测为 Int 类型\n```\n同理，如果你没有给浮点字面量标明类型，Swift 会推断你想要的是`Double`：\n``` swift\nlet pi = 3.14159\n// pi 会被推测为 Double 类型\n```\n当推断浮点数的类型时，Swift 总是会选择`Double`而不是`Float`。\n如果表达式中同时出现了整数和浮点数，会被推断为`Double`类型：\n``` swift\nlet anotherPi = 3 + 0.14159\n// anotherPi 会被推测为 Double 类型\n```\n原始值`3`没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为`Double`类型。\n\n## 数值型字面量\n整数字面量可以被写作：\n* 一个十进制数，没有前缀\n* 一个二进制数，前缀是`0b`\n* 一个八进制数，前缀是`0o`\n* 一个十六进制数，前缀是`0x`\n\n下面的所有整数字面量的十进制值都是16:\n``` swift\nlet decimalInteger = 16\nlet binaryInteger = 0b10000       // 二进制的16\nlet octalInteger = 0o20           // 八进制的16\nlet hexadecimalInteger = 0x10     // 十六进制的16\n```\n浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是`0x`）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。十进制浮点数也可以有一个可选的指数（exponent)，通过大写或者小写的 `e` 来指定；十六进制浮点数必须有一个指数，通过大写或者小写的 `p` 来指定。\n如果一个十进制数的指数为`exp`，那这个数相当于基数和10^exp的乘积：\n* `1.25e2` 表示 1.25 × 10^2，等于 `125.0`。\n* `1.25e-2` 表示 1.25 × 10^-2，等于 `0.0125`。\n\n如果一个十六进制数的指数为`exp`，那这个数相当于基数和2^exp的乘积：\n* `0xFp2` 表示 15 × 2^2，等于 `60.0`。\n* `0xFp-2` 表示 15 × 2^-2，等于 `3.75`。\n\n下面的这些浮点字面量都等于十进制的`12.1875`：\n``` swift\nlet decimalDouble = 12.1875\nlet exponentDouble = 1.21875e1\nlet hexadecimalDouble = 0xC.3p0\n```\n数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：\n``` swift\nlet paddedDouble = 000123.456\nlet oneMillion = 1_000_000\nlet justOverOneMillion = 1_000_000.000_000_1\n```\n\n## 数值型类型转换\n\n通常来讲，即使代码中的整数常量和变量已知非负，也请使用`Int`类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。\n\n只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。\n\n## 整数转换\n不同整数类型的变量和常量可以存储不同范围的数字。`Int8`类型的常量或者变量可以存储的数字范围是-128~127，而`UInt8`类型的常量或者变量能存储的数字范围是0~255。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：\n``` swift\nlet cannotBeNegative: UInt8 = -1\n// UInt8 类型不能存储负数，所以会报错\nlet tooBig: Int8 = Int8.max + 1\n// Int8 类型不能存储超过最大值的数，所以会报错\n```\n由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。\n\n要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量`twoThousand`是`UInt16`类型，然而常量`one`是`UInt8`类型。它们不能直接相加，因为它们类型不同。所以要调用`UInt16(one)`来创建一个新的`UInt16`数字并用`one`的值来初始化，然后使用这个新数字来计算：\n``` swift\nlet twoThousand: UInt16 = 2_000\nlet one: UInt8 = 1\nlet twoThousandAndOne = twoThousand + UInt16(one)\n```\n现在两个数字的类型都是`UInt16`，可以进行相加。目标常量`twoThousandAndOne`的类型被推断为`UInt16`，因为它是两个`UInt16`值的和。\n\n`SomeType(ofInitialValue)`是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，`UInt16`有一个构造器，可以接受一个`UInt8`类型的值，所以这个构造器可以用现有的`UInt8`来创建一个新的`UInt16`。注意，你并不能传入任意类型的值，只能传入`UInt16`内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型）。\n\n## 整数和浮点数转换\n整数和浮点数的转换必须显式指定类型：\n``` swift\nlet three = 3\nlet pointOneFourOneFiveNine = 0.14159\nlet pi = Double(three) + pointOneFourOneFiveNine\n// pi 等于 3.14159，所以被推测为 Double 类型\n```\n这个例子中，常量`three`的值被用来创建一个`Double`类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。\n浮点数到整数的反向转换同样行，整数类型可以用`Double`或者`Float`类型来初始化：\n``` swift\nlet integerPi = Int(pi)\n// integerPi 等于 3，所以被推测为 Int 类型\n```\n当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说`4.75`会变成`4`，`-3.9`会变成`-3`。\n> 注意：结合数字类常量和变量不同于结合数字类字面量。字面量`3`可以直接和字面量`0.14159`相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。\n\n## 类型别名\n\n类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用`typealias`关键字来定义类型别名。\n\n当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：\n``` swift\ntypealias AudioSample = UInt16\n```\n定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：\n``` swift\nvar maxAmplitudeFound = AudioSample.min\n// maxAmplitudeFound 现在是 0\n```\n本例中，`AudioSample`被定义为`UInt16`的一个别名。因为它是别名，`AudioSample.min`实际上是`UInt16.min`，所以会给`maxAmplitudeFound`赋一个初值`0`。\n\n## 布尔值\nSwift 有一个基本的布尔（Boolean）类型，叫做`Bool`。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，`true`和`false`：\n``` swift\nlet orangesAreOrange = true\nlet turnipsAreDelicious = false\n```\n`orangesAreOrange`和`turnipsAreDelicious`的类型会被推断为`Bool`，因为它们的初值是布尔字面量。就像之前提到的`Int`和`Double`一样，如果你创建变量的时候给它们赋值`true`或者`false`，那你不需要将常量或者变量声明为`Bool`类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断，这让 Swift 代码更加简洁并且可读性更高。\n当你编写条件语句比如`if`语句的时候，布尔值非常有用：\n``` swift\nif turnipsAreDelicious {\n    print(\"Mmm, tasty turnips!\")\n} else {\n    print(\"Eww, turnips are horrible.\")\n}\n// 输出 \"Eww, turnips are horrible.\"\n```\n如果你在需要使用`Bool`类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：\n``` swift\nlet i = 1\nif i {\n    // 这个例子不会通过编译，会报错\n}\n```\n然而，下面的例子是合法的：\n``` swift\nlet i = 1\nif i == 1 {\n    // 这个例子会编译成功\n}\n```\n`i == 1`的比较结果是`Bool`类型，所以第二个例子可以通过类型检查。\n\n和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。\n\n## 元组\n\n元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。\n\n下面这个例子中，`(404, \"Not Found\")`是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个`404 Not Found`状态码。\n``` swift\nlet http404Error = (404, \"Not Found\")\n// http404Error 的类型是 (Int, String)，值是 (404, \"Not Found\")\n```\n`(404, \"Not Found\")`元组把一个`Int`值和一个`String`值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为`(Int, String)`的元组”。\n你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为`(Int, Int, Int)`或者`(String, Bool)`或者其他任何你想要的组合的元组。\n你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：\n``` swift\nlet (statusCode, statusMessage) = http404Error\nprint(\"The status code is \\(statusCode)\")\n// 输出 \"The status code is 404\"\nprint(\"The status message is \\(statusMessage)\")\n// 输出 \"The status message is Not Found\"\n```\n如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（`_`）标记：\n``` swift\nlet (justTheStatusCode, _) = http404Error\nprint(\"The status code is \\(justTheStatusCode)\")\n// 输出 \"The status code is 404\"\n```\n此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：\n``` swift\nprint(\"The status code is \\(http404Error.0)\")\n// 输出 \"The status code is 404\"\nprint(\"The status message is \\(http404Error.1)\")\n// 输出 \"The status message is Not Found\"\n```\n你可以在定义元组的时候给单个元素命名：\n``` swift\nlet http200Status = (statusCode: 200, description: \"OK\")\n```\n给元组中的元素命名后，你可以通过名字来获取这些元素的值：\n``` swift\nprint(\"The status code is \\(http200Status.statusCode)\")\n// 输出 \"The status code is 200\"\nprint(\"The status message is \\(http200Status.description)\")\n// 输出 \"The status message is OK\"\n```\n作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个`(Int, String)`元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。\n> 注意：元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。\n\n## 可选类型\n\n使用可选类型（optionals）来处理值可能缺失的情况。\n来看一个例子。Swift 的`Int`类型有一种构造器，作用是将一个`String`值转换成一个`Int`值。然而，并不是所有的字符串都可以转换成一个整数。字符串`\"123\"`可以被转换成数字`123`，但是字符串`\"hello, world\"`不行。\n\n下面的例子使用这种构造器来尝试将一个`String`转换成`Int`：\n``` swift\nlet possibleNumber = \"123\"\nlet convertedNumber = Int(possibleNumber)\n// convertedNumber 被推测为类型 \"Int?\"， 或者类型 \"optional Int\"\n```\n因为该构造器可能会失败，所以它返回一个可选类型（optional）`Int`，而不是一个`Int`。一个可选的`Int`被写作`Int?`而不是`Int`。问号暗示包含的值是可选类型，也就是说可能包含`Int`值也可能不包含值。（不能包含其他任何值比如`Bool`值或者`String`值。只能是\t`Int`或者什么都没有。）\n\n## nil\n你可以给可选变量赋值为`nil`来表示它没有值：\n``` swift\nvar serverResponseCode: Int? = 404\n// serverResponseCode 包含一个可选的 Int 值 404\nserverResponseCode = nil\n// serverResponseCode 现在不包含值\n```\n> 注意：`nil`不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。\n\n如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为`nil`：\n``` swift\nvar surveyAnswer: String?\n// surveyAnswer 被自动设置为 nil\n```\n> 注意：Swift 的`nil`和 objc 中的`nil`并不一样。在 objc 中，`nil`是一个指向不存在对象的指针。在 Swift 中，`nil`不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为`nil`，不只是对象类型。\n\n## if 语句以及强制解析\n你可以使用`if`语句和`nil`比较来判断一个可选值是否包含值。你可以使用“相等”(`==`)或“不等”(`!=`)来执行比较。\n\n如果可选类型有值，它将不等于`nil`:\n``` swift\nif convertedNumber != nil {\n    print(\"convertedNumber contains some integer value.\")\n}\n// 输出 \"convertedNumber contains some integer value.\"\n```\n当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（`!`）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）：\n``` swift\nif convertedNumber != nil {\n    print(\"convertedNumber has an integer value of \\(convertedNumber!).\")\n}\n// 输出 \"convertedNumber has an integer value of 123.\"\n```\n> 注意：使用`!`来获取一个不存在的可选值会导致运行时错误。使用`!`来强制解析值之前，一定要确定可选包含一个非`nil`的值。\n\n## 可选绑定\n\n使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在`if`和`while`语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。\n\n像下面这样在`if`语句中写一个可选绑定：\n``` swift\nif let constantName = someOptional {\n    statements\n}\n```\n你可以像上面这样使用可选绑定来重写`possibleNumber`这个例子：\n``` swift\nif let actualNumber = Int(possibleNumber) {\n    print(\"\\'\\(possibleNumber)\\' has an integer value of \\(actualNumber)\")\n} else {\n    print(\"\\'\\(possibleNumber)\\' could not be converted to an integer\")\n}\n// 输出 \"'123' has an integer value of 123\"\n```\n这段代码可以被理解为：“如果`Int(possibleNumber)`返回的可选`Int`包含一个值，创建一个叫做`actualNumber`的新常量并将可选包含的值赋给它。”\n\n如果转换成功，`actualNumber`常量可以在`if`语句的第一个分支中使用。它已经被可选类型 包含的 值初始化过，所以不需要再使用!后缀来获取它的值。在这个例子中，`actualNumber`只被用来输出转换结果。\n\n你可以在可选绑定中使用常量和变量。如果你想在`if`语句的第一个分支中操作`actualNumber`的值，你可以改成`if var actualNumber`，这样可选类型包含的值就会被赋给一个变量而非常量。\n\n你可以包含多个可选绑定在`if`语句中，并使用`where`子句做布尔值判断。\n``` swift\nif let firstNumber = Int(\"4\"), secondNumber = Int(\"42\") where firstNumber < secondNumber {\n    print(\"\\(firstNumber) < \\(secondNumber)\")\n}\n// prints \"4 < 42\"\n```\n\n## 隐式解析可选类型\n\n如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过if语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。\n\n有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型_总会_有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。\n\n这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（`String?`）改成感叹号（`String!`）来声明一个隐式解析可选类型。\n\n当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。\n\n一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型`String`和隐式解析可选类型`String`之间的区别：\n``` swift\nlet possibleString: String? = \"An optional string.\"\nlet forcedString: String = possibleString! // 需要惊叹号来获取值\n\nlet assumedString: String! = \"An implicitly unwrapped optional string.\"\nlet implicitString: String = assumedString  // 不需要感叹号\n```\n你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。\n\n> 注意：如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。\n\n你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：\n``` swift\nif assumedString != nil {\n    print(assumedString)\n}\n// 输出 \"An implicitly unwrapped optional string.\"\n```\n你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：\n``` swift\nif let definiteString = assumedString {\n    print(definiteString)\n}\n// 输出 \"An implicitly unwrapped optional string.\"\n```\n> 注意：如果一个变量之后可能变成`nil`的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是`nil`的话，请使用普通可选类型。\n\n## 错误处理\n你可以使用错误处理（error handling）来应对程序执行中可能会遇到的错误条件。相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。\n``` swift\nfunc canThrowAnError() throws {\n    // 这个函数有可能抛出错误\n}\n```\n一个函数可以通过在声明中添加`throws`关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置`try`关键词。\n``` swift\ndo {\n    try canThrowAnError()\n    // 没有错误消息抛出\n} catch {\n    // 有一个错误消息抛出\n}\n```\n一个`do`语句创建了一个新的包含作用域,使得错误能被传播到一个或多个`catch`从句。\n这里有一个错误处理如何用来应对不同错误条件的例子。\n``` swift\nfunc makeASandwich() throws {\n    // ...\n}\n\ndo {\n    try makeASandwich()\n    eatASandwich()\n} catch Error.OutOfCleanDishes {\n    washDishes()\n} catch Error.MissingIngredients(let ingredients) {\n    buyGroceries(ingredients)\n}\n```\n在此例中，`makeASandwich()`（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为`makeASandwich()`抛出错误，函数调用被包裹在`try`表达式中。将函数包裹在一个`do`语句中,任何被抛出的错误会被传播到提供的`catch`从句中。\n\n如果没有错误被抛出, `eatASandwich()`函数会被调用。如果一个匹配`Error.OutOfCleanDishes`的错误被抛出,`washDishes`函数会被调用。如果一个匹配`Error.MissingIngredients`的错误被抛出，`buyGroceries(_:)`函数会随着被`catch`所捕捉到的关联值[`String`]被调用。\n\n## 断言\n可选类型可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能没办法继续执行。这时，你可以在你的代码中触发一个断言（assertion）来结束代码运行并通过调试来找到值缺失的原因。\n\n## 使用断言进行调试\n断言会在运行时判断一个逻辑条件是否为`true`。从字面意思来说，断言“断言”一个条件是否为真。你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。如果条件判断为`true`，代码运行会继续进行；如果条件判断为`false`，代码执行结束，你的应用被终止。\n\n如果你的代码在调试环境下触发了一个断言，比如你在 Xcode 中构建并运行一个应用，你可以清楚地看到不合法的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。\n\n你可以使用全局`assert(_:_file:line:)`函数来写一个断言。向这个函数传入一个结果为`true`或者`false`的表达式以及一条信息，当表达式的结果为`false`的时候这条信息会被显示：\n``` swift\nlet age = -3\nassert(age >= 0, \"A person's age cannot be less than zero\")\n// 因为 age < 0，所以断言会触发\n```\n在这个例子中，只有`age >= 0`为`true`的时候，即`age`的值非负的时候，代码才会继续执行。如果`age`的值是负数，就像代码中那样，`age >= 0为false`，断言被触发，终止应用。\n\n如果不需要断言信息，可以省略，就像这样：\n``` swift\nassert(age >= 0)\n```\n> 注意：当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置选项来 build 时，断言会被禁用。\n\n## 何时使用断言\n当条件可能为假时使用断言，但是最终一定要_保证_条件为真，这样你的代码才能继续运行。断言的适用情景：\n* 整数类型的下标索引被传入一个自定义下标实现，但是下标索引值可能太小或者太大。\n* 需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。\n* 一个可选值现在是`nil`，但是后面的代码运行需要一个非`nil`值。\n\n> 注意：断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。","slug":"Swift学习笔记之基础部分","published":1,"updated":"2016-06-02T04:00:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcij001i29weeqfnb1f5"},{"title":"Swift学习笔记之函数","date":"2016-05-31T10:19:17.000Z","_content":"\n函数是用来完成特定任务的独立代码块，你给一个个函数起一个合适的名字，用来标识该函数做什么，并且当函数需要执行的时候，这个名字会被用于“调用”函数。\n\nSwift统一的函数语法足够灵活，可以用来表示任何函数，包括从最简单的没有参数名字的C风格函数，到复杂带局部和外部参数名的Objective-C风格函数。参数可以提供默认值，以简化函数调用。参数也可以即当传入参数，也当传出参数。也就是说函数也是第一等公民，和常亮、变量一样。\n\n在Swiftl中，每一个函数都有一种类型，包括函数的参数值类型和返回值类型。你可以把函数类型当做其他不同类型变量一样处理，这样就可以更简单地把函数当做别的函数参数，也可以从其他函数中返回函数。函数的定义可以卸载其他函数定义中，这样可以在嵌套函数范围内实现功能封装。\n\n<!-- more -->\n\n## 函数的定义与调用\n当你定义一个函数时，你可以定义一个或多个有名字和类型的值，作为函数的输入（称为参数），也可以定义某种类型的值作为函数执行结束的输出（称为返回类型）。\n\n每个函数有个函数名，用来描述函数执行的任务，要使用一个函数时，你用函数名“调用”，并传给它匹配的输入值（称作实参）。一个函数的实参必须与函数表里的顺序一致。\n\n下面有个例子函数叫做`sayHello(_:)`,之所以叫这个名字，是因为这个函数用一个人的名字当做输入，并返回给这个人的问候语。为了完成这个任务，你定义一个输入参数，一个叫做`personName`的`String`值，和一个包含给这个人的问候语的`String`类型的返回值。\n\n``` swift\nfunc sayHello(personName: String) -> String {\n    let greeting = \"Hello, \" + personName + \"!\"\n    return greeting\n}\n```\n所有这些信息汇总起来成为函数的定义，并以`func`作为前缀。指定函数返回类型时，用返回箭头`->`后跟返回类型的名称的方式来表示。\n\n该定义描述了函数做什么，它期望接受什么和执行结束时它返回的结果类型是什么，这样的定义使得函数可以在别的地方以一种清晰的方式被调用：\n``` swift\nprint(sayHello(\"Anna\"))\n// prints \"Hello, Anna!\"\nprint(sayHello(\"Brian\"))\n// prints \"Hello, Brian!\"\n```\n### 函数参数和返回值\n函数参数与返回值在Swift中极为灵活，你可以定义任何类型的函数，包括从只带一个未名参数的简单函数到复杂的带有表达性参数名和不同参数选项的复杂函数。\n\n### 无参函数\n函数可以没有参数。下面这个函数就是一个无参函数，当被调用时，它返回固定的 `String` 消息：\n``` swift\nfunc sayHelloWorld() -> String {\n    return \"hello, world\"\n}\nprint(sayHelloWorld())\n// prints \"hello, world\"\n```\n> 尽管这个函数没有参数，但是定义中在函数名后还是需要一对圆括号。当被调用时，也需要在函数名后写一对圆括号。\n\n### 多参函数\n函数可以有多种输入参数，这些参数被包含在函数的括号之中，以逗号分隔。\n这个函数用一个人名和是否已经打过招呼作为输入，并返回对这个人的适当问候语:\n``` swift\nfunc sayHello(personName: String, alreadyGreeted: Bool) -> String {\n    if alreadyGreeted {\n        return sayHelloAgain(personName)\n    } else {\n        return sayHello(personName)\n    }\n}\nprint(sayHello(\"Tim\", alreadyGreeted: true))\n// prints \"Hello again, Tim!\"\n```\n### 无返回值函数\n函数可以没有返回值。下面是`sayHello(_:)`函数的另一个版本，叫`sayGoodbye(_:)`，这个函数直接输出`String`值，而不是返回它：\n``` swift\nfunc sayGoodbye(personName: String) {\n    print(\"Goodbye, \\(personName)!\")\n}\nsayGoodbye(\"Dave\")\n// prints \"Goodbye, Dave!\"\n```\n因为这个函数不需要返回值，所以这个函数的定义中没有返回箭头`->`和返回类型。\n> 注：严格上来说，虽然没有返回值被定义，`sayGoodbye(_:)`函数依然返回了值。没有定义返回类型的函数会返回特殊的值，叫做`Void`。它是一个空的元组，没有任何元素，可以写成`()`。","source":"_posts/Swift学习笔记之函数.md","raw":"---\ntitle: Swift学习笔记之函数\ndate: 2016-05-31 18:19:17\ntags:\n  - Swift\ncategories: Swift学习笔记\n---\n\n函数是用来完成特定任务的独立代码块，你给一个个函数起一个合适的名字，用来标识该函数做什么，并且当函数需要执行的时候，这个名字会被用于“调用”函数。\n\nSwift统一的函数语法足够灵活，可以用来表示任何函数，包括从最简单的没有参数名字的C风格函数，到复杂带局部和外部参数名的Objective-C风格函数。参数可以提供默认值，以简化函数调用。参数也可以即当传入参数，也当传出参数。也就是说函数也是第一等公民，和常亮、变量一样。\n\n在Swiftl中，每一个函数都有一种类型，包括函数的参数值类型和返回值类型。你可以把函数类型当做其他不同类型变量一样处理，这样就可以更简单地把函数当做别的函数参数，也可以从其他函数中返回函数。函数的定义可以卸载其他函数定义中，这样可以在嵌套函数范围内实现功能封装。\n\n<!-- more -->\n\n## 函数的定义与调用\n当你定义一个函数时，你可以定义一个或多个有名字和类型的值，作为函数的输入（称为参数），也可以定义某种类型的值作为函数执行结束的输出（称为返回类型）。\n\n每个函数有个函数名，用来描述函数执行的任务，要使用一个函数时，你用函数名“调用”，并传给它匹配的输入值（称作实参）。一个函数的实参必须与函数表里的顺序一致。\n\n下面有个例子函数叫做`sayHello(_:)`,之所以叫这个名字，是因为这个函数用一个人的名字当做输入，并返回给这个人的问候语。为了完成这个任务，你定义一个输入参数，一个叫做`personName`的`String`值，和一个包含给这个人的问候语的`String`类型的返回值。\n\n``` swift\nfunc sayHello(personName: String) -> String {\n    let greeting = \"Hello, \" + personName + \"!\"\n    return greeting\n}\n```\n所有这些信息汇总起来成为函数的定义，并以`func`作为前缀。指定函数返回类型时，用返回箭头`->`后跟返回类型的名称的方式来表示。\n\n该定义描述了函数做什么，它期望接受什么和执行结束时它返回的结果类型是什么，这样的定义使得函数可以在别的地方以一种清晰的方式被调用：\n``` swift\nprint(sayHello(\"Anna\"))\n// prints \"Hello, Anna!\"\nprint(sayHello(\"Brian\"))\n// prints \"Hello, Brian!\"\n```\n### 函数参数和返回值\n函数参数与返回值在Swift中极为灵活，你可以定义任何类型的函数，包括从只带一个未名参数的简单函数到复杂的带有表达性参数名和不同参数选项的复杂函数。\n\n### 无参函数\n函数可以没有参数。下面这个函数就是一个无参函数，当被调用时，它返回固定的 `String` 消息：\n``` swift\nfunc sayHelloWorld() -> String {\n    return \"hello, world\"\n}\nprint(sayHelloWorld())\n// prints \"hello, world\"\n```\n> 尽管这个函数没有参数，但是定义中在函数名后还是需要一对圆括号。当被调用时，也需要在函数名后写一对圆括号。\n\n### 多参函数\n函数可以有多种输入参数，这些参数被包含在函数的括号之中，以逗号分隔。\n这个函数用一个人名和是否已经打过招呼作为输入，并返回对这个人的适当问候语:\n``` swift\nfunc sayHello(personName: String, alreadyGreeted: Bool) -> String {\n    if alreadyGreeted {\n        return sayHelloAgain(personName)\n    } else {\n        return sayHello(personName)\n    }\n}\nprint(sayHello(\"Tim\", alreadyGreeted: true))\n// prints \"Hello again, Tim!\"\n```\n### 无返回值函数\n函数可以没有返回值。下面是`sayHello(_:)`函数的另一个版本，叫`sayGoodbye(_:)`，这个函数直接输出`String`值，而不是返回它：\n``` swift\nfunc sayGoodbye(personName: String) {\n    print(\"Goodbye, \\(personName)!\")\n}\nsayGoodbye(\"Dave\")\n// prints \"Goodbye, Dave!\"\n```\n因为这个函数不需要返回值，所以这个函数的定义中没有返回箭头`->`和返回类型。\n> 注：严格上来说，虽然没有返回值被定义，`sayGoodbye(_:)`函数依然返回了值。没有定义返回类型的函数会返回特殊的值，叫做`Void`。它是一个空的元组，没有任何元素，可以写成`()`。","slug":"Swift学习笔记之函数","published":1,"updated":"2016-06-17T09:27:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcim001l29wezqeyp32f"},{"title":"RXSwift基础","date":"2016-06-08T01:32:44.000Z","_content":"\n## 概念\n\n一个观察者(Observer)订阅一个可观察序列(Observable)。观察者对Observable发射的数据或数据序列作出响应\n\n## 为什么发用RxSwift\n一个程序通常包含着大量的各种事件的产生以及对应的处理逻辑，各种响应方法使代码更加的混乱和复杂，而RxSwift是一个统一的处理各种响应事件的方式\n\n* Observable的创建和订阅\n* Subjects的使用\n* Combination：Observable的混合操作\n* Transforming：Observable的转换操作\n* Filtering：Observable消息元素的过滤操作\n* 对Observable元素做运算操作\n* Connectable操作\n* 错误处理\n* debug\n\n<!-- more -->\n\n## 消息的订阅方式\n这些都是Observable的方法，参数都是闭包，闭包是观察者\n1. subscribe(on:(Event) -> void)：订阅所有消息(Next, Error, and Completed)\n2. subscribeNext((Element) -> void)：只订阅Next\n3. subscribeError((ErrorType) -> void)：只订阅Error\n4. subscribeCompleted(() -> Void)：只订阅Completed\n5. subscribe(onNext:(Element) -> void, onError:(ErrorType) -> void, onCompleted:() -> Void, onDisposed:() -> Void)订阅多个消息\n\n## 释放分配的资源\n订阅者可以通过调用.dispose()来释放分配的资源，但通过DisposeBag来管理或者通过takeUntil来自动释放更好\n\n``` swift\nlet disposeBag = DisposeBag()\nsubscription.addDisposableTo(disposeBag)\n```\n或\n\n``` swift\nsequence\n    .takeUntil(self.rx_deallocated)\n    .subscribe {\n        print($0)\n    }\n```\n## Observable的创建和订阅\nObservable序列分为两类：\n* 冷：只有当有观察者订阅这个序列时，序列才发射值\n* 热：序列创建时就开始发射值\n\n### never()创建即不会完成也不会发消息的Observable\n``` swift\nlet disposeBag = DisposeBag()\nlet neverSequence = Observable<String>.never()\n\nlet neverSequenceSubscription = neverSequence\n        .subscribe { _ in\n            print(\"This will never be printed\")\n    }\n\nneverSequenceSubscription.addDisposableTo(disposeBag)\n```\n<img src='./never.png' width=400/>\n\n### empty()创建只会发送一次完成消息的Observable\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable<Int>.empty()\n        .subscribe { event in\n            print(event)\n        }\n        .addDisposableTo(disposeBag)\n```\n`output:`\nCompleted\n\n<img src='./empty.png' width=400>\n\n### just()创建只包含一个元素的Observable，在发送一次Next消息后便发送Completed消息\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.just(\"🔴\")\n    .subscribe { event in\n        print(event)\n    }\n    .addDisposableTo(disposeBag)        \n```\n> 注：如果传递null给just，它将返回一个发送null消息的Observable，不要传入错误的参数，否则将会得到一个空的Observable\n\n`output:`\nNext(🔴)\nCompleted\n<br/>\n<img src='./just.png' width=400>\n\n\n### of()创建可以包含任意个元素的Observable，连续相同的元素会被忽略\n``` swift\n let disposeBag = DisposeBag()\n\n Observable.of(\"🐶\", \"🐱\", \"🐭\", \"🐹\")\n        .subscribeNext { element in\n            print(element)\n        }\n        .addDisposableTo(disposeBag)\n```\n`output:`\n🐶\n🐱\n🐭\n🐹\n\n### create()可以创建自定义的Observable，在最原始的Observable基础上创建Observable\n``` swift\nlet disposeBag = DisposeBag()\n\nlet myJust = { (element: String) -> Observable<String> in\n        return Observable.create { observer in\n            observer.on(.Next(element))\n            observer.on(.Completed)\n            return NopDisposable.instance\n        }\n    }\n\n myJust(\"🔴\")\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\nNext(🔴)\nCompleted\n<br/>\n<img src='./create.png' width=400>\n<br/>\n\n### range()创建一个发送一个范围的整数的Observable，发送完后发送Completed\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.range(start: 1, count: 10)\n        .subscribe { print($0) }\n        .addDisposableTo(disposeBag)\n```\n`output:`\nNext(1)\nNext(2)\nNext(3)\nNext(4)\nNext(5)\nNext(6)\nNext(7)\nNext(8)\nNext(9)\nNext(10)\nCompleted\n\n### repeatElement()创建一个可以重复发送消息的Observable，可以指定重复的次数，未指定即无限发送\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.repeatElement(\"🔴\")\n        .take(3)\n        .subscribeNext { print($0) }\n        .addDisposableTo(disposeBag)\n```\n`output:`\n🔴\n🔴\n🔴\n> 注：take可以用于所有Observable指定限制元素个数\n\n### generate()创建一个可以指定规则的Observable，会发送所有满足规则的元素\n``` swift\nlet disposeBag = DisposeBag()\n\n Observable.generate(\n            initialState: 0,\n            condition: { $0 < 3 },\n            iterate: { $0 + 1 }\n        )\n        .subscribeNext { print($0) }\n        .addDisposableTo(disposeBag)\n```\n**iterate：每次condition之后都会对当前值做一次相应迭代运算**\n\n`output:`<br/>\n0\n1\n2\n\n### deferred()序列为每一个订阅者创建一个全新的Observable\n``` swift\nlet disposeBag = DisposeBag()\nvar count = 1\n\nlet deferredSequence = Observable<String>.deferred {\n        print(\"Creating \\(count)\")\n        count += 1\n        return Observable.create { observer in\n            print(\"Emitting...\")\n            observer.onNext(\"🐶\")\n            observer.onNext(\"🐱\")\n            observer.onNext(\"🐵\")\n            return NopDisposable.instance\n        }\n    }\n\ndeferredSequence\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\ndeferredSequence\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n> 注：deferred序列只有在一个观察者订阅它的时候才执行它的创建Observable方法，产生一个全新的Observable**\n\n`output:`\nCreating 1\nEmitting...\n🐶\n🐱\n🐵\nCreating 2\nEmitting...\n🐶\n🐱\n🐵\n<img src='./deferred.png' width=400>\n<br/>\n\n### error()创建一个不发送元素的Observable，然后立即发送error并终止\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable<Int>.error(Error.Test)\n        .subscribe { print($0) }\n        .addDisposableTo(disposeBag)\n```\n`output:`\nError(Test)\n\n### doOn()在发送元素消息前对每一个元素做指定的操作，然后返回操作前的元素消息\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🍎\", \"🍐\", \"🍊\", \"🍋\")\n        .doOn { print(\"Intercepted:\", $0) }\n        .subscribeNext { print($0) }\n        .addDisposableTo(disposeBag)\n```\n> 注： doOn(onNext:onError:onCompleted:)为不同订阅方式分别指定\n\n`output:`\nIntercepted: Next(🍎)\n🍎\nIntercepted: Next(🍐)\n🍐\nIntercepted: Next(🍊)\n🍊\nIntercepted: Next(🍋)\n🍋\nIntercepted: Completed\n\n<img src='./doOn.png' width=400>\n<br/>\n\n### toObservable()通过Array,Dictionary,或Set等SequenceType创建一个Observable\n<br/>\n## Subjects的使用\n\nSubjects理解为observer和Observable之间的桥梁或代理，即扮演着observer又扮演着Observable，规定了添加的observer如何接收消息\n\n### PublishSubject向所有订阅者广播从订阅之后的事件\n``` swift\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.addObserver(\"1\").addDisposableTo(disposeBag)\nsubject.onNext(\"🐶\")\nsubject.onNext(\"🐱\")\n\nsubject.addObserver(\"2\").addDisposableTo(disposeBag)\nsubject.onNext(\"🅰️\")\nsubject.onNext(\"🅱️\")\n```\n`output:`\nSubscription: 1 Event: Next(🐶)\nSubscription: 1 Event: Next(🐱)\nSubscription: 1 Event: Next(🅰️)\nSubscription: 2 Event: Next(🅰️)\nSubscription: 1 Event: Next(🅱️)\nSubscription: 2 Event: Next(🅱️)\n\n### ReplaySubject有一个缓存机制，可以在创建时通过指定bufferSize指定缓存大小或调用buffer方法指定更详细的缓存条件来指定新添加的订阅者可以接收多少订阅前的消息\n``` swift\n let disposeBag = DisposeBag()\n let subject = ReplaySubject<String>.create(bufferSize: 1)\n\n subject.addObserver(\"1\").addDisposableTo(disposeBag)\n subject.onNext(\"🐶\")\n subject.onNext(\"🐱\")\n\n subject.addObserver(\"2\").addDisposableTo(disposeBag)\n subject.onNext(\"🅰️\")\n subject.onNext(\"🅱️\")\n```\n`output:`\nSubscription: 1 Event: Next(🐶)\nSubscription: 1 Event: Next(🐱)\nSubscription: 2 Event: Next(🐱)\nSubscription: 1 Event: Next(🅰️)\nSubscription: 2 Event: Next(🅰️)\nSubscription: 1 Event: Next(🅱️)\nSubscription: 2 Event: Next(🅱️)\n\n### BehaviorSubject向新的订阅者发送一条最近的事件，如果没有事件则发送一条默认的消息\n``` swift\nlet disposeBag = DisposeBag()\nlet subject = BehaviorSubject(value: \"🔴\")\n\nsubject.addObserver(\"1\").addDisposableTo(disposeBag)\nsubject.onNext(\"🐶\")\nsubject.onNext(\"🐱\")\n\nsubject.addObserver(\"2\").addDisposableTo(disposeBag)\nsubject.onNext(\"🅰️\")\nsubject.onNext(\"🅱️\")\n\nsubject.addObserver(\"3\").addDisposableTo(disposeBag)\nsubject.onNext(\"🍐\")\nsubject.onNext(\"🍊\")\n```\n**note：以上都不会自动发送Completed当它们被释放的时候**\n\n`output:`\nSubscription: 1 Event: Next(🔴)\nSubscription: 1 Event: Next(🐶)\nSubscription: 1 Event: Next(🐱)\nSubscription: 2 Event: Next(🐱)\nSubscription: 1 Event: Next(🅰️)\nSubscription: 2 Event: Next(🅰️)\nSubscription: 1 Event: Next(🅱️)\nSubscription: 2 Event: Next(🅱️)\nSubscription: 3 Event: Next(🅱️)\nSubscription: 1 Event: Next(🍐)\nSubscription: 2 Event: Next(🍐)\nSubscription: 3 Event: Next(🍐)\nSubscription: 1 Event: Next(🍊)\nSubscription: 2 Event: Next(🍊)\nSubscription: 3 Event: Next(🍊)\n\n### Variable与BehaviorSubject的区别是在完成的时候它会自动发送一条Completed消息和调用deist\n``` swift\n  let disposeBag = DisposeBag()\n  let variable = Variable(\"🔴\")\n\n  variable.asObservable().addObserver(\"1\").addDisposableTo(disposeBag)\n  variable.value = \"🐶\"\n  variable.value = \"🐱\"\n\n  variable.asObservable().addObserver(\"2\").addDisposableTo(disposeBag)\n  variable.value = \"🅰️\"\n  variable.value = \"🅱️\"\n```\n> 注:variable.asObservable()实际是获取variable中的BehaviorSubject。variable也没有onNext，而是通过value来获取或添加元素，它会添加元素到BehaviorSubject\n\n`output:`\nSubscription: 1 Event: Next(🔴)\nSubscription: 1 Event: Next(🐶)\nSubscription: 1 Event: Next(🐱)\nSubscription: 2 Event: Next(🐱)\nSubscription: 1 Event: Next(🅰️)\nSubscription: 2 Event: Next(🅰️)\nSubscription: 1 Event: Next(🅱️)\nSubscription: 2 Event: Next(🅱️)\nSubscription: 1 Event: Completed\nSubscription: 2 Event: Completed\n\n## Combination：Observable的混合操作\n\n### startWith()分为原Observable和新Observable，并且在发送原Observable元素前会先发送完新Observable元素，有点像栈\n``` swift\n   let disposeBag = DisposeBag()\n\n    Observable.of(\"🐶\", \"🐱\", \"🐭\", \"🐹\")\n        .startWith(\"1️⃣\")\n        .startWith(\"2️⃣\")\n        .startWith(\"3️⃣\", \"🅰️\", \"🅱️\")\n        .subscribeNext { print($0) }\n        .addDisposableTo(disposeBag)\n```\n`output:`\n3️⃣\n🅰️\n🅱️\n2️⃣\n1️⃣\n🐶\n🐱\n🐭\n🐹\n<http://reactivex.io/documentation/operators/startwith.html>\n\n\n### merge()按顺序混合多个Observable为一个新Observable\n``` swift\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<String>()\nlet subject2 = PublishSubject<String>()\nlet subject3 = PublishSubject<String>()\n\nObservable.of(subject1, subject2, subject3)\n    .merge()\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\nsubject1.onNext(\"🅰️\")\n\nsubject1.onNext(\"🅱️\")\n\nsubject2.onNext(\"①\")\n\nsubject2.onNext(\"②\")\n\nsubject1.onNext(\"🆎\")\n\nsubject3.onNext(\"🐱\")\n\nsubject2.onNext(\"③\")\n```\n`output:`\n🅰️\n🅱️\n①\n②\n🆎\n③\n<http://reactivex.io/documentation/operators/merge.html>\n\n\n### zip()相当于并排的将多个Observable合并成一个新Observable\n``` swift\nlet disposeBag = DisposeBag()\n\nlet stringSubject = PublishSubject<String>()\nlet intSubject = PublishSubject<Int>()\n\nObservable.zip(stringSubject, intSubject) { stringElement, intElement in\n    \"\\(stringElement) \\(intElement)\"\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\nstringSubject.onNext(\"🅰️\")\nstringSubject.onNext(\"🅱️\")\n\nintSubject.onNext(1)\n\nintSubject.onNext(2)\n\nstringSubject.onNext(\"🆎\")\nintSubject.onNext(3)\n```\n`output:`\n🅰️ 1\n🅱️ 2\n🆎 3\n\n<http://reactivex.io/documentation/operators/zip.html>\n</br>\n### combineLatest()总是将某个Observable发出的最新元素与其他Observable的最后发出的元素混合\n``` swift\nlet disposeBag = DisposeBag()\n\nlet stringSubject = PublishSubject<String>()\nlet intSubject = PublishSubject<Int>()\n\nObservable.combineLatest(stringSubject, intSubject) { stringElement, intElement in\n        \"\\(stringElement) \\(intElement)\"\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\nstringSubject.onNext(\"🅰️\")\n\nstringSubject.onNext(\"🅱️\")\nintSubject.onNext(1)\n\nintSubject.onNext(2)\n\nstringSubject.onNext(\"🆎\")\n```\n`output:`\n🅱️ 1\n🅱️ 2\n🆎 2\n<http://reactivex.io/documentation/operators/combinelatest.html>\n\n在数组上的应用：\n\n``` swift\nlet disposeBag = DisposeBag()\n\nlet stringObservable = Observable.just(\"❤️\")\nlet fruitObservable = [\"🍎\", \"🍐\", \"🍊\"].toObservable()\nlet animalObservable = Observable.of(\"🐶\", \"🐱\", \"🐭\", \"🐹\")\n\n[stringObservable, fruitObservable, animalObservable].combineLatest {\n        \"\\($0[0]) \\($0[1]) \\($0[2])\"\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n**note：所有集合的类型必须一样**\n\n`output:`\n❤️ 🍊 🐶\n❤️ 🍊 🐱\n❤️ 🍊 🐭\n❤️ 🍊 🐹\n\n### switchLatest()可以将多个Observable序列合并成一个一维的Observable序列，只合并当前关注的Observable序列最近的消息\n``` swift\nlet disposeBag = DisposeBag()\n\nlet subject1 = BehaviorSubject(value: \"⚽️\")\nlet subject2 = BehaviorSubject(value: \"🍎\")\n\nlet variable = Variable(subject1)\n\nvariable.asObservable()\n    .switchLatest()\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\nsubject1.onNext(\"🏈\")\nsubject1.onNext(\"🏀\")\n\nvariable.value = subject2\n\nsubject1.onNext(\"⚾️\")\nsubject1.onNext(\"🎾\")\n\nsubject2.onNext(\"🍐\")\n\nvariable.value = subject1\n```\n`output:`\n⚽️\n🏈\n🏀\n🍎\n🍐\n🎾\n**note：⚽️ 被忽略**\n<br/>\n<img src='./switch.png' width=400>\n<br/>\n\n## Transforming：Observable的转换操作 \n\n### map()将闭包操作应用到一个被观察序列的所有元素上，然后返回一个新的被观察序列\n``` swift\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3)\n    .map { $0 * $0 }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n1\n4\n9\n<http://reactivex.io/documentation/operators/map.html>\n\n\n### scan()可以迭代的操作，并且可以设置一个初始的迭代值\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(10, 100, 1000)\n    .scan(1) { aggregateValue, newValue in\n        aggregateValue + newValue\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n11\n111\n1111\n<http://reactivex.io/documentation/operators/scan.html>\n\n## Filtering：Observable消息元素的过滤操作\n\n### filter()发出满足bool条件的元素\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\n    \"🐱\", \"🐰\", \"🐶\",\n    \"🐸\", \"🐱\", \"🐰\",\n    \"🐹\", \"🐸\", \"🐱\")\n    .filter {\n        $0 == \"🐱\"\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐱\n🐱\n🐱\n<http://reactivex.io/documentation/operators/filter.html>\n\n### distinctUntilChanged()过滤掉连续的相同元素\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐷\", \"🐱\", \"🐱\", \"🐱\", \"🐵\", \"🐱\")\n    .distinctUntilChanged()\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐱\n🐷\n🐱\n🐵\n🐱\n<http://reactivex.io/documentation/operators/distinct.html>\n\n### elementAt()只发送指定下标的元素\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .elementAt(3)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐸\n<http://reactivex.io/documentation/operators/elementat.html>\n\n### single()不传参数则发送Observable的第一个元素，否则为满足条件表达式的第一个元素，如果没有发送一个确切的元素，将发送一个 Error消息\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .single{ $0 <= 6}//如果是==这种确切的判断，将没有Error消息而是Completed消息\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\nNext(1)\nError(Sequence contains more than one element.)\n\n### take()仅发送从第一个元素开始指定个数的元素\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .take(3)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐱\n🐰\n🐶\n<http://reactivex.io/documentation/operators/take.html>\n\n### takeLast()与take不同的是takeLast是从末尾开始\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .takeLast(3)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐸\n🐷\n🐵\n<http://reactivex.io/documentation/operators/takelast.html>\n\n### takeWhile()发送从头开始的满足条件的元素\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 2, 3, 4, 5, 6)\n    .takeWhile { $0 < 4 }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n1\n2\n3\n<img src='./takeWhile.png' width=400>\n<br/>\n\n### takeUntil：在与之关联的另一Observable发送元素前发送元素\n``` swift\nlet disposeBag = DisposeBag()\n\nlet sourceSequence = PublishSubject<String>()\nlet referenceSequence = PublishSubject<String>()\n\nsourceSequence\n    .takeUntil(referenceSequence)\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n\nsourceSequence.onNext(\"🐱\")\nsourceSequence.onNext(\"🐰\")\nsourceSequence.onNext(\"🐶\")\n\nreferenceSequence.onNext(\"🔴\")\n\nsourceSequence.onNext(\"🐸\")\nsourceSequence.onNext(\"🐷\")\nsourceSequence.onNext(\"🐵\")\n```\n`output:`\nNext(🐱)\nNext(🐰)\nNext(🐶)\nCompleted<br/>\n<http://reactivex.io/documentation/operators/takeuntil.html>\n\n### skip()与take相反，它是不发送\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .skip(2)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐶\n🐸\n🐷\n🐵\n<http://reactivex.io/documentation/operators/skip.html>\n\n### skipWhile()与takeWhile相反，它是不发送\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 2, 3, 4, 5, 6)\n    .skipWhile { $0 < 4 }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n4\n5\n6\n<br/>\n<img src='./skipWhile.png' width=400>\n<br/>\n\n### skipWhileWithIndex()只是skipWhile基础上增加了一个下标index\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .skipWhileWithIndex { element, index in\n        index < 3\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐸\n🐷\n🐵\n\n### skipUntil()与takeUntil相反，它是之后发送\n``` swift\nlet disposeBag = DisposeBag()\n\nlet sourceSequence = PublishSubject<String>()\nlet referenceSequence = PublishSubject<String>()\n\nsourceSequence\n    .skipUntil(referenceSequence)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\nsourceSequence.onNext(\"🐱\")\nsourceSequence.onNext(\"🐰\")\nsourceSequence.onNext(\"🐶\")\n\nreferenceSequence.onNext(\"🔴\")\n\nsourceSequence.onNext(\"🐸\")\nsourceSequence.onNext(\"🐷\")\nsourceSequence.onNext(\"🐵\")\n```\n`output:`\n🐸\n🐷\n🐵\n<http://reactivex.io/documentation/operators/skipuntil.html>\n\n## 对Observable元素做运算操作\n\n### toArray()将Observable序列转换成array并发送，然后终止\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.range(start: 1, count: 10)\n    .toArray()\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\nNext([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\nCompleted\n<br/>\n<img src='./toArray.png' width=400>\n<br/>\n\n### reduce()迭代运算，通过指定初始迭代值和运算符\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(10, 100, 1000)\n    .reduce(1, accumulator: +)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`=\n1111\n<http://reactivex.io/documentation/operators/reduce.html>\n\n### concat()将一个Observable序列的内部Observable序列串联起来，且同一时间只操作一个序列，只有当前序列Completed后，才开始串联下一个序列的前一个元素及之后的元素\n``` swift\nlet disposeBag = DisposeBag()\n\nlet subject1 = BehaviorSubject(value: \"🍎\")\nlet subject2 = BehaviorSubject(value: \"🐶\")\n\nlet variable = Variable(subject1)\n\nvariable.asObservable()\n    .concat()\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n\nsubject1.onNext(\"🍐\")\nsubject1.onNext(\"🍊\")\n\nvariable.value = subject2\n\nsubject2.onNext(\"I would be ignored\")\nsubject2.onNext(\"🐱\")\n\nsubject1.onNext(\"🍹\")\nsubject1.onCompleted()\n\nsubject2.onNext(\"🐭\")\n```\n`output:`\nNext(🍎)\nNext(🍐)\nNext(🍊)\nNext(🍹)\nNext(🐱)\nNext(🐭)\n<http://reactivex.io/documentation/operators/concat.html>\n\n## Connectable操作\n\nConnectable操作，Connectable Observable操作跟普通的Observable区别在于，Connectable Observable只有在它们的connect()方法调用后才开始发送元素，因此可以等到所有订阅者都订阅后才开始发送元素，有点像事务一样\n\n### publish()将一个普通序列转换成Connectable Observable序列\n``` swift\nprintExampleHeader(#function)\n\nlet intSequence = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n    .publish()\n\n_ = intSequence\n    .subscribeNext { print(\"Subscription 1:, Event: \\($0)\") }\n\ndelay(2) { intSequence.connect() }\n\ndelay(4) {\n    _ = intSequence\n        .subscribeNext { print(\"Subscription 2:, Event: \\($0)\") }\n\n}\n\ndelay(6) {\n    _ = intSequence\n        .subscribeNext { print(\"Subscription 3:, Event: \\($0)\") }\n```\n`output:`\n\ndelay 2\n\nSubscription 1:, Event: 0\nSubscription 1:, Event: 1\nSubscription 2:, Event: 1\nSubscription 1:, Event: 2\nSubscription 2:, Event: 2\nSubscription 1:, Event: 3\nSubscription 2:, Event: 3\nSubscription 3:, Event: 3\nSubscription 1:, Event: 4\nSubscription 2:, Event: 4\nSubscription 3:, Event: 4\n<br/>\n<img src='./publish.png' width=400>\n<br/>\n\n### replay()相对于publish增加了bufferSize指定对元素的缓存大小，这样新加入的订阅者可以获取相应个数的已发送的元素\n``` swift\nprintExampleHeader(#function)\n\nlet intSequence = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n    .replay(5)\n\n_ = intSequence\n    .subscribeNext { print(\"Subscription 1:, Event: \\($0)\") }\n\ndelay(2) { intSequence.connect() }\n\ndelay(4) {\n    _ = intSequence\n        .subscribeNext { print(\"Subscription 2:, Event: \\($0)\") }\n}\n\ndelay(8) {\n    _ = intSequence\n        .subscribeNext { print(\"Subscription 3:, Event: \\($0)\") }\n}\n```\n`output:`\n\ndelay 2\n\nSubscription 1:, Event: 0\nSubscription 2:, Event: 0\nSubscription 1:, Event: 1\nSubscription 2:, Event: 1\nSubscription 1:, Event: 2\nSubscription 2:, Event: 2\nSubscription 1:, Event: 3\nSubscription 2:, Event: 3\nSubscription 1:, Event: 4\nSubscription 2:, Event: 4\nSubscription 3:, Event: 0\nSubscription 3:, Event: 1\nSubscription 3:, Event: 2\nSubscription 3:, Event: 3\nSubscription 3:, Event: 4\nSubscription 1:, Event: 5\nSubscription 2:, Event: 5\nSubscription 3:, Event: 5\n<br/>\n<img src='./replay.png' width=400>\n<br/>\n\n### multicast()需要传入一个subject，通过subject来管理向订阅者发送消息\n``` swift\nprintExampleHeader(#function)\n\nlet subject = PublishSubject<Int>()\n\n_ = subject\n    .subscribeNext { print(\"Subject: \\($0)\") }\n\nlet intSequence = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n    .multicast(subject)\n\n_ = intSequence\n    .subscribeNext { print(\"\\tSubscription 1:, Event: \\($0)\") }\n\ndelay(2) { intSequence.connect() }\n\ndelay(4) {\n     _ = intSequence\n        .subscribeNext { print(\"\\tSubscription 2:, Event: \\($0)\") }\n}\n\ndelay(6) {\n     _ = intSequence\n        .subscribeNext { print(\"\\tSubscription 3:, Event: \\($0)\") }\n}\n```\n`output:`\n\ndelay 2\n\nSubject: 0\nSubscription 1:, Event: 0\n Subject: 1\nSubscription 1:, Event: 1\nSubscription 2:, Event: 1\n Subject: 2\nSubscription 1:, Event: 2\nSubscription 2:, Event: 2\n Subject: 3\nSubscription 1:, Event: 3\nSubscription 2:, Event: 3\nSubscription 3:, Event: 3\n Subject: 4\nSubscription 1:, Event: 4\nSubscription 2:, Event: 4\nSubscription 3:, Event: 4\n Subject: 5\nSubscription 1:, Event: 5\nSubscription 2:, Event: 5\nSubscription 3:, Event: 5\n\n## 错误处理\n\n### catchErrorJustReturn()通过返回一个只发送一个元素的Observable序列来捕获错误信息，然后 Completed\n``` swift\nlet disposeBag = DisposeBag()\n\nlet sequenceThatFails = PublishSubject<String>()\n\nsequenceThatFails\n    .catchErrorJustReturn(\"😊\")\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n\nsequenceThatFails.onNext(\"😬\")\nsequenceThatFails.onNext(\"😨\")\nsequenceThatFails.onNext(\"😡\")\nsequenceThatFails.onNext(\"🔴\")\nsequenceThatFails.onError(Error.Test)\n```\n`output:`\nNext(😬)\nNext(😨)\nNext(😡)\nNext(🔴)\nNext(😊)\nCompleted\n\n### catchError()当捕获错误后会返回一个正常的Observable序列与之合并\n``` swift\nlet disposeBag = DisposeBag()\n\nlet sequenceThatErrors = PublishSubject<String>()\nlet recoverySequence = PublishSubject<String>()\n\nsequenceThatErrors\n    .catchError {\n        print(\"Error:\", $0)\n        return recoverySequence\n    }\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n\nsequenceThatErrors.onNext(\"😬\")\nsequenceThatErrors.onNext(\"😨\")\nsequenceThatErrors.onNext(\"😡\")\nsequenceThatErrors.onNext(\"🔴\")\nsequenceThatErrors.onError(Error.Test)\n\nrecoverySequence.onNext(\"😊\")\n```\n`output:`\nNext(😬)\nNext(😨)\nNext(😡)\nNext(🔴)\nError: Test\nNext(😊)\n<br/>\n<img src='./catch.png' width=400>\n<br/>\n\n### retry()当遇到error后发送一条error消息然后重新重头发送元素，通过传入一个整数可以指定重复次数\n``` swift\nlet disposeBag = DisposeBag()\n    var count = 1\n\nlet sequenceThatErrors = Observable<String>.create { observer in\n    observer.onNext(\"🍎\")\n    observer.onNext(\"🍐\")\n    observer.onNext(\"🍊\")\n\n    if count == 1 {\n        observer.onError(Error.Test)\n        print(\"Error encountered\")\n        count += 1\n    }\n\n    observer.onNext(\"🐶\")\n    observer.onNext(\"🐱\")\n    observer.onNext(\"🐭\")\n    observer.onCompleted()\n\n    return NopDisposable.instance\n}\n\nsequenceThatErrors\n    .retry()\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🍎\n🍐\n🍊\nError encountered\n🍎\n🍐\n🍊\n🐶\n🐱\n🐭\n<br/>\n<img src='./retry.png' width=400>\n<br/>\n\n## debug\n\n1. debug()会打印详细的信息\n2. RxSwift.resourceCount()打印资源分配计数\n\n> 注：不要在Release builds中使用","source":"_posts/RXSwift基础.md","raw":"---\ntitle: RXSwift基础\ndate: 2016-06-08 09:32:44\ntags:\n   - RXSwift\n---\n\n## 概念\n\n一个观察者(Observer)订阅一个可观察序列(Observable)。观察者对Observable发射的数据或数据序列作出响应\n\n## 为什么发用RxSwift\n一个程序通常包含着大量的各种事件的产生以及对应的处理逻辑，各种响应方法使代码更加的混乱和复杂，而RxSwift是一个统一的处理各种响应事件的方式\n\n* Observable的创建和订阅\n* Subjects的使用\n* Combination：Observable的混合操作\n* Transforming：Observable的转换操作\n* Filtering：Observable消息元素的过滤操作\n* 对Observable元素做运算操作\n* Connectable操作\n* 错误处理\n* debug\n\n<!-- more -->\n\n## 消息的订阅方式\n这些都是Observable的方法，参数都是闭包，闭包是观察者\n1. subscribe(on:(Event) -> void)：订阅所有消息(Next, Error, and Completed)\n2. subscribeNext((Element) -> void)：只订阅Next\n3. subscribeError((ErrorType) -> void)：只订阅Error\n4. subscribeCompleted(() -> Void)：只订阅Completed\n5. subscribe(onNext:(Element) -> void, onError:(ErrorType) -> void, onCompleted:() -> Void, onDisposed:() -> Void)订阅多个消息\n\n## 释放分配的资源\n订阅者可以通过调用.dispose()来释放分配的资源，但通过DisposeBag来管理或者通过takeUntil来自动释放更好\n\n``` swift\nlet disposeBag = DisposeBag()\nsubscription.addDisposableTo(disposeBag)\n```\n或\n\n``` swift\nsequence\n    .takeUntil(self.rx_deallocated)\n    .subscribe {\n        print($0)\n    }\n```\n## Observable的创建和订阅\nObservable序列分为两类：\n* 冷：只有当有观察者订阅这个序列时，序列才发射值\n* 热：序列创建时就开始发射值\n\n### never()创建即不会完成也不会发消息的Observable\n``` swift\nlet disposeBag = DisposeBag()\nlet neverSequence = Observable<String>.never()\n\nlet neverSequenceSubscription = neverSequence\n        .subscribe { _ in\n            print(\"This will never be printed\")\n    }\n\nneverSequenceSubscription.addDisposableTo(disposeBag)\n```\n<img src='./never.png' width=400/>\n\n### empty()创建只会发送一次完成消息的Observable\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable<Int>.empty()\n        .subscribe { event in\n            print(event)\n        }\n        .addDisposableTo(disposeBag)\n```\n`output:`\nCompleted\n\n<img src='./empty.png' width=400>\n\n### just()创建只包含一个元素的Observable，在发送一次Next消息后便发送Completed消息\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.just(\"🔴\")\n    .subscribe { event in\n        print(event)\n    }\n    .addDisposableTo(disposeBag)        \n```\n> 注：如果传递null给just，它将返回一个发送null消息的Observable，不要传入错误的参数，否则将会得到一个空的Observable\n\n`output:`\nNext(🔴)\nCompleted\n<br/>\n<img src='./just.png' width=400>\n\n\n### of()创建可以包含任意个元素的Observable，连续相同的元素会被忽略\n``` swift\n let disposeBag = DisposeBag()\n\n Observable.of(\"🐶\", \"🐱\", \"🐭\", \"🐹\")\n        .subscribeNext { element in\n            print(element)\n        }\n        .addDisposableTo(disposeBag)\n```\n`output:`\n🐶\n🐱\n🐭\n🐹\n\n### create()可以创建自定义的Observable，在最原始的Observable基础上创建Observable\n``` swift\nlet disposeBag = DisposeBag()\n\nlet myJust = { (element: String) -> Observable<String> in\n        return Observable.create { observer in\n            observer.on(.Next(element))\n            observer.on(.Completed)\n            return NopDisposable.instance\n        }\n    }\n\n myJust(\"🔴\")\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\nNext(🔴)\nCompleted\n<br/>\n<img src='./create.png' width=400>\n<br/>\n\n### range()创建一个发送一个范围的整数的Observable，发送完后发送Completed\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.range(start: 1, count: 10)\n        .subscribe { print($0) }\n        .addDisposableTo(disposeBag)\n```\n`output:`\nNext(1)\nNext(2)\nNext(3)\nNext(4)\nNext(5)\nNext(6)\nNext(7)\nNext(8)\nNext(9)\nNext(10)\nCompleted\n\n### repeatElement()创建一个可以重复发送消息的Observable，可以指定重复的次数，未指定即无限发送\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.repeatElement(\"🔴\")\n        .take(3)\n        .subscribeNext { print($0) }\n        .addDisposableTo(disposeBag)\n```\n`output:`\n🔴\n🔴\n🔴\n> 注：take可以用于所有Observable指定限制元素个数\n\n### generate()创建一个可以指定规则的Observable，会发送所有满足规则的元素\n``` swift\nlet disposeBag = DisposeBag()\n\n Observable.generate(\n            initialState: 0,\n            condition: { $0 < 3 },\n            iterate: { $0 + 1 }\n        )\n        .subscribeNext { print($0) }\n        .addDisposableTo(disposeBag)\n```\n**iterate：每次condition之后都会对当前值做一次相应迭代运算**\n\n`output:`<br/>\n0\n1\n2\n\n### deferred()序列为每一个订阅者创建一个全新的Observable\n``` swift\nlet disposeBag = DisposeBag()\nvar count = 1\n\nlet deferredSequence = Observable<String>.deferred {\n        print(\"Creating \\(count)\")\n        count += 1\n        return Observable.create { observer in\n            print(\"Emitting...\")\n            observer.onNext(\"🐶\")\n            observer.onNext(\"🐱\")\n            observer.onNext(\"🐵\")\n            return NopDisposable.instance\n        }\n    }\n\ndeferredSequence\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\ndeferredSequence\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n> 注：deferred序列只有在一个观察者订阅它的时候才执行它的创建Observable方法，产生一个全新的Observable**\n\n`output:`\nCreating 1\nEmitting...\n🐶\n🐱\n🐵\nCreating 2\nEmitting...\n🐶\n🐱\n🐵\n<img src='./deferred.png' width=400>\n<br/>\n\n### error()创建一个不发送元素的Observable，然后立即发送error并终止\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable<Int>.error(Error.Test)\n        .subscribe { print($0) }\n        .addDisposableTo(disposeBag)\n```\n`output:`\nError(Test)\n\n### doOn()在发送元素消息前对每一个元素做指定的操作，然后返回操作前的元素消息\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🍎\", \"🍐\", \"🍊\", \"🍋\")\n        .doOn { print(\"Intercepted:\", $0) }\n        .subscribeNext { print($0) }\n        .addDisposableTo(disposeBag)\n```\n> 注： doOn(onNext:onError:onCompleted:)为不同订阅方式分别指定\n\n`output:`\nIntercepted: Next(🍎)\n🍎\nIntercepted: Next(🍐)\n🍐\nIntercepted: Next(🍊)\n🍊\nIntercepted: Next(🍋)\n🍋\nIntercepted: Completed\n\n<img src='./doOn.png' width=400>\n<br/>\n\n### toObservable()通过Array,Dictionary,或Set等SequenceType创建一个Observable\n<br/>\n## Subjects的使用\n\nSubjects理解为observer和Observable之间的桥梁或代理，即扮演着observer又扮演着Observable，规定了添加的observer如何接收消息\n\n### PublishSubject向所有订阅者广播从订阅之后的事件\n``` swift\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.addObserver(\"1\").addDisposableTo(disposeBag)\nsubject.onNext(\"🐶\")\nsubject.onNext(\"🐱\")\n\nsubject.addObserver(\"2\").addDisposableTo(disposeBag)\nsubject.onNext(\"🅰️\")\nsubject.onNext(\"🅱️\")\n```\n`output:`\nSubscription: 1 Event: Next(🐶)\nSubscription: 1 Event: Next(🐱)\nSubscription: 1 Event: Next(🅰️)\nSubscription: 2 Event: Next(🅰️)\nSubscription: 1 Event: Next(🅱️)\nSubscription: 2 Event: Next(🅱️)\n\n### ReplaySubject有一个缓存机制，可以在创建时通过指定bufferSize指定缓存大小或调用buffer方法指定更详细的缓存条件来指定新添加的订阅者可以接收多少订阅前的消息\n``` swift\n let disposeBag = DisposeBag()\n let subject = ReplaySubject<String>.create(bufferSize: 1)\n\n subject.addObserver(\"1\").addDisposableTo(disposeBag)\n subject.onNext(\"🐶\")\n subject.onNext(\"🐱\")\n\n subject.addObserver(\"2\").addDisposableTo(disposeBag)\n subject.onNext(\"🅰️\")\n subject.onNext(\"🅱️\")\n```\n`output:`\nSubscription: 1 Event: Next(🐶)\nSubscription: 1 Event: Next(🐱)\nSubscription: 2 Event: Next(🐱)\nSubscription: 1 Event: Next(🅰️)\nSubscription: 2 Event: Next(🅰️)\nSubscription: 1 Event: Next(🅱️)\nSubscription: 2 Event: Next(🅱️)\n\n### BehaviorSubject向新的订阅者发送一条最近的事件，如果没有事件则发送一条默认的消息\n``` swift\nlet disposeBag = DisposeBag()\nlet subject = BehaviorSubject(value: \"🔴\")\n\nsubject.addObserver(\"1\").addDisposableTo(disposeBag)\nsubject.onNext(\"🐶\")\nsubject.onNext(\"🐱\")\n\nsubject.addObserver(\"2\").addDisposableTo(disposeBag)\nsubject.onNext(\"🅰️\")\nsubject.onNext(\"🅱️\")\n\nsubject.addObserver(\"3\").addDisposableTo(disposeBag)\nsubject.onNext(\"🍐\")\nsubject.onNext(\"🍊\")\n```\n**note：以上都不会自动发送Completed当它们被释放的时候**\n\n`output:`\nSubscription: 1 Event: Next(🔴)\nSubscription: 1 Event: Next(🐶)\nSubscription: 1 Event: Next(🐱)\nSubscription: 2 Event: Next(🐱)\nSubscription: 1 Event: Next(🅰️)\nSubscription: 2 Event: Next(🅰️)\nSubscription: 1 Event: Next(🅱️)\nSubscription: 2 Event: Next(🅱️)\nSubscription: 3 Event: Next(🅱️)\nSubscription: 1 Event: Next(🍐)\nSubscription: 2 Event: Next(🍐)\nSubscription: 3 Event: Next(🍐)\nSubscription: 1 Event: Next(🍊)\nSubscription: 2 Event: Next(🍊)\nSubscription: 3 Event: Next(🍊)\n\n### Variable与BehaviorSubject的区别是在完成的时候它会自动发送一条Completed消息和调用deist\n``` swift\n  let disposeBag = DisposeBag()\n  let variable = Variable(\"🔴\")\n\n  variable.asObservable().addObserver(\"1\").addDisposableTo(disposeBag)\n  variable.value = \"🐶\"\n  variable.value = \"🐱\"\n\n  variable.asObservable().addObserver(\"2\").addDisposableTo(disposeBag)\n  variable.value = \"🅰️\"\n  variable.value = \"🅱️\"\n```\n> 注:variable.asObservable()实际是获取variable中的BehaviorSubject。variable也没有onNext，而是通过value来获取或添加元素，它会添加元素到BehaviorSubject\n\n`output:`\nSubscription: 1 Event: Next(🔴)\nSubscription: 1 Event: Next(🐶)\nSubscription: 1 Event: Next(🐱)\nSubscription: 2 Event: Next(🐱)\nSubscription: 1 Event: Next(🅰️)\nSubscription: 2 Event: Next(🅰️)\nSubscription: 1 Event: Next(🅱️)\nSubscription: 2 Event: Next(🅱️)\nSubscription: 1 Event: Completed\nSubscription: 2 Event: Completed\n\n## Combination：Observable的混合操作\n\n### startWith()分为原Observable和新Observable，并且在发送原Observable元素前会先发送完新Observable元素，有点像栈\n``` swift\n   let disposeBag = DisposeBag()\n\n    Observable.of(\"🐶\", \"🐱\", \"🐭\", \"🐹\")\n        .startWith(\"1️⃣\")\n        .startWith(\"2️⃣\")\n        .startWith(\"3️⃣\", \"🅰️\", \"🅱️\")\n        .subscribeNext { print($0) }\n        .addDisposableTo(disposeBag)\n```\n`output:`\n3️⃣\n🅰️\n🅱️\n2️⃣\n1️⃣\n🐶\n🐱\n🐭\n🐹\n<http://reactivex.io/documentation/operators/startwith.html>\n\n\n### merge()按顺序混合多个Observable为一个新Observable\n``` swift\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<String>()\nlet subject2 = PublishSubject<String>()\nlet subject3 = PublishSubject<String>()\n\nObservable.of(subject1, subject2, subject3)\n    .merge()\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\nsubject1.onNext(\"🅰️\")\n\nsubject1.onNext(\"🅱️\")\n\nsubject2.onNext(\"①\")\n\nsubject2.onNext(\"②\")\n\nsubject1.onNext(\"🆎\")\n\nsubject3.onNext(\"🐱\")\n\nsubject2.onNext(\"③\")\n```\n`output:`\n🅰️\n🅱️\n①\n②\n🆎\n③\n<http://reactivex.io/documentation/operators/merge.html>\n\n\n### zip()相当于并排的将多个Observable合并成一个新Observable\n``` swift\nlet disposeBag = DisposeBag()\n\nlet stringSubject = PublishSubject<String>()\nlet intSubject = PublishSubject<Int>()\n\nObservable.zip(stringSubject, intSubject) { stringElement, intElement in\n    \"\\(stringElement) \\(intElement)\"\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\nstringSubject.onNext(\"🅰️\")\nstringSubject.onNext(\"🅱️\")\n\nintSubject.onNext(1)\n\nintSubject.onNext(2)\n\nstringSubject.onNext(\"🆎\")\nintSubject.onNext(3)\n```\n`output:`\n🅰️ 1\n🅱️ 2\n🆎 3\n\n<http://reactivex.io/documentation/operators/zip.html>\n</br>\n### combineLatest()总是将某个Observable发出的最新元素与其他Observable的最后发出的元素混合\n``` swift\nlet disposeBag = DisposeBag()\n\nlet stringSubject = PublishSubject<String>()\nlet intSubject = PublishSubject<Int>()\n\nObservable.combineLatest(stringSubject, intSubject) { stringElement, intElement in\n        \"\\(stringElement) \\(intElement)\"\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\nstringSubject.onNext(\"🅰️\")\n\nstringSubject.onNext(\"🅱️\")\nintSubject.onNext(1)\n\nintSubject.onNext(2)\n\nstringSubject.onNext(\"🆎\")\n```\n`output:`\n🅱️ 1\n🅱️ 2\n🆎 2\n<http://reactivex.io/documentation/operators/combinelatest.html>\n\n在数组上的应用：\n\n``` swift\nlet disposeBag = DisposeBag()\n\nlet stringObservable = Observable.just(\"❤️\")\nlet fruitObservable = [\"🍎\", \"🍐\", \"🍊\"].toObservable()\nlet animalObservable = Observable.of(\"🐶\", \"🐱\", \"🐭\", \"🐹\")\n\n[stringObservable, fruitObservable, animalObservable].combineLatest {\n        \"\\($0[0]) \\($0[1]) \\($0[2])\"\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n**note：所有集合的类型必须一样**\n\n`output:`\n❤️ 🍊 🐶\n❤️ 🍊 🐱\n❤️ 🍊 🐭\n❤️ 🍊 🐹\n\n### switchLatest()可以将多个Observable序列合并成一个一维的Observable序列，只合并当前关注的Observable序列最近的消息\n``` swift\nlet disposeBag = DisposeBag()\n\nlet subject1 = BehaviorSubject(value: \"⚽️\")\nlet subject2 = BehaviorSubject(value: \"🍎\")\n\nlet variable = Variable(subject1)\n\nvariable.asObservable()\n    .switchLatest()\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\nsubject1.onNext(\"🏈\")\nsubject1.onNext(\"🏀\")\n\nvariable.value = subject2\n\nsubject1.onNext(\"⚾️\")\nsubject1.onNext(\"🎾\")\n\nsubject2.onNext(\"🍐\")\n\nvariable.value = subject1\n```\n`output:`\n⚽️\n🏈\n🏀\n🍎\n🍐\n🎾\n**note：⚽️ 被忽略**\n<br/>\n<img src='./switch.png' width=400>\n<br/>\n\n## Transforming：Observable的转换操作 \n\n### map()将闭包操作应用到一个被观察序列的所有元素上，然后返回一个新的被观察序列\n``` swift\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3)\n    .map { $0 * $0 }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n1\n4\n9\n<http://reactivex.io/documentation/operators/map.html>\n\n\n### scan()可以迭代的操作，并且可以设置一个初始的迭代值\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(10, 100, 1000)\n    .scan(1) { aggregateValue, newValue in\n        aggregateValue + newValue\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n11\n111\n1111\n<http://reactivex.io/documentation/operators/scan.html>\n\n## Filtering：Observable消息元素的过滤操作\n\n### filter()发出满足bool条件的元素\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\n    \"🐱\", \"🐰\", \"🐶\",\n    \"🐸\", \"🐱\", \"🐰\",\n    \"🐹\", \"🐸\", \"🐱\")\n    .filter {\n        $0 == \"🐱\"\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐱\n🐱\n🐱\n<http://reactivex.io/documentation/operators/filter.html>\n\n### distinctUntilChanged()过滤掉连续的相同元素\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐷\", \"🐱\", \"🐱\", \"🐱\", \"🐵\", \"🐱\")\n    .distinctUntilChanged()\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐱\n🐷\n🐱\n🐵\n🐱\n<http://reactivex.io/documentation/operators/distinct.html>\n\n### elementAt()只发送指定下标的元素\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .elementAt(3)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐸\n<http://reactivex.io/documentation/operators/elementat.html>\n\n### single()不传参数则发送Observable的第一个元素，否则为满足条件表达式的第一个元素，如果没有发送一个确切的元素，将发送一个 Error消息\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .single{ $0 <= 6}//如果是==这种确切的判断，将没有Error消息而是Completed消息\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\nNext(1)\nError(Sequence contains more than one element.)\n\n### take()仅发送从第一个元素开始指定个数的元素\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .take(3)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐱\n🐰\n🐶\n<http://reactivex.io/documentation/operators/take.html>\n\n### takeLast()与take不同的是takeLast是从末尾开始\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .takeLast(3)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐸\n🐷\n🐵\n<http://reactivex.io/documentation/operators/takelast.html>\n\n### takeWhile()发送从头开始的满足条件的元素\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 2, 3, 4, 5, 6)\n    .takeWhile { $0 < 4 }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n1\n2\n3\n<img src='./takeWhile.png' width=400>\n<br/>\n\n### takeUntil：在与之关联的另一Observable发送元素前发送元素\n``` swift\nlet disposeBag = DisposeBag()\n\nlet sourceSequence = PublishSubject<String>()\nlet referenceSequence = PublishSubject<String>()\n\nsourceSequence\n    .takeUntil(referenceSequence)\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n\nsourceSequence.onNext(\"🐱\")\nsourceSequence.onNext(\"🐰\")\nsourceSequence.onNext(\"🐶\")\n\nreferenceSequence.onNext(\"🔴\")\n\nsourceSequence.onNext(\"🐸\")\nsourceSequence.onNext(\"🐷\")\nsourceSequence.onNext(\"🐵\")\n```\n`output:`\nNext(🐱)\nNext(🐰)\nNext(🐶)\nCompleted<br/>\n<http://reactivex.io/documentation/operators/takeuntil.html>\n\n### skip()与take相反，它是不发送\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .skip(2)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐶\n🐸\n🐷\n🐵\n<http://reactivex.io/documentation/operators/skip.html>\n\n### skipWhile()与takeWhile相反，它是不发送\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 2, 3, 4, 5, 6)\n    .skipWhile { $0 < 4 }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n4\n5\n6\n<br/>\n<img src='./skipWhile.png' width=400>\n<br/>\n\n### skipWhileWithIndex()只是skipWhile基础上增加了一个下标index\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(\"🐱\", \"🐰\", \"🐶\", \"🐸\", \"🐷\", \"🐵\")\n    .skipWhileWithIndex { element, index in\n        index < 3\n    }\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🐸\n🐷\n🐵\n\n### skipUntil()与takeUntil相反，它是之后发送\n``` swift\nlet disposeBag = DisposeBag()\n\nlet sourceSequence = PublishSubject<String>()\nlet referenceSequence = PublishSubject<String>()\n\nsourceSequence\n    .skipUntil(referenceSequence)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n\nsourceSequence.onNext(\"🐱\")\nsourceSequence.onNext(\"🐰\")\nsourceSequence.onNext(\"🐶\")\n\nreferenceSequence.onNext(\"🔴\")\n\nsourceSequence.onNext(\"🐸\")\nsourceSequence.onNext(\"🐷\")\nsourceSequence.onNext(\"🐵\")\n```\n`output:`\n🐸\n🐷\n🐵\n<http://reactivex.io/documentation/operators/skipuntil.html>\n\n## 对Observable元素做运算操作\n\n### toArray()将Observable序列转换成array并发送，然后终止\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.range(start: 1, count: 10)\n    .toArray()\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\nNext([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\nCompleted\n<br/>\n<img src='./toArray.png' width=400>\n<br/>\n\n### reduce()迭代运算，通过指定初始迭代值和运算符\n``` swift\nlet disposeBag = DisposeBag()\n\nObservable.of(10, 100, 1000)\n    .reduce(1, accumulator: +)\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`=\n1111\n<http://reactivex.io/documentation/operators/reduce.html>\n\n### concat()将一个Observable序列的内部Observable序列串联起来，且同一时间只操作一个序列，只有当前序列Completed后，才开始串联下一个序列的前一个元素及之后的元素\n``` swift\nlet disposeBag = DisposeBag()\n\nlet subject1 = BehaviorSubject(value: \"🍎\")\nlet subject2 = BehaviorSubject(value: \"🐶\")\n\nlet variable = Variable(subject1)\n\nvariable.asObservable()\n    .concat()\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n\nsubject1.onNext(\"🍐\")\nsubject1.onNext(\"🍊\")\n\nvariable.value = subject2\n\nsubject2.onNext(\"I would be ignored\")\nsubject2.onNext(\"🐱\")\n\nsubject1.onNext(\"🍹\")\nsubject1.onCompleted()\n\nsubject2.onNext(\"🐭\")\n```\n`output:`\nNext(🍎)\nNext(🍐)\nNext(🍊)\nNext(🍹)\nNext(🐱)\nNext(🐭)\n<http://reactivex.io/documentation/operators/concat.html>\n\n## Connectable操作\n\nConnectable操作，Connectable Observable操作跟普通的Observable区别在于，Connectable Observable只有在它们的connect()方法调用后才开始发送元素，因此可以等到所有订阅者都订阅后才开始发送元素，有点像事务一样\n\n### publish()将一个普通序列转换成Connectable Observable序列\n``` swift\nprintExampleHeader(#function)\n\nlet intSequence = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n    .publish()\n\n_ = intSequence\n    .subscribeNext { print(\"Subscription 1:, Event: \\($0)\") }\n\ndelay(2) { intSequence.connect() }\n\ndelay(4) {\n    _ = intSequence\n        .subscribeNext { print(\"Subscription 2:, Event: \\($0)\") }\n\n}\n\ndelay(6) {\n    _ = intSequence\n        .subscribeNext { print(\"Subscription 3:, Event: \\($0)\") }\n```\n`output:`\n\ndelay 2\n\nSubscription 1:, Event: 0\nSubscription 1:, Event: 1\nSubscription 2:, Event: 1\nSubscription 1:, Event: 2\nSubscription 2:, Event: 2\nSubscription 1:, Event: 3\nSubscription 2:, Event: 3\nSubscription 3:, Event: 3\nSubscription 1:, Event: 4\nSubscription 2:, Event: 4\nSubscription 3:, Event: 4\n<br/>\n<img src='./publish.png' width=400>\n<br/>\n\n### replay()相对于publish增加了bufferSize指定对元素的缓存大小，这样新加入的订阅者可以获取相应个数的已发送的元素\n``` swift\nprintExampleHeader(#function)\n\nlet intSequence = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n    .replay(5)\n\n_ = intSequence\n    .subscribeNext { print(\"Subscription 1:, Event: \\($0)\") }\n\ndelay(2) { intSequence.connect() }\n\ndelay(4) {\n    _ = intSequence\n        .subscribeNext { print(\"Subscription 2:, Event: \\($0)\") }\n}\n\ndelay(8) {\n    _ = intSequence\n        .subscribeNext { print(\"Subscription 3:, Event: \\($0)\") }\n}\n```\n`output:`\n\ndelay 2\n\nSubscription 1:, Event: 0\nSubscription 2:, Event: 0\nSubscription 1:, Event: 1\nSubscription 2:, Event: 1\nSubscription 1:, Event: 2\nSubscription 2:, Event: 2\nSubscription 1:, Event: 3\nSubscription 2:, Event: 3\nSubscription 1:, Event: 4\nSubscription 2:, Event: 4\nSubscription 3:, Event: 0\nSubscription 3:, Event: 1\nSubscription 3:, Event: 2\nSubscription 3:, Event: 3\nSubscription 3:, Event: 4\nSubscription 1:, Event: 5\nSubscription 2:, Event: 5\nSubscription 3:, Event: 5\n<br/>\n<img src='./replay.png' width=400>\n<br/>\n\n### multicast()需要传入一个subject，通过subject来管理向订阅者发送消息\n``` swift\nprintExampleHeader(#function)\n\nlet subject = PublishSubject<Int>()\n\n_ = subject\n    .subscribeNext { print(\"Subject: \\($0)\") }\n\nlet intSequence = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n    .multicast(subject)\n\n_ = intSequence\n    .subscribeNext { print(\"\\tSubscription 1:, Event: \\($0)\") }\n\ndelay(2) { intSequence.connect() }\n\ndelay(4) {\n     _ = intSequence\n        .subscribeNext { print(\"\\tSubscription 2:, Event: \\($0)\") }\n}\n\ndelay(6) {\n     _ = intSequence\n        .subscribeNext { print(\"\\tSubscription 3:, Event: \\($0)\") }\n}\n```\n`output:`\n\ndelay 2\n\nSubject: 0\nSubscription 1:, Event: 0\n Subject: 1\nSubscription 1:, Event: 1\nSubscription 2:, Event: 1\n Subject: 2\nSubscription 1:, Event: 2\nSubscription 2:, Event: 2\n Subject: 3\nSubscription 1:, Event: 3\nSubscription 2:, Event: 3\nSubscription 3:, Event: 3\n Subject: 4\nSubscription 1:, Event: 4\nSubscription 2:, Event: 4\nSubscription 3:, Event: 4\n Subject: 5\nSubscription 1:, Event: 5\nSubscription 2:, Event: 5\nSubscription 3:, Event: 5\n\n## 错误处理\n\n### catchErrorJustReturn()通过返回一个只发送一个元素的Observable序列来捕获错误信息，然后 Completed\n``` swift\nlet disposeBag = DisposeBag()\n\nlet sequenceThatFails = PublishSubject<String>()\n\nsequenceThatFails\n    .catchErrorJustReturn(\"😊\")\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n\nsequenceThatFails.onNext(\"😬\")\nsequenceThatFails.onNext(\"😨\")\nsequenceThatFails.onNext(\"😡\")\nsequenceThatFails.onNext(\"🔴\")\nsequenceThatFails.onError(Error.Test)\n```\n`output:`\nNext(😬)\nNext(😨)\nNext(😡)\nNext(🔴)\nNext(😊)\nCompleted\n\n### catchError()当捕获错误后会返回一个正常的Observable序列与之合并\n``` swift\nlet disposeBag = DisposeBag()\n\nlet sequenceThatErrors = PublishSubject<String>()\nlet recoverySequence = PublishSubject<String>()\n\nsequenceThatErrors\n    .catchError {\n        print(\"Error:\", $0)\n        return recoverySequence\n    }\n    .subscribe { print($0) }\n    .addDisposableTo(disposeBag)\n\nsequenceThatErrors.onNext(\"😬\")\nsequenceThatErrors.onNext(\"😨\")\nsequenceThatErrors.onNext(\"😡\")\nsequenceThatErrors.onNext(\"🔴\")\nsequenceThatErrors.onError(Error.Test)\n\nrecoverySequence.onNext(\"😊\")\n```\n`output:`\nNext(😬)\nNext(😨)\nNext(😡)\nNext(🔴)\nError: Test\nNext(😊)\n<br/>\n<img src='./catch.png' width=400>\n<br/>\n\n### retry()当遇到error后发送一条error消息然后重新重头发送元素，通过传入一个整数可以指定重复次数\n``` swift\nlet disposeBag = DisposeBag()\n    var count = 1\n\nlet sequenceThatErrors = Observable<String>.create { observer in\n    observer.onNext(\"🍎\")\n    observer.onNext(\"🍐\")\n    observer.onNext(\"🍊\")\n\n    if count == 1 {\n        observer.onError(Error.Test)\n        print(\"Error encountered\")\n        count += 1\n    }\n\n    observer.onNext(\"🐶\")\n    observer.onNext(\"🐱\")\n    observer.onNext(\"🐭\")\n    observer.onCompleted()\n\n    return NopDisposable.instance\n}\n\nsequenceThatErrors\n    .retry()\n    .subscribeNext { print($0) }\n    .addDisposableTo(disposeBag)\n```\n`output:`\n🍎\n🍐\n🍊\nError encountered\n🍎\n🍐\n🍊\n🐶\n🐱\n🐭\n<br/>\n<img src='./retry.png' width=400>\n<br/>\n\n## debug\n\n1. debug()会打印详细的信息\n2. RxSwift.resourceCount()打印资源分配计数\n\n> 注：不要在Release builds中使用","slug":"RXSwift基础","published":1,"updated":"2016-06-08T02:04:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcip001o29we7kwzslne"},{"title":"RESideMenu在所有界面都会侧滑的问题解决办法","date":"2016-03-05T08:24:40.000Z","_content":"\n>RESideMenu一个非常好用的左右侧滑菜单控件，很多IOS项目都会用到此类左右侧滑效果。然而在RESideMenu的使用过程中，发现其默认将所有界面都加入了侧滑效果。如在主界面导航的Menu放在屏幕的左右两侧，侧滑才可以显示出来，但是当我们进入主界面的某个次级View中，甚至更深一层的View中，侧滑功能仍然可用。这一点就用IOS的UINavigationController的滑动返回冲突。为了解决这个问题，通过Google在网上搜索找到了如下的解决方法。\n\n<!-- more -->\n\n奉上参考原文链接地址：http://blog.csdn.net/icetime17/article/details/46883915\n\n## RESideMenu基本用法\n\n首先创建window的rootViewController，在RootViewController引入并继承RESideMenu及其RESideMenuDelegate. \n\n具体相关代码如下：\n\n``` objc\n#import \"RESideMenu.h\"\n@interface RootViewController : RESideMenu <RESideMenuDelegate>\n@end\n```\n\n然后在RootViewController.m文件中设置好RESideMenu\n\n``` objc\n#import \"RootViewController.h\"\n@interface RootViewController ()\n@end\n\n@implementation RootViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n}\n\n- (void)didReceiveMemoryWarning {\n  [super didReceiveMemoryWarning];\n}\n\n- (void)awakeFromNib {\n  self.menuPreferredStatusBarStyle = UIStatusBarStyleLightContent;\n  self.contentViewShadowColor = [UIColor blackColor];\n  self.contentViewShadowOffset = CGSizeMake(0, 0);\n  self.contentViewShadowOpacity = 0.6;\n  self.contentViewShadowRadius = 12;\n  self.contentViewShadowEnabled = NO;\n\n  self.contentViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"ContentViewController\"];\n  self.leftMenuViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"LeftMenuViewController\"];\n\n  self.delegate = self;\n}\n\n#pragma mark - RESideMenu Delegate\n\n- (void)sideMenu:(RESideMenu *)sideMenu willShowMenuViewController:(UIViewController *)menuViewController {\n}\n\n- (void)sideMenu:(RESideMenu *)sideMenu didShowMenuViewController:(UIViewController *)menuViewController {\n}\n\n- (void)sideMenu:(RESideMenu *)sideMenu willHideMenuViewController:(UIViewController *)menuViewController {\n}\n\n- (void)sideMenu:(RESideMenu *)sideMenu didHideMenuViewController:(UIViewController *)menuViewController {\n}\n@end\n```\n\n## 遇到问题\n\n在RESideMenu的使用过程中，发现所有的界面都加上了侧滑功能，并且iOS的滑动返回功能失效了。\n\n## 解决办法\n\n通过观察RESideMenu的源码发现，RESideMenu类中有一个BOOL属性panGestureEnabled, 可以将其视为侧滑效果的开关。以RESideMenu的panGestureEnabled属性为突破口，采用通知的方式来解决这个问题。\n在RootViewController.m文件中加入如下代码：\n``` objc\n- (void)viewDidLoad {\n  [super viewDidLoad];\n\n  [[NSNotificationCenter defaultCenter] addObserver:self\n                                           selector:@selector(disableRESideMenu)\n                                               name:@\"disableRESideMenu\"\n                                             object:nil];\n  [[NSNotificationCenter defaultCenter] addObserver:self\n                                           selector:@selector(enableRESideMenu) \n                                               name:@\"enableRESideMenu\"\n                                             object:nil];\n}\n\n- (void)enableRESideMenu {\n  self.panGestureEnabled = YES;\n}\n\n- (void)disableRESideMenu {\n  self.panGestureEnabled = NO;\n}\n```\n在其他页面需要禁止侧滑的时候调用如下代码,发送通知\n``` objc\n// 关闭侧滑效果\n[[NSNotificationCenter defaultCenter] postNotificationName:@\"disableRESideMenu\"\n                                                            object:self\n                                                          userInfo:nil];\n```\n相反在需要侧滑的地方调用\n``` objc\n// 开启侧滑效果\n[[NSNotificationCenter defaultCenter] postNotificationName:@\"enableRESideMenu\"\n                                                    object:self\n                                                  userInfo:nil];\n```","source":"_posts/RESideMenu在所有界面都会侧滑的问题解决办法.md","raw":"---\ntitle: RESideMenu在所有界面都会侧滑的问题解决办法\ndate: 2016-03-05 16:24:40\ntags:\n---\n\n>RESideMenu一个非常好用的左右侧滑菜单控件，很多IOS项目都会用到此类左右侧滑效果。然而在RESideMenu的使用过程中，发现其默认将所有界面都加入了侧滑效果。如在主界面导航的Menu放在屏幕的左右两侧，侧滑才可以显示出来，但是当我们进入主界面的某个次级View中，甚至更深一层的View中，侧滑功能仍然可用。这一点就用IOS的UINavigationController的滑动返回冲突。为了解决这个问题，通过Google在网上搜索找到了如下的解决方法。\n\n<!-- more -->\n\n奉上参考原文链接地址：http://blog.csdn.net/icetime17/article/details/46883915\n\n## RESideMenu基本用法\n\n首先创建window的rootViewController，在RootViewController引入并继承RESideMenu及其RESideMenuDelegate. \n\n具体相关代码如下：\n\n``` objc\n#import \"RESideMenu.h\"\n@interface RootViewController : RESideMenu <RESideMenuDelegate>\n@end\n```\n\n然后在RootViewController.m文件中设置好RESideMenu\n\n``` objc\n#import \"RootViewController.h\"\n@interface RootViewController ()\n@end\n\n@implementation RootViewController\n\n- (void)viewDidLoad {\n  [super viewDidLoad];\n}\n\n- (void)didReceiveMemoryWarning {\n  [super didReceiveMemoryWarning];\n}\n\n- (void)awakeFromNib {\n  self.menuPreferredStatusBarStyle = UIStatusBarStyleLightContent;\n  self.contentViewShadowColor = [UIColor blackColor];\n  self.contentViewShadowOffset = CGSizeMake(0, 0);\n  self.contentViewShadowOpacity = 0.6;\n  self.contentViewShadowRadius = 12;\n  self.contentViewShadowEnabled = NO;\n\n  self.contentViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"ContentViewController\"];\n  self.leftMenuViewController = [self.storyboard instantiateViewControllerWithIdentifier:@\"LeftMenuViewController\"];\n\n  self.delegate = self;\n}\n\n#pragma mark - RESideMenu Delegate\n\n- (void)sideMenu:(RESideMenu *)sideMenu willShowMenuViewController:(UIViewController *)menuViewController {\n}\n\n- (void)sideMenu:(RESideMenu *)sideMenu didShowMenuViewController:(UIViewController *)menuViewController {\n}\n\n- (void)sideMenu:(RESideMenu *)sideMenu willHideMenuViewController:(UIViewController *)menuViewController {\n}\n\n- (void)sideMenu:(RESideMenu *)sideMenu didHideMenuViewController:(UIViewController *)menuViewController {\n}\n@end\n```\n\n## 遇到问题\n\n在RESideMenu的使用过程中，发现所有的界面都加上了侧滑功能，并且iOS的滑动返回功能失效了。\n\n## 解决办法\n\n通过观察RESideMenu的源码发现，RESideMenu类中有一个BOOL属性panGestureEnabled, 可以将其视为侧滑效果的开关。以RESideMenu的panGestureEnabled属性为突破口，采用通知的方式来解决这个问题。\n在RootViewController.m文件中加入如下代码：\n``` objc\n- (void)viewDidLoad {\n  [super viewDidLoad];\n\n  [[NSNotificationCenter defaultCenter] addObserver:self\n                                           selector:@selector(disableRESideMenu)\n                                               name:@\"disableRESideMenu\"\n                                             object:nil];\n  [[NSNotificationCenter defaultCenter] addObserver:self\n                                           selector:@selector(enableRESideMenu) \n                                               name:@\"enableRESideMenu\"\n                                             object:nil];\n}\n\n- (void)enableRESideMenu {\n  self.panGestureEnabled = YES;\n}\n\n- (void)disableRESideMenu {\n  self.panGestureEnabled = NO;\n}\n```\n在其他页面需要禁止侧滑的时候调用如下代码,发送通知\n``` objc\n// 关闭侧滑效果\n[[NSNotificationCenter defaultCenter] postNotificationName:@\"disableRESideMenu\"\n                                                            object:self\n                                                          userInfo:nil];\n```\n相反在需要侧滑的地方调用\n``` objc\n// 开启侧滑效果\n[[NSNotificationCenter defaultCenter] postNotificationName:@\"enableRESideMenu\"\n                                                    object:self\n                                                  userInfo:nil];\n```","slug":"RESideMenu在所有界面都会侧滑的问题解决办法","published":1,"updated":"2016-06-02T04:10:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcjo001r29we3ergtgl3"},{"title":"objc过滤NSString中的HTML标签","date":"2016-05-04T03:17:29.000Z","_content":"\n开发过程中常常会遇到这样一个情况：对于后台编辑的一些文本都是使用富文本的形式进行编辑的，我们在使用接口区请求数据的时候，请求到的数据是带HTML标签的富文本形式，但是我们前台是使用UIlabel去显示的，这个时候就需要去掉NSString的HTML标签。\n\n## 解决办法\n\n对于这种常用的一些方法，我们一般会创建一个NSString的Category去实现。关于去掉NSString中HTML标签的实现方法我在网上找到了两种实现方式：\n\n### 方法一\n用NSScanner扫描来处理\n\n<!-- more -->\n\nNSString+Jvaeyhcd.h\n``` objc\n#import <Foundation/Foundation.h>\n\n@interface NSString (Jvaeyhcd)\n\n- (NSString *)removeHTML;\n\n@end\n```\n\nNSString+Jvaeyhcd.m\n``` objc\n- (NSString *)removeHTML {\n    \n    NSScanner *theScanner;\n    NSString *text = nil;\n    \n    theScanner = [NSScanner scannerWithString:self];\n\n    while ([theScanner isAtEnd] == NO) {\n        // find start of tag\n        [theScanner scanUpToString:@\"<\" intoString:NULL] ;\n        // find end of tag\n        [theScanner scanUpToString:@\">\" intoString:&text] ;\n        \n        // replace the found tag with a space\n        \n        //(you can filter multi-spaces out later if you wish)\n        \n        self = [self stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@\"%@>\", text] withString:@\" \"];\n    }\n    \n    return self;\n}\n\n```\n\n### 方法二\n用NSString自带的Seprated自截断方法\n\nNSString+Jvaeyhcd.h\n``` objc\n#import <Foundation/Foundation.h>\n\n@interface NSString (Jvaeyhcd)\n\n- (NSString *)removeHTML2;\n\n@end\n```\n\nNSString+Jvaeyhcd.m\n``` objc\n- (NSString *)removeHTML2 {\n    NSArray *components = [self componentsSeparatedByCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@\"<>\"]];\n    NSMutableArray *componentsToKeep = [NSMutableArray array];\n    \n    for (int i = 0; i < [components count]; i = i + 2) {\n        [componentsToKeep addObject:[components objectAtIndex:i]];\n    }\n    \n    NSString *plainText = [componentsToKeep componentsJoinedByString:@\"\"];\n    \n    return plainText;\n}\n```","source":"_posts/Objective-C过滤NSString中的HTML标签.md","raw":"---\ntitle: objc过滤NSString中的HTML标签\ndate: 2016-05-04 11:17:29\ntags:\n  - objc\n---\n\n开发过程中常常会遇到这样一个情况：对于后台编辑的一些文本都是使用富文本的形式进行编辑的，我们在使用接口区请求数据的时候，请求到的数据是带HTML标签的富文本形式，但是我们前台是使用UIlabel去显示的，这个时候就需要去掉NSString的HTML标签。\n\n## 解决办法\n\n对于这种常用的一些方法，我们一般会创建一个NSString的Category去实现。关于去掉NSString中HTML标签的实现方法我在网上找到了两种实现方式：\n\n### 方法一\n用NSScanner扫描来处理\n\n<!-- more -->\n\nNSString+Jvaeyhcd.h\n``` objc\n#import <Foundation/Foundation.h>\n\n@interface NSString (Jvaeyhcd)\n\n- (NSString *)removeHTML;\n\n@end\n```\n\nNSString+Jvaeyhcd.m\n``` objc\n- (NSString *)removeHTML {\n    \n    NSScanner *theScanner;\n    NSString *text = nil;\n    \n    theScanner = [NSScanner scannerWithString:self];\n\n    while ([theScanner isAtEnd] == NO) {\n        // find start of tag\n        [theScanner scanUpToString:@\"<\" intoString:NULL] ;\n        // find end of tag\n        [theScanner scanUpToString:@\">\" intoString:&text] ;\n        \n        // replace the found tag with a space\n        \n        //(you can filter multi-spaces out later if you wish)\n        \n        self = [self stringByReplacingOccurrencesOfString:[NSString stringWithFormat:@\"%@>\", text] withString:@\" \"];\n    }\n    \n    return self;\n}\n\n```\n\n### 方法二\n用NSString自带的Seprated自截断方法\n\nNSString+Jvaeyhcd.h\n``` objc\n#import <Foundation/Foundation.h>\n\n@interface NSString (Jvaeyhcd)\n\n- (NSString *)removeHTML2;\n\n@end\n```\n\nNSString+Jvaeyhcd.m\n``` objc\n- (NSString *)removeHTML2 {\n    NSArray *components = [self componentsSeparatedByCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@\"<>\"]];\n    NSMutableArray *componentsToKeep = [NSMutableArray array];\n    \n    for (int i = 0; i < [components count]; i = i + 2) {\n        [componentsToKeep addObject:[components objectAtIndex:i]];\n    }\n    \n    NSString *plainText = [componentsToKeep componentsJoinedByString:@\"\"];\n    \n    return plainText;\n}\n```","slug":"Objective-C过滤NSString中的HTML标签","published":1,"updated":"2016-06-02T03:57:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcjq001s29werqj0nlq5"},{"title":"Objective-C身份证验证实现","date":"2016-06-15T04:04:58.000Z","_content":"\n最近在一个二次开发的项目中看到了一段身份证验证的OC代码，虽然我一直讨厌二次开发。因为这这个二次开发的项目太老，代码太乱，毫无层次感。可是令人欣慰的是，我在里面发现了一段有用的代码。\n\n直接上代码\n\n<!-- more -->\n\n``` objc\n- (BOOL)isValidIdCardNum\n{\n    NSString *value = [self copy];\n    value = [value stringByReplacingOccurrencesOfString:@\"X\" withString:@\"x\"];\n    value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];\n    int length = 0;\n    if (!value) {\n        return NO;\n    }else {\n        length = (int)value.length;\n        if (length != 15 && length !=18) {\n            return NO;\n        }\n    }\n    // 省份代码\n    NSArray *areasArray =@[@\"11\", @\"12\", @\"13\", @\"14\", @\"15\", @\"21\", @\"22\", @\"23\", @\"31\", @\"32\", @\"33\", @\"34\", @\"35\", @\"36\", @\"37\", @\"41\", @\"42\", @\"43\", @\"44\", @\"45\", @\"46\", @\"50\", @\"51\", @\"52\", @\"53\", @\"54\", @\"61\", @\"62\", @\"63\", @\"64\", @\"65\", @\"71\", @\"81\", @\"82\", @\"91\"];\n    NSString *valueStart2 = [value substringToIndex:2];\n    BOOL areaFlag = NO;\n    for (NSString *areaCode in areasArray) {\n        if ([areaCode isEqualToString:valueStart2]) {\n            areaFlag = YES;\n            break;\n        }\n    }\n    if (!areaFlag) {\n        return NO;\n    }\n    NSRegularExpression *regularExpression;\n    NSUInteger numberofMatch;\n    int year = 0;\n    switch (length) {\n        case 15:\n            year = [value substringWithRange:NSMakeRange(6,2)].intValue +1900;\n            if (year % 4 ==0 || (year % 100 ==0 && year % 4 ==0)) {\n                regularExpression = [[NSRegularExpression alloc] initWithPattern:@\"^[1-9][0-9]{5}[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]{3}$\"                   options:NSRegularExpressionCaseInsensitive error:nil];// 测试出生日期的合法性\n            }else {\n                regularExpression = [[NSRegularExpression alloc] initWithPattern:@\"^[1-9][0-9]{5}[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]{3}$\"           options:NSRegularExpressionCaseInsensitive error:nil];// 测试出生日期的合法性\n            }\n            numberofMatch = [regularExpression numberOfMatchesInString:value options:NSMatchingReportProgress range:NSMakeRange(0, value.length)];\n            if(numberofMatch > 0) {\n                return YES;\n            }else {\n                return NO;\n            }\n        case 18:\n            year = [value substringWithRange:NSMakeRange(6,4)].intValue;\n            if (year % 4 ==0 || (year % 100 ==0 && year % 4 ==0)) {\n                regularExpression = [[NSRegularExpression alloc] initWithPattern:@\"^[1-9][0-9]{5}19|20[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]{3}[0-9Xx]$\"options:NSRegularExpressionCaseInsensitive error:nil];// 测试出生日期的合法性\n                \n            }else {\n                regularExpression = [[NSRegularExpression alloc] initWithPattern:@\"^[1-9][0-9]{5}19|20[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]{3}[0-9Xx]$\"\n                                                                         options:NSRegularExpressionCaseInsensitive error:nil];// 测试出生日期的合法性\n            }\n            numberofMatch = [regularExpression numberOfMatchesInString:value options:NSMatchingReportProgress range:NSMakeRange(0, value.length)];\n            if(numberofMatch > 0) {\n                int S = ([value substringWithRange:NSMakeRange(0,1)].intValue + [value substringWithRange:NSMakeRange(10,1)].intValue) *7 + ([value substringWithRange:NSMakeRange(1,1)].intValue + [value substringWithRange:NSMakeRange(11,1)].intValue) *9 + ([value substringWithRange:NSMakeRange(2,1)].intValue + [value substringWithRange:NSMakeRange(12,1)].intValue) *10 + ([value substringWithRange:NSMakeRange(3,1)].intValue + [value substringWithRange:NSMakeRange(13,1)].intValue) *5 + ([value substringWithRange:NSMakeRange(4,1)].intValue + [value substringWithRange:NSMakeRange(14,1)].intValue) *8 + ([value substringWithRange:NSMakeRange(5,1)].intValue + [value substringWithRange:NSMakeRange(15,1)].intValue) *4 + ([value substringWithRange:NSMakeRange(6,1)].intValue + [value substringWithRange:NSMakeRange(16,1)].intValue) *2 + [value substringWithRange:NSMakeRange(7,1)].intValue *1 + [value substringWithRange:NSMakeRange(8,1)].intValue *6 + [value substringWithRange:NSMakeRange(9,1)].intValue *3;\n                int Y = S % 11;\n                NSString *M = @\"F\";\n                NSString *JYM = @\"10X98765432\";\n                M = [JYM substringWithRange:NSMakeRange(Y,1)]; // 判断校验位\n                if ([M isEqualToString:[[value substringWithRange:NSMakeRange(17,1)] uppercaseString]]) {\n                    return YES;// 检测ID的校验位\n                }else {\n                    return NO;\n                }\n            }else {\n                return NO;\n            }\n            \n        default:\n            return NO;\n    }\n    return NO;\n}\n```\n\n上面的代码验证十分全面。","source":"_posts/Objective-C身份证验证实现.md","raw":"---\ntitle: Objective-C身份证验证实现\ndate: 2016-06-15 12:04:58\ntags:\n---\n\n最近在一个二次开发的项目中看到了一段身份证验证的OC代码，虽然我一直讨厌二次开发。因为这这个二次开发的项目太老，代码太乱，毫无层次感。可是令人欣慰的是，我在里面发现了一段有用的代码。\n\n直接上代码\n\n<!-- more -->\n\n``` objc\n- (BOOL)isValidIdCardNum\n{\n    NSString *value = [self copy];\n    value = [value stringByReplacingOccurrencesOfString:@\"X\" withString:@\"x\"];\n    value = [value stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];\n    int length = 0;\n    if (!value) {\n        return NO;\n    }else {\n        length = (int)value.length;\n        if (length != 15 && length !=18) {\n            return NO;\n        }\n    }\n    // 省份代码\n    NSArray *areasArray =@[@\"11\", @\"12\", @\"13\", @\"14\", @\"15\", @\"21\", @\"22\", @\"23\", @\"31\", @\"32\", @\"33\", @\"34\", @\"35\", @\"36\", @\"37\", @\"41\", @\"42\", @\"43\", @\"44\", @\"45\", @\"46\", @\"50\", @\"51\", @\"52\", @\"53\", @\"54\", @\"61\", @\"62\", @\"63\", @\"64\", @\"65\", @\"71\", @\"81\", @\"82\", @\"91\"];\n    NSString *valueStart2 = [value substringToIndex:2];\n    BOOL areaFlag = NO;\n    for (NSString *areaCode in areasArray) {\n        if ([areaCode isEqualToString:valueStart2]) {\n            areaFlag = YES;\n            break;\n        }\n    }\n    if (!areaFlag) {\n        return NO;\n    }\n    NSRegularExpression *regularExpression;\n    NSUInteger numberofMatch;\n    int year = 0;\n    switch (length) {\n        case 15:\n            year = [value substringWithRange:NSMakeRange(6,2)].intValue +1900;\n            if (year % 4 ==0 || (year % 100 ==0 && year % 4 ==0)) {\n                regularExpression = [[NSRegularExpression alloc] initWithPattern:@\"^[1-9][0-9]{5}[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]{3}$\"                   options:NSRegularExpressionCaseInsensitive error:nil];// 测试出生日期的合法性\n            }else {\n                regularExpression = [[NSRegularExpression alloc] initWithPattern:@\"^[1-9][0-9]{5}[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]{3}$\"           options:NSRegularExpressionCaseInsensitive error:nil];// 测试出生日期的合法性\n            }\n            numberofMatch = [regularExpression numberOfMatchesInString:value options:NSMatchingReportProgress range:NSMakeRange(0, value.length)];\n            if(numberofMatch > 0) {\n                return YES;\n            }else {\n                return NO;\n            }\n        case 18:\n            year = [value substringWithRange:NSMakeRange(6,4)].intValue;\n            if (year % 4 ==0 || (year % 100 ==0 && year % 4 ==0)) {\n                regularExpression = [[NSRegularExpression alloc] initWithPattern:@\"^[1-9][0-9]{5}19|20[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]{3}[0-9Xx]$\"options:NSRegularExpressionCaseInsensitive error:nil];// 测试出生日期的合法性\n                \n            }else {\n                regularExpression = [[NSRegularExpression alloc] initWithPattern:@\"^[1-9][0-9]{5}19|20[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]{3}[0-9Xx]$\"\n                                                                         options:NSRegularExpressionCaseInsensitive error:nil];// 测试出生日期的合法性\n            }\n            numberofMatch = [regularExpression numberOfMatchesInString:value options:NSMatchingReportProgress range:NSMakeRange(0, value.length)];\n            if(numberofMatch > 0) {\n                int S = ([value substringWithRange:NSMakeRange(0,1)].intValue + [value substringWithRange:NSMakeRange(10,1)].intValue) *7 + ([value substringWithRange:NSMakeRange(1,1)].intValue + [value substringWithRange:NSMakeRange(11,1)].intValue) *9 + ([value substringWithRange:NSMakeRange(2,1)].intValue + [value substringWithRange:NSMakeRange(12,1)].intValue) *10 + ([value substringWithRange:NSMakeRange(3,1)].intValue + [value substringWithRange:NSMakeRange(13,1)].intValue) *5 + ([value substringWithRange:NSMakeRange(4,1)].intValue + [value substringWithRange:NSMakeRange(14,1)].intValue) *8 + ([value substringWithRange:NSMakeRange(5,1)].intValue + [value substringWithRange:NSMakeRange(15,1)].intValue) *4 + ([value substringWithRange:NSMakeRange(6,1)].intValue + [value substringWithRange:NSMakeRange(16,1)].intValue) *2 + [value substringWithRange:NSMakeRange(7,1)].intValue *1 + [value substringWithRange:NSMakeRange(8,1)].intValue *6 + [value substringWithRange:NSMakeRange(9,1)].intValue *3;\n                int Y = S % 11;\n                NSString *M = @\"F\";\n                NSString *JYM = @\"10X98765432\";\n                M = [JYM substringWithRange:NSMakeRange(Y,1)]; // 判断校验位\n                if ([M isEqualToString:[[value substringWithRange:NSMakeRange(17,1)] uppercaseString]]) {\n                    return YES;// 检测ID的校验位\n                }else {\n                    return NO;\n                }\n            }else {\n                return NO;\n            }\n            \n        default:\n            return NO;\n    }\n    return NO;\n}\n```\n\n上面的代码验证十分全面。","slug":"Objective-C身份证验证实现","published":1,"updated":"2016-06-15T04:59:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcjt001v29wehhkqty9m"},{"title":"Objc常用关键字的使用与区别","date":"2016-03-23T02:17:12.000Z","_content":"\n虽然接触iOS已经很久了，但是对于objc中常见的关键字还经常处于傻傻分不清楚的状态。遇到最多的情况就是在申明一个属性的时候，比如：\n``` objc\n@propperty (?,?) ?*!;\n...............\n............\n.........\n......\n```\n就是这里，每次在这里的时候都不知道，怎么去申明他的关键字。这个看起来简单（弄明白了确实也是很简单的），但是如果没有系统的去区分这些关键字很容易混淆。\n所以今天通过自己的一些积累以及在网上总结的一些资料，给自己总结一下，主要作为自己对iOS学习的一个小小的总结。\n\nOC中常见的关键字有copy,assign,strong,retain,weak,readonly,nonatomic,atomic。\n这篇文章主要从这几个关键字的含义和简单的使用以及iOS开发中使用的时候的一些区别来进行总结。（看似简单但却非常重要）\n\n<!-- more -->\n\n## 含义\n* **copy** 创建一个索引计数为1的对象,释放掉原来的对象。复制内容（深复制），如果调用copy的是数组，则为指针复制（浅复制），仅仅复制子元素的指针。copy常常用来修饰NSString，NSMutableArray和Block。\n``` objc\n@property  (nonatomic,copy) NSString  *title;\n@property (nonatomic, copy) NSMutableArray *myArray;\n@property (nonatomic, copy) void(^myBlock)();\n```\n* **assign** 简单的赋值，不会更改索引计数，主要是对基本数据类型使用。eg：（NSInteger，CGFloat和C语言的int,float, double,char等）\n``` objc\n@property (nonatomic, assign) int n;\n@property (nonatomic, assign) BOOL isOK;\n@property (nonatomic, assign) CGFloat width;\n@property (nonatomic, assign) CGPoint height;\n```\n* **retain**\n释放旧的对象，将旧对象的值赋予输入对象并将输入对象的索引计数＋1，主要应用与NSObject与其子类中。 retain是指针复制（浅复制），引用计数加1，而不会导致内容被复制。\n``` objc\n@property  (nonatomic, retain) UIColor *myColor;\n\n- (void)setName:(NSString *)newName {\n    [newName retain];\n    [name release];  \n    name = newName;  \n}\n\n```\n\n* **strong**\n相当于retain，strong在ARC环境下为默认属性类型。\n``` objc\n@property (nonatomic,readwrite,strong) NSString *title;\n@property (strong, nonatomic) UIViewController *viewController;\n@property (nonatomic,  strong) id childObject;\n```\n\n* **weak**\n取代之前的assign，对象销毁之后会自动置为nil，防止野指针。\nassign不能自动置为nil，需要手动置为nil。\ndelegate基本总是使用weak，以防止循环引用。特殊情况是，如果希望在dealloc中调用delegate的某些方法进行释放，此时如果使用weak将引起异常，因为此时已经是nil了，那么采用assign更为合适。\n``` objc\n@property  (weak, nonatomic) IBOutlet UIButton *myButton;//处于最顶层的IBOutlet应该为strong\n@property (nonatomic, weak) id parentObject;\n@property(nonatomic, readwrite, weak) id  <MyDelegate> delegate;\n@property (nonatomic, weak) NSObject <SomeDelegate> *delegate;\n```\n\n* **readonly**\n此标记说明属性是只读的，默认的标记是读写，如果你指定了只读，在@implementation中只需要一个读取器。或者如果你使用@synthesize关键字，也是有读取器方法被解析。而且如果你试图使用点操作符为属性赋值，你将得到一个编译错误。\n\n* **readwrite**\n此标记说明属性会被当成读写的，这也是默认属性。设置器和读取器都需要在@implementation中实现。如果使用@synthesize关键字，读取器和设置器都会被解析。\n\n## 使用区别\n* **copy和retain**\n1. copy其实是建立了一个相同的对象，而retain不是；\n2. copy是内容拷贝，retain是指针拷贝；\n3. copy是内容的拷贝 ,对于像NSString的确是这样，但是如果copy的是一个NSArray呢?这时只是copy了指向array中相对应元素的指针.这便是所谓的\"浅复制\".\n4. copy的情况：NSString *newPt = [pt copy];\n此时会在堆上重新开辟一段内存存放@\"abc\" 比如0X1122 内容为@\"abc 同时会在栈上为newPt分配空间 比如地址：0Xaacc 内容为0X1122 因此retainCount增加1供newPt来管理0X1122这段内存；\n* **assign与retain**\n1. assign: 简单赋值，不更改索引计数；\n2. assign的情况：NSString *newPt = [pt assing];\n此时newPt和pt完全相同 地址都是0Xaaaa 内容为0X1111 即newPt只是pt的别名，对任何一个操作就等于对另一个操作， 因此retainCount不需要增加；\n3. assign就是直接赋值；\n4. retain使用了引用计数，retain引起引用计数加1, release引起引用计数减1，当引用计数为0时，dealloc函数被调用，内存被回收；\n5. retain的情况：NSString *newPt = [pt retain];\n此时newPt的地址不再为0Xaaaa，可能为0Xaabb 但是内容依然为0X1111。 因此newPt 和 pt 都可以管理\"abc\"所在的内存，因此 retainCount需要增加1；\n* **readonly与readwrite**\n1. readonly：只产生简单的getter,没有setter。\n2. readwrite：同时产生setter\\getter方法\n* **nonatomic与atomic**\n1. nonatomic非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能。如果不加此属性，则默认是两个访问方法都为原子型事务访问；\n2. 成员变量的@property属性时，默认为atomic，提供多线程安全。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果\nweak and strong property (强引用和弱引用的区别)\n3. 比如setter函数里面改变两个成员变量，如果你用nonatomic的话，getter可能会取到只更改了其中一个变量时候的状态，这样取到的东西会有问题，就是不完整的。当然如果不需要多线程支持的话，用nonatomic就够了，因为不涉及到线程锁的操作，所以它执行率相对快些。\n4. atomic的意思就是setter/getter这个函数，是一个原语操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行完setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样，可以保证数据的完整性。nonatomic不保证setter/getter的原语行，所以你可能会取到不完整的东西。因此，在多线程的环境下原子操作是非常必要的，否则有可能会引起错误的结果。\n\n* **weak与strong**\n1. weak 和 strong 属性只有在你打开ARC时才会被要求使用，这时你是不能使用retain release autorelease 操作的，因为ARC会自动为你做好这些操作，但是你需要在对象属性上使用weak 和strong,其中strong就相当于retain属性，而weak相当于assign。\n2. 只有一种情况你需要使用weak（默认是strong），就是为了避免retain cycles（就是父类中含有子类{父类retain了子类}，子类中又调用了父类{子类又retain了父类}，这样都无法release）\n3. 声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为nil。这样的好处能有效的防止野指针。","source":"_posts/Objective-C常用关键字的使用与区别.md","raw":"---\ntitle: objc常用关键字的使用与区别\ndate: 2016-03-23 10:17:12\ntags:\n  - objc\n---\n\n虽然接触iOS已经很久了，但是对于objc中常见的关键字还经常处于傻傻分不清楚的状态。遇到最多的情况就是在申明一个属性的时候，比如：\n``` objc\n@propperty (?,?) ?*!;\n...............\n............\n.........\n......\n```\n就是这里，每次在这里的时候都不知道，怎么去申明他的关键字。这个看起来简单（弄明白了确实也是很简单的），但是如果没有系统的去区分这些关键字很容易混淆。\n所以今天通过自己的一些积累以及在网上总结的一些资料，给自己总结一下，主要作为自己对iOS学习的一个小小的总结。\n\nOC中常见的关键字有copy,assign,strong,retain,weak,readonly,nonatomic,atomic。\n这篇文章主要从这几个关键字的含义和简单的使用以及iOS开发中使用的时候的一些区别来进行总结。（看似简单但却非常重要）\n\n<!-- more -->\n\n## 含义\n* **copy** 创建一个索引计数为1的对象,释放掉原来的对象。复制内容（深复制），如果调用copy的是数组，则为指针复制（浅复制），仅仅复制子元素的指针。copy常常用来修饰NSString，NSMutableArray和Block。\n``` objc\n@property  (nonatomic,copy) NSString  *title;\n@property (nonatomic, copy) NSMutableArray *myArray;\n@property (nonatomic, copy) void(^myBlock)();\n```\n* **assign** 简单的赋值，不会更改索引计数，主要是对基本数据类型使用。eg：（NSInteger，CGFloat和C语言的int,float, double,char等）\n``` objc\n@property (nonatomic, assign) int n;\n@property (nonatomic, assign) BOOL isOK;\n@property (nonatomic, assign) CGFloat width;\n@property (nonatomic, assign) CGPoint height;\n```\n* **retain**\n释放旧的对象，将旧对象的值赋予输入对象并将输入对象的索引计数＋1，主要应用与NSObject与其子类中。 retain是指针复制（浅复制），引用计数加1，而不会导致内容被复制。\n``` objc\n@property  (nonatomic, retain) UIColor *myColor;\n\n- (void)setName:(NSString *)newName {\n    [newName retain];\n    [name release];  \n    name = newName;  \n}\n\n```\n\n* **strong**\n相当于retain，strong在ARC环境下为默认属性类型。\n``` objc\n@property (nonatomic,readwrite,strong) NSString *title;\n@property (strong, nonatomic) UIViewController *viewController;\n@property (nonatomic,  strong) id childObject;\n```\n\n* **weak**\n取代之前的assign，对象销毁之后会自动置为nil，防止野指针。\nassign不能自动置为nil，需要手动置为nil。\ndelegate基本总是使用weak，以防止循环引用。特殊情况是，如果希望在dealloc中调用delegate的某些方法进行释放，此时如果使用weak将引起异常，因为此时已经是nil了，那么采用assign更为合适。\n``` objc\n@property  (weak, nonatomic) IBOutlet UIButton *myButton;//处于最顶层的IBOutlet应该为strong\n@property (nonatomic, weak) id parentObject;\n@property(nonatomic, readwrite, weak) id  <MyDelegate> delegate;\n@property (nonatomic, weak) NSObject <SomeDelegate> *delegate;\n```\n\n* **readonly**\n此标记说明属性是只读的，默认的标记是读写，如果你指定了只读，在@implementation中只需要一个读取器。或者如果你使用@synthesize关键字，也是有读取器方法被解析。而且如果你试图使用点操作符为属性赋值，你将得到一个编译错误。\n\n* **readwrite**\n此标记说明属性会被当成读写的，这也是默认属性。设置器和读取器都需要在@implementation中实现。如果使用@synthesize关键字，读取器和设置器都会被解析。\n\n## 使用区别\n* **copy和retain**\n1. copy其实是建立了一个相同的对象，而retain不是；\n2. copy是内容拷贝，retain是指针拷贝；\n3. copy是内容的拷贝 ,对于像NSString的确是这样，但是如果copy的是一个NSArray呢?这时只是copy了指向array中相对应元素的指针.这便是所谓的\"浅复制\".\n4. copy的情况：NSString *newPt = [pt copy];\n此时会在堆上重新开辟一段内存存放@\"abc\" 比如0X1122 内容为@\"abc 同时会在栈上为newPt分配空间 比如地址：0Xaacc 内容为0X1122 因此retainCount增加1供newPt来管理0X1122这段内存；\n* **assign与retain**\n1. assign: 简单赋值，不更改索引计数；\n2. assign的情况：NSString *newPt = [pt assing];\n此时newPt和pt完全相同 地址都是0Xaaaa 内容为0X1111 即newPt只是pt的别名，对任何一个操作就等于对另一个操作， 因此retainCount不需要增加；\n3. assign就是直接赋值；\n4. retain使用了引用计数，retain引起引用计数加1, release引起引用计数减1，当引用计数为0时，dealloc函数被调用，内存被回收；\n5. retain的情况：NSString *newPt = [pt retain];\n此时newPt的地址不再为0Xaaaa，可能为0Xaabb 但是内容依然为0X1111。 因此newPt 和 pt 都可以管理\"abc\"所在的内存，因此 retainCount需要增加1；\n* **readonly与readwrite**\n1. readonly：只产生简单的getter,没有setter。\n2. readwrite：同时产生setter\\getter方法\n* **nonatomic与atomic**\n1. nonatomic非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能。如果不加此属性，则默认是两个访问方法都为原子型事务访问；\n2. 成员变量的@property属性时，默认为atomic，提供多线程安全。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果\nweak and strong property (强引用和弱引用的区别)\n3. 比如setter函数里面改变两个成员变量，如果你用nonatomic的话，getter可能会取到只更改了其中一个变量时候的状态，这样取到的东西会有问题，就是不完整的。当然如果不需要多线程支持的话，用nonatomic就够了，因为不涉及到线程锁的操作，所以它执行率相对快些。\n4. atomic的意思就是setter/getter这个函数，是一个原语操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行完setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样，可以保证数据的完整性。nonatomic不保证setter/getter的原语行，所以你可能会取到不完整的东西。因此，在多线程的环境下原子操作是非常必要的，否则有可能会引起错误的结果。\n\n* **weak与strong**\n1. weak 和 strong 属性只有在你打开ARC时才会被要求使用，这时你是不能使用retain release autorelease 操作的，因为ARC会自动为你做好这些操作，但是你需要在对象属性上使用weak 和strong,其中strong就相当于retain属性，而weak相当于assign。\n2. 只有一种情况你需要使用weak（默认是strong），就是为了避免retain cycles（就是父类中含有子类{父类retain了子类}，子类中又调用了父类{子类又retain了父类}，这样都无法release）\n3. 声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为nil。这样的好处能有效的防止野指针。","slug":"Objective-C常用关键字的使用与区别","published":1,"updated":"2016-06-02T04:07:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcjv001w29wetxxl900o"},{"title":"NSURLErrorDomain Code=-1002 “Unsupported URL”","date":"2016-06-30T07:13:42.000Z","_content":"\n在进行iOS网络请求的时候，报Error Domain=NSURLErrorDomain Code=-1002 “unsupported URL”的错误，请求的类型是GET，但是使用PSOTMAN和在浏览器中打开此接口可以返回正确的数据。通过google搜索最后找到了解决办法，今天记录下这个奇怪的问题。\n\n## 问题概述\n我在一个接手的二次开发的项目中，发现了这样一个问题，有的接口可以用正常访问，但是却有一个接口就不能正常访问。我对比了这个不能访问的接口和其它能够正常访问的接口的区别发现，当我传入的参数有值为中文字符串时就会报如下的错误，所以显然问题就出在传入参数为中文字符串的问题上。\n\n<!-- more -->\n\n## 问题分析\n通过对比发现（分析问题常见的方法），当这个接口传入了中文后将会报错，如果不传中文接口并不会报错，所以我基本上就可以锁定问题就出在中文字符的问题上。\n\n## 解决方法\n找到了问题出现的原因后其它的一切都变得简单了，因为传入中文字符会出现服务器不能解析然后报错的情况，所以我们应该将传入的中文字符用UTF8编码一下后再通过接口传递给服务器。（问题轻松解决～～～就是这么简单）\n``` objc\n//text为传入参数\ntext = [text stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n```\n","source":"_posts/NSURLErrorDomain-Code-1002-“unsupported-URL”.md","raw":"---\ntitle: NSURLErrorDomain Code=-1002 “unsupported URL”\ndate: 2016-06-30 15:13:42\ntags:\n  - 常见错误\ncategories: 常见错误\n---\n\n在进行iOS网络请求的时候，报Error Domain=NSURLErrorDomain Code=-1002 “unsupported URL”的错误，请求的类型是GET，但是使用PSOTMAN和在浏览器中打开此接口可以返回正确的数据。通过google搜索最后找到了解决办法，今天记录下这个奇怪的问题。\n\n## 问题概述\n我在一个接手的二次开发的项目中，发现了这样一个问题，有的接口可以用正常访问，但是却有一个接口就不能正常访问。我对比了这个不能访问的接口和其它能够正常访问的接口的区别发现，当我传入的参数有值为中文字符串时就会报如下的错误，所以显然问题就出在传入参数为中文字符串的问题上。\n\n<!-- more -->\n\n## 问题分析\n通过对比发现（分析问题常见的方法），当这个接口传入了中文后将会报错，如果不传中文接口并不会报错，所以我基本上就可以锁定问题就出在中文字符的问题上。\n\n## 解决方法\n找到了问题出现的原因后其它的一切都变得简单了，因为传入中文字符会出现服务器不能解析然后报错的情况，所以我们应该将传入的中文字符用UTF8编码一下后再通过接口传递给服务器。（问题轻松解决～～～就是这么简单）\n``` objc\n//text为传入参数\ntext = [text stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n```\n","slug":"NSURLErrorDomain-Code-1002-“unsupported-URL”","published":1,"updated":"2016-06-30T07:41:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcjx001y29we06apojdm"},{"title":"Mac环境中Jenkins停止和启动命令","date":"2016-08-02T04:02:06.000Z","_content":"\n### 启动\n``` bash\nsudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist\n```\n\n### 停止\n``` bash\nsudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist\n```\n<!-- more -->\n","source":"_posts/Mac环境中Jenkins停止和启动命令.md","raw":"---\ntitle: Mac环境中Jenkins停止和启动命令\ndate: 2016-08-02 12:02:06\ntags:\n---\n\n### 启动\n``` bash\nsudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist\n```\n\n### 停止\n``` bash\nsudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist\n```\n<!-- more -->\n","slug":"Mac环境中Jenkins停止和启动命令","published":1,"updated":"2016-08-02T06:20:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcjz002329we94tstk49"},{"title":"Mac基础：如何让Finder显示隐藏文件和文件夹","date":"2016-04-28T01:43:25.000Z","_content":"有些人中喜欢折腾一些奇怪的东西（比如说我），使用git已经很长一段时间了，但是最近才发现在Finder中找不到.git的文件夹。原来这个东西是被隐藏了，那么现在问题来了，我要将隐藏的文件或者文件夹显示出来应该如何做呢？\n\n## 让Finder显示隐藏文件和文件夹\n\n* <b>第一步：</b>打开「终端」应用程序（我推荐使用[iTerm](https://www.iterm2.com/),他比Mac自带终端好用很多）。\n\n<!-- more -->\n\n* <b>第二步：</b>输入如下命令，如图一所示：\n{% asset_img bash.png 图一%}\n```bash\ndefaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder\n//OS X Mountain Lion 和早期版本命令如下：\ndefaults write com.apple.finder AppleShowAllFiles TRUE ; killall Finder\n```\n* <b>第三步：</b>按下「Return」键确认。\n现在你将会在 Finder 窗口中看到那些隐藏的文件和文件夹了。如图二所示：\n{% asset_img finder.png 图二%}\n\n\n## 让Finder隐藏隐藏文件和文件夹\n* 只需要一步\n如果你想再次隐藏原本的隐藏文件和文件夹的话，将上述命令替换成（图三）即可。\n{% asset_img show.png 图三%}\n```bash\ndefaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder\n//OS X Mountain Lion 和早期版本命令如下：\ndefaults write com.apple.finder AppleShowAllFiles FALSE ; killall Finder\n```\n\n* 最后看到的效果如图四所示：\n{% asset_img hidefinder.png 图四%}","source":"_posts/Mac基础：如何让Finder显示隐藏文件和文件夹.md","raw":"---\ntitle: Mac基础：如何让Finder显示隐藏文件和文件夹\ndate: 2016-04-28 09:43:25\ntags:\n  - Mac\ncategories: Mac基础\n---\n有些人中喜欢折腾一些奇怪的东西（比如说我），使用git已经很长一段时间了，但是最近才发现在Finder中找不到.git的文件夹。原来这个东西是被隐藏了，那么现在问题来了，我要将隐藏的文件或者文件夹显示出来应该如何做呢？\n\n## 让Finder显示隐藏文件和文件夹\n\n* <b>第一步：</b>打开「终端」应用程序（我推荐使用[iTerm](https://www.iterm2.com/),他比Mac自带终端好用很多）。\n\n<!-- more -->\n\n* <b>第二步：</b>输入如下命令，如图一所示：\n{% asset_img bash.png 图一%}\n```bash\ndefaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder\n//OS X Mountain Lion 和早期版本命令如下：\ndefaults write com.apple.finder AppleShowAllFiles TRUE ; killall Finder\n```\n* <b>第三步：</b>按下「Return」键确认。\n现在你将会在 Finder 窗口中看到那些隐藏的文件和文件夹了。如图二所示：\n{% asset_img finder.png 图二%}\n\n\n## 让Finder隐藏隐藏文件和文件夹\n* 只需要一步\n如果你想再次隐藏原本的隐藏文件和文件夹的话，将上述命令替换成（图三）即可。\n{% asset_img show.png 图三%}\n```bash\ndefaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder\n//OS X Mountain Lion 和早期版本命令如下：\ndefaults write com.apple.finder AppleShowAllFiles FALSE ; killall Finder\n```\n\n* 最后看到的效果如图四所示：\n{% asset_img hidefinder.png 图四%}","slug":"Mac基础：如何让Finder显示隐藏文件和文件夹","published":1,"updated":"2016-04-28T07:27:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gck1002429we25q2fjen"},{"title":"Hexo安装新主题apollo","date":"2016-02-20T08:15:35.000Z","_content":"\nHexo博客系统的流行原因，是因为他的个人性，而皮肤就是个人性的一种体现。Hexo换皮肤还是比较简单的,既可以自己根据默认的主题来修改，也可以到[https://hexo.io/themes/](https://hexo.io/themes/)上去找主题。\n\n下面简单描述一下我安装apollo主题的过程。\n\n<!-- more -->\n\n## 安装\ngithub上的文档给出了详细的安装命令\n``` bash\nhexo init #blogname#\ncd #blogname# \nnpm install\nnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\ngit clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo\n```\n\n## 启用\n安装成功后就可以开始启用主题，主题的启用需要修改_config.yml 的 theme 配置项为 apollo：\n``` bash\n# Extensions 插件和皮肤\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\n# theme: landscape\ntheme: apollo\n```\n\n启动hexo后修改成功后的皮肤如图所示\n{% asset_img apollo.png apollo主题 %}","source":"_posts/Hexo安装新主题apollo.md","raw":"---\ntitle: Hexo安装新主题apollo\ndate: 2016-02-20 16:15:35\ntags:\n---\n\nHexo博客系统的流行原因，是因为他的个人性，而皮肤就是个人性的一种体现。Hexo换皮肤还是比较简单的,既可以自己根据默认的主题来修改，也可以到[https://hexo.io/themes/](https://hexo.io/themes/)上去找主题。\n\n下面简单描述一下我安装apollo主题的过程。\n\n<!-- more -->\n\n## 安装\ngithub上的文档给出了详细的安装命令\n``` bash\nhexo init #blogname#\ncd #blogname# \nnpm install\nnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\ngit clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo\n```\n\n## 启用\n安装成功后就可以开始启用主题，主题的启用需要修改_config.yml 的 theme 配置项为 apollo：\n``` bash\n# Extensions 插件和皮肤\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\n# theme: landscape\ntheme: apollo\n```\n\n启动hexo后修改成功后的皮肤如图所示\n{% asset_img apollo.png apollo主题 %}","slug":"Hexo安装新主题apollo","published":1,"updated":"2016-06-02T04:11:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcke002929wefyouwme8"},{"title":"Hexo在github上构建免费的博客","date":"2016-02-20T04:07:20.000Z","_content":"\n\n很多次想搭建一个自己的博客，彻底从csdn上转移到自己的博客站点中，但是一直由于时间的原因耽搁了。之前也使用过Wordpress来搭建自己的博客，但是发现Wordpress使用起来不是太方便。后来再接触了markdown语法写文章后，喜欢上了markdown。再后来了解到了hexo，一个基于Node的博客框架，同样可以实现基于github的博客，而且更轻更快，更适合Node的开发程序员。\n\n## Hexo介绍\n\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 [Markdown](http://daringfireball.net/projects/markdown/)（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n<!-- more -->\n\n## Hexo安装\n\n安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：\n* [Node.js](http://nodejs.org/)\n* [git](http://git-scm.com/)\n\n如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n``` bash\n$ npm install -g hexo-cli\n```\n如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。\n>Mac用户在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -> Download -> Command Line Tools -> Install 安装命令行工具。\n\n### 安装 Git\n* Windows：下载并安装 [git](https://git-scm.com/download/win)\n* Mac：使用 [Homebrew](http://brew.sh/), [MacPorts](http://www.macports.org/) 或下载 安装程序 安装。\n* Linux (Ubuntu, Debian)：sudo apt-get install git-core\n* Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n\n### 安装 Node.js\n安装 Node.js 的最佳方式是使用[nvm](https://github.com/creationix/nvm)\ncURL:\n``` bash\n$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\nWget:\n``` bash\n$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\n安装完成后，重启终端并执行下列命令即可安装 Node.js。\n``` bash\nnvm install 5.0\n```\n或者您也可以下载 [安装程序](https://nodejs.org/en/) 来安装。\n\n### 安装 Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo,Hexo安装，要用全局安装，加-g参数。\n``` bash\n$ npm install -g hexo-cli\n$ npm install -g hexo\n```\n查看hexo的版本\n``` bash\n$ hexo version\nhexo-cli: 1.0.1\nos: Darwin 15.3.0 darwin x64\nhttp_parser: 2.5.0\nnode: 4.2.1\nv8: 4.5.103.35\nuv: 1.7.5\nzlib: 1.2.8\nares: 1.10.1-DEV\nicu: 56.1\nmodules: 46\nopenssl: 1.0.2d\n```\n\n## Hexo创建项目\n\n我的系统环境：\n* Mac OS X EI Capitan\n* node v4.2.1\n* npm 2.14.7\n\n安装好后，我们就可以使用Hexo创建项目了。\n``` bash\nhexo init nodejs-hexo \n```\n我们看到当前在目录下，出现了一个文件夹，包括初始化的文件。\n\n进入目录，并启动Hexo服务器。\n\n``` bash\n# 进入目录\n$ cd nodejs-hexo\n# 启动hexo服务器\n$ hexo server\nINFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.\n```\n这时端口4000被打开了，我们能过浏览器打开地址，http://0.0.0.0:4000/ \nps:Mac上的地址是[http://0.0.0.0:4000/](http://0.0.0.0:4000/)， windows上的地址是http://localhost:4000/\n\n## Hexo结构解析\n接下来，我们需要对Hexo做全面的了解，才能做出个性化的博客。\n### 目录和文件\n{% asset_img hexo-dict.png Hexo目录结构示意图 %}\n* .deploy_git 发布到github上生成的静态文件夹\n* node_modules mode的modules\n* scaffolds 脚手架，也就是一个工具模板\n* scripts 写文件的js，扩展hexo的功能\n* source 存放博客正文内容\n* source/_drafts 草稿箱\n* source/_posts 文件箱\n* themes 存放皮肤的目录\n* themes/landscape 默认的皮肤\n* _config.yml 全局的配置文件\n* db.json 静态常量\n\n_posts目录：我们每次创建的文章都放在了_posts目录下面，Hexo是一个静态博客框架，没有数据库，文章内容都是以文本文件的方式进行存储的，直接存储在_posts的目录。\n\nthemes目录：是存放皮肤的，包括一套Javascript+CSS样式和基于EJS的模板设置。通过在themes目录下，新建一个子目录，就可以创建一套新的皮肤，当然我们也可以直接在landscape上面修改。\n\n### 全局配置\n_config.yml是全局的配置文件：很多的网站配置都在这个文件中定义。\n* 站点信息: 定义标题，作者，语言\n* URL: URL访问路径\n* 文件目录: 正文的存储目录\n* 写博客配置：文章标题，文章类型，外部链接等\n* 目录和标签：默认分类，分类图，标签图\n* 归档设置：归档的类型\n* 服务器设置：IP，访问端口，日志输出\n* 时间和日期格式： 时间显示格式，日期显示格式\n* 分页设置：每页显示数量\n* 评论：外挂的Disqus评论系统\n* 插件和皮肤：换皮肤，安装插件\n* Markdown语言：markdown的标准\n* CSS的stylus格式：是否允许压缩\n* 部署配置：主要是github发布\n\n附上我本地的_config.yml配置\n``` bash\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site 站点信息\ntitle: Salvador\nsubtitle:\ndescription:\nauthor: Salvador\nlanguage: en\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory 文件目录\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing 写博客配置\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: true\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n\n# Category & Tag 目录和标签\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format 时间和日期格式\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination 分页设置\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions 插件和皮肤\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\n# theme: landscape\ntheme: apollo\n\n# Deployment 部署配置\n## Docs: https://hexo.io/docs/deployment.html\ndeploy: \n  type: git \n  repo: https://github.com/Jvaeyhcd/jvaeyhcd.github.io.git\n```\n\n## Hexo使用\n\n### 创建新文章\n\n接下来，我们可以开始创建博客了。Hexo建议通过命令来创建文章，当然你也可以直接在_posts目录下创建文件。\n通过命令创建新的文章\n``` bash\n$ hexo new post Hexo在github上构建免费的\nINFO  Created: ~/hexo-blog/source/_posts/Hexo在github上构建免费的.md\n```\n创建完成后在_posts目录下，就会生成文件“Hexo在github上构建免费的.md”\n\n{% asset_img hexo-new.png Hexo创建新的文章 %}\n\n然后，我们编辑文件：”Hexo在github上构建免费的.md”，以markdown语法写文章，然后保存。\n\n在命令行，启动服务器。\n``` bash\n$ sudo hexo server\n```\n\n### 文章的语法\n我们在写文章时，有一些语法的要求。\n语法包括3部分：\n* 基本信息：标题，发布日期，分类目录，标签，类型，固定发布链接\n* 正文：markdown语法和Swig语法(掌握一个就行)\n* 特殊标记：引用，链接，图片，代码块，iframe，youtube视频\n\n#### 基本信息\n必须在文件的顶部，---的行之前的部分。如：\n``` bash\n---\ntitle: Hexo在github上构建免费的博客\ndate: 2016-02-20 12:07:20\ntags:\n---\n```\n#### 正文\nhexo的正文要求使用markdown的语法，markdown的语法可以参考 [此处](http://www.markdown.cn/).\n\n#### 特殊标记\nhexo对于一些有特殊标记 文字块，做了特殊的定义。\n\n** 引用 **\n``` bash\n# Swig语法\n{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}\nEvery interaction is both precious and an opportunity to delight.\n{% endblockquote %}\n\n# Markdown语法\n> Every interaction is both precious and an opportunity to delight.\n```\n\n** 代码块 **\n``` bash\n# Swig语法\n{% codeblock .compact http://underscorejs.org/#compact Underscore.js %}\n.compact([0, 1, false, 2, ‘’, 3]);\n=> [1, 2, 3]\n{% endcodeblock %}\n\n# Markdown语法\n'```{bash}\n.compact([0, 1, false, 2, ‘’, 3]);\n=> [1, 2, 3]\n```'\n\n```\n\n** 链接 **\n``` bash\n# Swig语法\n{% link 粉丝日志 http://blog.fens.me true 粉丝日志 %}\n\n# Markdown语法\n[粉丝日志](http://blog.fens.me)\n```\n\n** 图片 **\n对于本地图片，需要在_config.yml文件中配置\"post_asset_folder: true\"。\n``` bash\n# Writing 写博客配置\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: true\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n```\n这样在\"hexo new\"创建文章的时候hexo会自动会在_posts文件夹下面生成一个与文章同名的文件夹存放图片资源,如下图所示\n{% asset_img hexo-new.png Hexo创建新的文章 %}\n\n通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。\n\n``` bash\n{% asset_path slug %}\n{% asset_img slug [title] %}\n{% asset_link slug [title] %}\n```\n比如说：当你打开文章资源文件夹功能后，你把一个 \"example.jpg\" 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 它将 不会 出现在页面上。正确的引用本地图片方式是使用下面的标签而不是 markdown ：\n``` bash\n{% asset_img example.jpg This is an example image %}\n```\n\n## 发布到github\n\n### 静态化处理\n写完了文章，我们就可以发布了。要说明的一点是hexo的静态博客框架，那什么是静态博客呢？静态博客，是只包含html, javascript, css文件的网站，没有动态的脚本。虽然我们是用Node进行的开发，但博客的发布后就与Node无关了。在发布之前，我们要通过一条命令，把所有的文章都做静态化处理，就是生成对应的html, javascript, css，使得所有的文章都是由静态文件组成的。\n\n** 静态化命令 **\n``` bash\n$ hexo generate\n```\n运行完命令后，在本地目录下，会生成一个public的目录，里面包括了所有静态化的文件。\n\n### 上传到github\n\n接下来，我们把这个博客发布到github。\n首先在github上创建一个项目“你的用户名.github.io”,我创建的项目是[jvaeyhcd.github.io](https://github.com/Jvaeyhcd/jvaeyhcd.github.io)\n编辑全局配置文件：_config.yml，找到deploy的部分，设置github的项目地址。\n``` bash\n# Deployment 部署配置\n## Docs: https://hexo.io/docs/deployment.html\ndeploy: \n  type: git #这里必须是git，以前是github\n  repo: https://github.com/Jvaeyhcd/jvaeyhcd.github.io.git\n```\n然后，通过命令进行部署。\n``` bash\n$ sudo hexo d\n```\n部署完成后，打开你在github上创建的工程，你会看到\n{% asset_img github.png github %}\n然后访问[http://jvaeyhcd.github.io/](http://jvaeyhcd.github.io/)就能看到你发布到github上的博客了。\n","source":"_posts/Hexo在github上构建免费的博客.md","raw":"---\ntitle: Hexo在github上构建免费的博客\ndate: 2016-02-20 12:07:20\ntags:\n---\n\n\n很多次想搭建一个自己的博客，彻底从csdn上转移到自己的博客站点中，但是一直由于时间的原因耽搁了。之前也使用过Wordpress来搭建自己的博客，但是发现Wordpress使用起来不是太方便。后来再接触了markdown语法写文章后，喜欢上了markdown。再后来了解到了hexo，一个基于Node的博客框架，同样可以实现基于github的博客，而且更轻更快，更适合Node的开发程序员。\n\n## Hexo介绍\n\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 [Markdown](http://daringfireball.net/projects/markdown/)（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n<!-- more -->\n\n## Hexo安装\n\n安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：\n* [Node.js](http://nodejs.org/)\n* [git](http://git-scm.com/)\n\n如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。\n``` bash\n$ npm install -g hexo-cli\n```\n如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。\n>Mac用户在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -> Download -> Command Line Tools -> Install 安装命令行工具。\n\n### 安装 Git\n* Windows：下载并安装 [git](https://git-scm.com/download/win)\n* Mac：使用 [Homebrew](http://brew.sh/), [MacPorts](http://www.macports.org/) 或下载 安装程序 安装。\n* Linux (Ubuntu, Debian)：sudo apt-get install git-core\n* Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n\n### 安装 Node.js\n安装 Node.js 的最佳方式是使用[nvm](https://github.com/creationix/nvm)\ncURL:\n``` bash\n$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\nWget:\n``` bash\n$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\n安装完成后，重启终端并执行下列命令即可安装 Node.js。\n``` bash\nnvm install 5.0\n```\n或者您也可以下载 [安装程序](https://nodejs.org/en/) 来安装。\n\n### 安装 Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo,Hexo安装，要用全局安装，加-g参数。\n``` bash\n$ npm install -g hexo-cli\n$ npm install -g hexo\n```\n查看hexo的版本\n``` bash\n$ hexo version\nhexo-cli: 1.0.1\nos: Darwin 15.3.0 darwin x64\nhttp_parser: 2.5.0\nnode: 4.2.1\nv8: 4.5.103.35\nuv: 1.7.5\nzlib: 1.2.8\nares: 1.10.1-DEV\nicu: 56.1\nmodules: 46\nopenssl: 1.0.2d\n```\n\n## Hexo创建项目\n\n我的系统环境：\n* Mac OS X EI Capitan\n* node v4.2.1\n* npm 2.14.7\n\n安装好后，我们就可以使用Hexo创建项目了。\n``` bash\nhexo init nodejs-hexo \n```\n我们看到当前在目录下，出现了一个文件夹，包括初始化的文件。\n\n进入目录，并启动Hexo服务器。\n\n``` bash\n# 进入目录\n$ cd nodejs-hexo\n# 启动hexo服务器\n$ hexo server\nINFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.\n```\n这时端口4000被打开了，我们能过浏览器打开地址，http://0.0.0.0:4000/ \nps:Mac上的地址是[http://0.0.0.0:4000/](http://0.0.0.0:4000/)， windows上的地址是http://localhost:4000/\n\n## Hexo结构解析\n接下来，我们需要对Hexo做全面的了解，才能做出个性化的博客。\n### 目录和文件\n{% asset_img hexo-dict.png Hexo目录结构示意图 %}\n* .deploy_git 发布到github上生成的静态文件夹\n* node_modules mode的modules\n* scaffolds 脚手架，也就是一个工具模板\n* scripts 写文件的js，扩展hexo的功能\n* source 存放博客正文内容\n* source/_drafts 草稿箱\n* source/_posts 文件箱\n* themes 存放皮肤的目录\n* themes/landscape 默认的皮肤\n* _config.yml 全局的配置文件\n* db.json 静态常量\n\n_posts目录：我们每次创建的文章都放在了_posts目录下面，Hexo是一个静态博客框架，没有数据库，文章内容都是以文本文件的方式进行存储的，直接存储在_posts的目录。\n\nthemes目录：是存放皮肤的，包括一套Javascript+CSS样式和基于EJS的模板设置。通过在themes目录下，新建一个子目录，就可以创建一套新的皮肤，当然我们也可以直接在landscape上面修改。\n\n### 全局配置\n_config.yml是全局的配置文件：很多的网站配置都在这个文件中定义。\n* 站点信息: 定义标题，作者，语言\n* URL: URL访问路径\n* 文件目录: 正文的存储目录\n* 写博客配置：文章标题，文章类型，外部链接等\n* 目录和标签：默认分类，分类图，标签图\n* 归档设置：归档的类型\n* 服务器设置：IP，访问端口，日志输出\n* 时间和日期格式： 时间显示格式，日期显示格式\n* 分页设置：每页显示数量\n* 评论：外挂的Disqus评论系统\n* 插件和皮肤：换皮肤，安装插件\n* Markdown语言：markdown的标准\n* CSS的stylus格式：是否允许压缩\n* 部署配置：主要是github发布\n\n附上我本地的_config.yml配置\n``` bash\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site 站点信息\ntitle: Salvador\nsubtitle:\ndescription:\nauthor: Salvador\nlanguage: en\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory 文件目录\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing 写博客配置\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: true\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n\n# Category & Tag 目录和标签\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format 时间和日期格式\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination 分页设置\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions 插件和皮肤\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\n# theme: landscape\ntheme: apollo\n\n# Deployment 部署配置\n## Docs: https://hexo.io/docs/deployment.html\ndeploy: \n  type: git \n  repo: https://github.com/Jvaeyhcd/jvaeyhcd.github.io.git\n```\n\n## Hexo使用\n\n### 创建新文章\n\n接下来，我们可以开始创建博客了。Hexo建议通过命令来创建文章，当然你也可以直接在_posts目录下创建文件。\n通过命令创建新的文章\n``` bash\n$ hexo new post Hexo在github上构建免费的\nINFO  Created: ~/hexo-blog/source/_posts/Hexo在github上构建免费的.md\n```\n创建完成后在_posts目录下，就会生成文件“Hexo在github上构建免费的.md”\n\n{% asset_img hexo-new.png Hexo创建新的文章 %}\n\n然后，我们编辑文件：”Hexo在github上构建免费的.md”，以markdown语法写文章，然后保存。\n\n在命令行，启动服务器。\n``` bash\n$ sudo hexo server\n```\n\n### 文章的语法\n我们在写文章时，有一些语法的要求。\n语法包括3部分：\n* 基本信息：标题，发布日期，分类目录，标签，类型，固定发布链接\n* 正文：markdown语法和Swig语法(掌握一个就行)\n* 特殊标记：引用，链接，图片，代码块，iframe，youtube视频\n\n#### 基本信息\n必须在文件的顶部，---的行之前的部分。如：\n``` bash\n---\ntitle: Hexo在github上构建免费的博客\ndate: 2016-02-20 12:07:20\ntags:\n---\n```\n#### 正文\nhexo的正文要求使用markdown的语法，markdown的语法可以参考 [此处](http://www.markdown.cn/).\n\n#### 特殊标记\nhexo对于一些有特殊标记 文字块，做了特殊的定义。\n\n** 引用 **\n``` bash\n# Swig语法\n{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}\nEvery interaction is both precious and an opportunity to delight.\n{% endblockquote %}\n\n# Markdown语法\n> Every interaction is both precious and an opportunity to delight.\n```\n\n** 代码块 **\n``` bash\n# Swig语法\n{% codeblock .compact http://underscorejs.org/#compact Underscore.js %}\n.compact([0, 1, false, 2, ‘’, 3]);\n=> [1, 2, 3]\n{% endcodeblock %}\n\n# Markdown语法\n'```{bash}\n.compact([0, 1, false, 2, ‘’, 3]);\n=> [1, 2, 3]\n```'\n\n```\n\n** 链接 **\n``` bash\n# Swig语法\n{% link 粉丝日志 http://blog.fens.me true 粉丝日志 %}\n\n# Markdown语法\n[粉丝日志](http://blog.fens.me)\n```\n\n** 图片 **\n对于本地图片，需要在_config.yml文件中配置\"post_asset_folder: true\"。\n``` bash\n# Writing 写博客配置\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: true\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: false\n  tab_replace:\n```\n这样在\"hexo new\"创建文章的时候hexo会自动会在_posts文件夹下面生成一个与文章同名的文件夹存放图片资源,如下图所示\n{% asset_img hexo-new.png Hexo创建新的文章 %}\n\n通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。\n\n``` bash\n{% asset_path slug %}\n{% asset_img slug [title] %}\n{% asset_link slug [title] %}\n```\n比如说：当你打开文章资源文件夹功能后，你把一个 \"example.jpg\" 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 它将 不会 出现在页面上。正确的引用本地图片方式是使用下面的标签而不是 markdown ：\n``` bash\n{% asset_img example.jpg This is an example image %}\n```\n\n## 发布到github\n\n### 静态化处理\n写完了文章，我们就可以发布了。要说明的一点是hexo的静态博客框架，那什么是静态博客呢？静态博客，是只包含html, javascript, css文件的网站，没有动态的脚本。虽然我们是用Node进行的开发，但博客的发布后就与Node无关了。在发布之前，我们要通过一条命令，把所有的文章都做静态化处理，就是生成对应的html, javascript, css，使得所有的文章都是由静态文件组成的。\n\n** 静态化命令 **\n``` bash\n$ hexo generate\n```\n运行完命令后，在本地目录下，会生成一个public的目录，里面包括了所有静态化的文件。\n\n### 上传到github\n\n接下来，我们把这个博客发布到github。\n首先在github上创建一个项目“你的用户名.github.io”,我创建的项目是[jvaeyhcd.github.io](https://github.com/Jvaeyhcd/jvaeyhcd.github.io)\n编辑全局配置文件：_config.yml，找到deploy的部分，设置github的项目地址。\n``` bash\n# Deployment 部署配置\n## Docs: https://hexo.io/docs/deployment.html\ndeploy: \n  type: git #这里必须是git，以前是github\n  repo: https://github.com/Jvaeyhcd/jvaeyhcd.github.io.git\n```\n然后，通过命令进行部署。\n``` bash\n$ sudo hexo d\n```\n部署完成后，打开你在github上创建的工程，你会看到\n{% asset_img github.png github %}\n然后访问[http://jvaeyhcd.github.io/](http://jvaeyhcd.github.io/)就能看到你发布到github上的博客了。\n","slug":"Hexo在github上构建免费的博客","published":1,"updated":"2016-06-02T04:23:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gckj002a29we5psi3tg7"},{"title":"Github上优秀的objc项目简介","date":"2016-02-20T09:15:47.000Z","_content":"\n主要对当前Github排名靠前的项目做一个简单的简介，方便自己快速了解 objc的一些优秀的开源框架。\n\n* <a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"AFNetworking\">AFNetworking</a>\n作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest\n* <a href=\"https://github.com/gavinkwoe/BeeFramework\">BeeFramework</a>\nBeeFramework是一个iOS应用开发框架，由国内开发者郭虹宇创立并且在Github上开源。经过一年多的发展，BeeFramework在Github上，得到了广泛关注，有1000多的star数和400多的fork数\n* <a href=\"https://github.com/BradLarson/GPUImage\">GPUImage</a>\n一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 SO 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果\n\n<!-- more -->\n\n* <a href=\"https://github.com/rs/SDWebImage\">SDWebImage</a>\n作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单\n* <a href=\"https://github.com/RestKit/RestKit\">RestKit</a>\n主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上\n* <a href=\"https://github.com/ReactiveCocoa/ReactiveCocoa\">ReactiveCocoa</a>\n由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 \"An open source project that exemplifies this brave new era for objc\", 也有人说它是 Cocoa 的未来,GitHub自家的函数式响应式编程范式的objc实现，名字听着很高大上，学习曲线确实也比较陡，但是绝对会改变你对iOS编程的认知\n* <a href=\"https://github.com/facebookarchive/three20\">three20</a>\n由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 PR 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 Nimbus, 算是 three20 的一个替代品\n* <a href=\"https://github.com/jdg/MBProgressHUD\">MBProgressHUD</a>\n作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师, 此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)\n* <a href=\"https://github.com/magicalpanda/MagicalRecord\">MagicalRecord</a>\n作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作\n* <a href=\"https://github.com/ccgus/fmdb\">FMDB</a>\n一个对 SQLite 进行封装的库, 使用起来方便, 简单\n* <a href=\"https://github.com/Mantle/Mantle\">Mantle</a>\n作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了。GitHub自家的产物，轻量级建模的首选，也可以很好的配合CoreData工作\n* <a href=\"https://github.com/Grouper/FlatUIKit\">FlatUIKit</a>\n收集了很多扁平化 UI 的 iOS 组件, 方便使用\n* <a href=\"https://github.com/pokeb/asi-http-request\">ASIHTTPRequest</a>\n一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)\n* <a href=\"https://github.com/path/FastImageCache\">FastImageCache</a>\nPath 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点\n* <a href=\"https://github.com/SnapKit/Masonry\">Masonry</a>\n一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备\n* <a href=\"https://github.com/facebook/Shimmer\">Shimmer</a>\nFacebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单\n* <a href=\"https://github.com/TransitApp/SVProgressHUD\">SVProgressHUD</a>\n又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用\n* <a href=\"https://github.com/johnezang/JSONKit\">JSONKit</a>\n主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了\n* <a href=\"https://github.com/jverkoey/nimbus\">Nimbus</a>\n作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全\n* <a href=\"https://github.com/facebook/facebook-ios-sdk\"> Facebook SDK for iOS</a>\nFacebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面\n* <a href=\"https://github.com/facebook/AsyncDisplayKit\">AsyncDisplayKit</a>\nFacebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎\n* <a href=\"https://github.com/supermarin/Alcatraz\">Alcatraz</a>\nAlcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传\n* <a href=\"https://github.com/jessesquires/JSQMessagesViewController\">JSQMessagesViewController</a>\n优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高\n* <a href=\"https://github.com/facebook/xctool\">Xctool</a>\n是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, Travis CI, OCLint 等测试工具\n* <a href=\"https://github.com/OpenEmu/OpenEmu\">OpenEmu</a>\n超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错\n* <a href=\"https://github.com/nicklockwood/iCarousel\">iCarousel</a>\n作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果\n* <a href=\"https://github.com/romaonthego/RESideMenu\">RESideMenu</a>\n作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8\n* <a href=\"https://github.com/kevinzhow/PNChart\">PNChart</a>\n作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱\n* <a href=\"https://github.com/square/PonyDebugger\">PonyDebugger</a>\n由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试\n* <a href=\"https://github.com/jverdi/JVFloatLabeledTextField\">JVFloatLabeledTextField</a>\n作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本\n* <a href=\"https://github.com/CEWendel/SWTableViewCell\">SWTableViewCell</a>\nUITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮\n* <a href=\"https://github.com/levey/AwesomeMenu\">AwesomeMenu</a>\n作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果\n* <a href=\"https://github.com/tonymillion/Reachability\">Reachability</a>\nReachablity 是用于检测 iOS 设备网络环境的库,Beeframeowrk中使用过的库\n* <a href=\"https://github.com/onevcat/VVDocumenter-Xcode\"> VVDocumenter-Xcode</a>\n作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞\n* <a href=\"https://github.com/google/physical-web\">The Physical Web</a>\n由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段\n* <a href=\"https://github.com/samuelclay/NewsBlur\">NewsBlur</a>\n作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码\n* <a href=\"https://github.com/cocos2d/cocos2d-objc\">Cocos2D-SpriteBuilder</a>\n一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift, 目前该项目在 GitHub 上更新较为频繁\n* <a href=\"https://github.com/TTTAttributedLabel/TTTAttributedLabel\">TTTAttributedLabel</a>\nUILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能\n* <a href=\"https://github.com/robbiehanson/CocoaAsyncSocket\">CocoaAsyncSocket</a>\n一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师\n* <a href=\"https://github.com/devinross/tapkulibrary\">TapkuLibrary</a>\n作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中</a>\n* <a href=\"https://github.com/CanvasPod/Canvas\">Canvas</a>\n无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手\n* <a href=\"https://github.com/square/SocketRocket\">SocketRocket</a>\nSquare 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱\n* <a href=\"https://github.com/ECSlidingViewController/ECSlidingViewController\">ECSlidingViewController</a>\n一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工\n* <a href=\"https://github.com/stig/json-framework\">Json Framework</a>\n用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了\n* <a href=\"https://github.com/facebook/Tweaks\">Tweaks</a>\nFacebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了\n* <a href=\"https://github.com/realm/realm-cocoa\">realm-cocoa</a>\nRealm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库\n* <a href=\"https://github.com/icanzilb/JSONModel\">JSONModel</a>\n一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换\n* <a href=\"https://github.com/facebook/KVOController\">KVOController</a>\n一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一\n* <a href=\"https://github.com/mwaterfall/MWPhotoBrowser\">MWPhotoBrowser</a>\n一款简单的 iOS 照片浏览控件\n* <a href=\"https://github.com/samvermette/SVPullToRefresh\">SVPullToRefresh</a>\n<b>一款只需一行代码便可集成上拉刷新和下拉加载的组件</b>\n* <a href=\"https://github.com/facebook/pop\">POP</a>\nfacebook出品的paper，动画效果太好了，赶超apple的原生app一大截。pop就是paper的动画库！\n* <a href=\"https://github.com/dennisreimann/ioctocat\">ioctocat</a>\ngithub的iOS客户端，目前开源代码是V1版本，V2版本在appstore上可以下载\n* <a href=\"https://github.com/ChatSecure/ChatSecure-iOS\">ChatSecure</a>\n使用XMPP协议的IM开源软件，很强大，在appstore上可以下载\n* [FDFullscreenPopGesture](https://github.com/forkingdog/FDFullscreenPopGesture)\n一个丝滑的全屏滑动返回手势,相关博客文章点击[这里](http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/)\n* [TKSubmitTransition](https://github.com/Jvaeyhcd/TKSubmitTransition)\n非常漂亮的一个登录转场动画\n* [DZNEmptyDataSet](https://github.com/dzenbot/DZNEmptyDataSet)\n非常方便的对一些没有数据的UITableView或者UIScrollView加上提示图片和文字。\n\n* [iRate](https://github.com/nicklockwood/iRate)\n一个开源的评分控件，能够非常友好的设置提醒用户去评论我们的app\n\n* [iVersion](https://github.com/nicklockwood/iVersion)\n和iRate一样出自同一个人之手，，这个是提示用户更新版本。\n\n* [PureLayout](https://github.com/PureLayout/PureLayout)\n自动布局\n\n# 文本相关\n\n* [SlackTextViewController](https://github.com/slackhq/SlackTextViewController)\n你曾经用过Slack iOS应用吗？如果你在较大的软件公司工作，也许会用过。对那些没用过的人呢？—?Slack令人激动。用到Slack的应用也是这样，尤其是用作极佳、定制的文本输入控制时。这时你有了一个现成可用在应用中的代码。自适应文本区域？试一下。手势识别、自动填充、多媒体合并？试一下。快速drop-in解决方案？试一下。其他还想要什么？SlackTextViewController 可以替代 UITableViewController & UICollectionViewController。\n\n* [RTLabel](https://github.com/honcheng/RTLabel)\n用于显示html的Label\n\n* [Shimmer](https://github.com/facebook/Shimmer)\n滑动解锁效果的界面\n\n* [DDRichText](https://github.com/daiweilai/DDRichText)\n为图文混排提供了一个思路\n\n# 进度条\n\n* [NJKWebViewProgress](https://github.com/ninjinkun/NJKWebViewProgress)\nweb界面加载进度条\n\n* [MBProgressHUD](https://github.com/jdg/MBProgressHUD)\nMBProgressHUD 使用非常广泛，网上很多基于ta的封装\n\n* [SVProgressHUD](https://github.com/SVProgressHUD/SVProgressHUD)\nNavigation的扩展，强烈推荐\n\n* [Toast](https://github.com/scalessec/Toast)\n\n# 导航栏\n\n* [LTNavigationbar](https://github.com/ltebean/LTNavigationbar)\n上下滑动动态改变导航栏颜色\n\n* [JZNavigationExtension](https://github.com/JazysYu/JZNavigationExtension)\n\n# 键盘类\n\n* [IQKeyboardManager](https://github.com/hackiftekhar/IQKeyboardManager)\n\n* [TPKeyboardAvoiding](https://github.com/michaeltyson/TPKeyboardAvoiding)\n这个我用得很多，界面上如果有输入框可以界面会跟着键盘动，而不被键盘挡住。\n\n# 基础工具类以及Category\n\n* [BFKit OC版本](https://github.com/FabrizioBrancati/BFKit)\n国外的一个大神写的很好用的分类，比较齐全\n\n* [DateTools](https://github.com/MatthewYork/DateTools)\n很强大的日期工具类\n\n* [iOS-Categories](https://github.com/shaojiankui/iOS-Categories)\n很是全面的一个扩展 iOS中的各种objc Category, a collection of useful objc Categories extending iOS Frameworks such as Foundation,UIKit,CoreData,QuartzCore,CoreLocation,MapKit Etc.\n\n* [Material-Controls-For-iOS](https://github.com/fpt-software/Material-Controls-For-iOS)\n大神模仿谷歌做的iOS原生特效控件\n\n* [BlocksKit](https://github.com/zwaldowski/BlocksKit)\n为基础类提供Block支持，很好用\n\n# 弹出框\n\n* [STPopup](https://github.com/kevin0571/STPopup)\n很方便的弹出框\n\n* [MMPopupView](https://github.com/adad184/MMPopupView)\n里脊串的弹出框\n\n* [NYAlertViewController](https://github.com/nealyoung/NYAlertViewController)\n非常强大的弹出框\n\n* [TYAlertController](https://github.com/12207480/TYAlertController)\n很好很强大的弹出框，多种样式满足你的需求\n\n* [JKPopMenuView](https://github.com/UncleJoke/JKPopMenuView)\n一个简单的弹出菜单\n\n# 其它\n\n* [SWTableViewCell](https://github.com/CEWendel/SWTableViewCell)\n自定义侧滑\n\n* [MGSwipeTableCell](https://github.com/MortimerGoro/MGSwipeTableCell)\n同上自定义侧滑\n\n* [FDFullscreenPopGesture](https://github.com/forkingdog/FDFullscreenPopGesture)\n全屏滑动返回上级页面\n\n* [PDTSimpleCalendar](https://github.com/jivesoftware/PDTSimpleCalendar)\n一款日历控件，可以看看\n\n# Xcode插件\n\n* <a href=\"https://github.com/kattrali/cocoapods-xcode-plugin\">cocoapods-xcode-plugin</a>\nDependency management helper for your CocoaPods, right in Xcode.\n用于在Xcode中管理CocoaPods依赖库。\n![\"\"](http://wangzz.github.io/images/article1/plugin_cocoapods_menu.png)\n* <a href=\"https://github.com/qfish/XAlign\">XAlign</a>\nAn amazing Xcode plugin to align regular code. it can align Xnything in any way you want.\n方便实现代码对其功能，使代码风格统一。\n![\"\"](http://wangzz.github.io/images/article1/plugin_align.gif)\n* <a href=\"https://github.com/supermarin/Alcatraz\">Alcatraz</a>\nAlcatraz is an open-source package manager for Xcode 5+. It lets you discover and install plugins, templates and color schemes without the need for manually cloning or copying files. It installs itself as a part of Xcode and it feels like home.---Xcode插件管理工具。\n![\"\"](https://camo.githubusercontent.com/919efe4e1e53237df51d7010c862bd5c04fd6a70/687474703a2f2f616c63617472617a2e696f2f696d616765732f73637265656e73686f744032782e706e67)\n* <a href=\"https://github.com/onevcat/VVDocumenter-Xcode\">VVDocumenter-Xcode</a>\n提供了为代码增加注视的最快捷方式,非常好的Xcode插件。\n![\"\"](https://camo.githubusercontent.com/ca5518c9872e15b8a95b9d8c5f44bc331977d710/68747470733a2f2f7261772e6769746875622e636f6d2f6f6e65766361742f5656446f63756d656e7465722d58636f64652f6d61737465722f53637265656e53686f742e676966)\n并且支持了Swift的注释，太棒了！\n![\"\"](https://camo.githubusercontent.com/58e452b57245cd79c2e59ac7926609be4dffbfd8/68747470733a2f2f7261772e6769746875622e636f6d2f6f6e65766361742f5656446f63756d656e7465722d58636f64652f6d61737465722f7676646f63756d656e7465722d73776966742e676966)\n* <a href=\"https://github.com/ksuther/KSImageNamed-Xcode\">KSImageNamed-Xcode</a>\n当输入[NSImage imageNamed: 或者[UIImage imageNamed:时，会自动补全工程中可用的图片名称，同时能提供选中图片的预览。\n![\"\"](http://foggry.com/images/article1/plugin_image_named.gif)\n\n自己做个笔记，方便以后工作遇到问题能够得到快速的解决","source":"_posts/Github上优秀的Objective-C项目简介.md","raw":"---\ntitle: Github上优秀的objc项目简介\ndate: 2016-02-20 17:15:47\ntags:\n---\n\n主要对当前Github排名靠前的项目做一个简单的简介，方便自己快速了解 objc的一些优秀的开源框架。\n\n* <a href=\"https://github.com/AFNetworking/AFNetworking\" target=\"AFNetworking\">AFNetworking</a>\n作者是 NSHipster 的博主, iOS 开发界的大神级人物, 毕业于卡内基·梅隆大学, 开源了许多牛逼的项目, 这个便是其中之一, AFNetworking 采用 NSURLConnection + NSOperation, 主要方便与服务端 API 进行数据交换, 操作简单, 功能强大, 现在许多人都用它取代 ASIHTTPRequest\n* <a href=\"https://github.com/gavinkwoe/BeeFramework\">BeeFramework</a>\nBeeFramework是一个iOS应用开发框架，由国内开发者郭虹宇创立并且在Github上开源。经过一年多的发展，BeeFramework在Github上，得到了广泛关注，有1000多的star数和400多的fork数\n* <a href=\"https://github.com/BradLarson/GPUImage\">GPUImage</a>\n一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 SO 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果\n\n<!-- more -->\n\n* <a href=\"https://github.com/rs/SDWebImage\">SDWebImage</a>\n作者 Olivier Poitrey 是 Dailymotion 的 CTO, 拥有多个不错的开源项目, 此项目常用于对从 Web 端接受到的图片进行缓存, 是 UIImageView 的扩展, 应用起来比较简单\n* <a href=\"https://github.com/RestKit/RestKit\">RestKit</a>\n主要用于 iOS 上网络通信, 允许与 RESTful Web 服务交互, 常用于处理 API, 解析 JSON, 映射响应对象等操作, 简单易用, 方便你把所有精力都放在对数据的操作上\n* <a href=\"https://github.com/ReactiveCocoa/ReactiveCocoa\">ReactiveCocoa</a>\n由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 \"An open source project that exemplifies this brave new era for objc\", 也有人说它是 Cocoa 的未来,GitHub自家的函数式响应式编程范式的objc实现，名字听着很高大上，学习曲线确实也比较陡，但是绝对会改变你对iOS编程的认知\n* <a href=\"https://github.com/facebookarchive/three20\">three20</a>\n由 Facebook iOS 客户端衍生出的一款 iPhone 框架, 内置许多丰富的功能, 有丰富的界面, 对底层的操作便捷, 为开发者省下了很多时间, 但现在已经停止了更新, 一个 PR 把代码删得干干净净, 不要好奇去点开 Files changed, 我点开后该页面直接卡死, three20 当中的一位作者创建了 Nimbus, 算是 three20 的一个替代品\n* <a href=\"https://github.com/jdg/MBProgressHUD\">MBProgressHUD</a>\n作者 Matej Bukovinski 是一位全栈工程师, UI/UX 设计师, 此项目是一款提示框第三方库, 帮助开发者快速应用到项目中)\n* <a href=\"https://github.com/magicalpanda/MagicalRecord\">MagicalRecord</a>\n作者是 Coursera 的 iOS 工程师, 该项目创作灵感来自于 Ruby on Rails 的 Active Record, 主要为方便操作 CoreData 而生, 帮助清除 CoreData 引用的代码, 协助方便 CoreData 的工作\n* <a href=\"https://github.com/ccgus/fmdb\">FMDB</a>\n一个对 SQLite 进行封装的库, 使用起来方便, 简单\n* <a href=\"https://github.com/Mantle/Mantle\">Mantle</a>\n作者是 GitHub 的员工, 文档写的很清楚: Mantle makes it easy to write a simple model layer for your Cocoa or Cocoa Touch application, 主要用来将 JSON 数据模型化为 Model 对象, 唱吧在前段时间也改用 Mantle 了。GitHub自家的产物，轻量级建模的首选，也可以很好的配合CoreData工作\n* <a href=\"https://github.com/Grouper/FlatUIKit\">FlatUIKit</a>\n收集了很多扁平化 UI 的 iOS 组件, 方便使用\n* <a href=\"https://github.com/pokeb/asi-http-request\">ASIHTTPRequest</a>\n一个轻量级的 iOS 网络通信类库, 基于 CFNetwork 框架开发, 但现在已经停止更新, 多数开发者改用 AFNetworking 替代)\n* <a href=\"https://github.com/path/FastImageCache\">FastImageCache</a>\nPath 公司出品的 iOS 库, 作者 Mallory Paine 是苹果前员工, 此类库适用于在滚动时快速显示图像, 高速持久是其最大的特点\n* <a href=\"https://github.com/SnapKit/Masonry\">Masonry</a>\n一个轻量级的布局框架, 同时支持 iOS 和 Mac OS X, 语法优雅, 帮助开发者快速适配不同分辨率的 iOS 设备\n* <a href=\"https://github.com/facebook/Shimmer\">Shimmer</a>\nFacebook 推出的一款具有闪烁效果的第三方控件, 供它旗下一款名为 Paper 的应用使用, 安装使用整个过程都十分简单\n* <a href=\"https://github.com/TransitApp/SVProgressHUD\">SVProgressHUD</a>\n又一款轻量级的 iOS 第三方控件, 用于显示任务加载时的动画, 非常轻便, 容易使用\n* <a href=\"https://github.com/johnezang/JSONKit\">JSONKit</a>\n主要用于解析 JSON, 适用于 iOS6 以下环境, 自从 iOS5 开始 Apple 官方给出了 NSJSONSerialization API, 自此大家都用官方的了\n* <a href=\"https://github.com/jverkoey/nimbus\">Nimbus</a>\n作者 Jeff 曾为 Facebook, Google 做过不少好东西, 也是 three20 的成员之一, three20 停更后, 他创造出这个框架来代替 three20, 文档齐全\n* <a href=\"https://github.com/facebook/facebook-ios-sdk\"> Facebook SDK for iOS</a>\nFacebook 官方的 iOS SDK, 方便开发者集成 Facebook 的一些功能到自己的 iOS APP 里面\n* <a href=\"https://github.com/facebook/AsyncDisplayKit\">AsyncDisplayKit</a>\nFacebook 开源的一款 iOS UI 框架, Paper 用的就是该框架, 另外框架还用到了 Facebook 早期开源 Pop 动画引擎\n* <a href=\"https://github.com/supermarin/Alcatraz\">Alcatraz</a>\nAlcatraz 是一款管理 Xcode 插件、模版以及颜色配置的工具, 可以集成到 Xcode 的图形界面中, 安装删除都是几条命令的事, 很方便, 支持自己开发插件并上传\n* <a href=\"https://github.com/jessesquires/JSQMessagesViewController\">JSQMessagesViewController</a>\n优雅的 iOS 消息类库, 常用于聊天应用中, 可定制性高\n* <a href=\"https://github.com/facebook/xctool\">Xctool</a>\n是 Facebook 开源的一个命令行工具，用来替代苹果的 XcodeBuild 工具, 极大的方便了 iOS 的构建和测试, 输出错误信息也比较友好, 受到许多 iOS 开发者的称赞, 经常与其搭配使用的还有 OCUnit, Travis CI, OCLint 等测试工具\n* <a href=\"https://github.com/OpenEmu/OpenEmu\">OpenEmu</a>\n超强的游戏模拟器, 做游戏开发必备, 官网做得也很不错\n* <a href=\"https://github.com/nicklockwood/iCarousel\">iCarousel</a>\n作者是英国 Charcoal Design 公司的创始人, 开源领域的贡献颇为卓著, 这个项目就是其中之一, 这是一款可以在 iOS 上实现旋转木马视图切换效果的第三方控件, 并提供多种切换效果\n* <a href=\"https://github.com/romaonthego/RESideMenu\">RESideMenu</a>\n作者 Roman Efimov 是雅虎的 iOS 工程师, 这个项目实现了 iOS 上的菜单侧滑效果, 创意来源于 Dribbble, 该项目支持 iOS8\n* <a href=\"https://github.com/kevinzhow/PNChart\">PNChart</a>\n作者周楷雯是 90 后, 秒视的创始人, 该项目是一个带动画效果的图表控件, 简约易用, 受到不少开发者喜爱\n* <a href=\"https://github.com/square/PonyDebugger\">PonyDebugger</a>\n由 Square 公司推出的一款优秀的 iOS 应用网络调试工具, 用户可以实时看到应用程序的网络请求, 也可以对 iOS 应用程序的核心数据栈进行远程调试\n* <a href=\"https://github.com/jverdi/JVFloatLabeledTextField\">JVFloatLabeledTextField</a>\n作者是 Thumb Labs 的联合创始人, JVFloatLabeledTextField 是 UITextField 的子类, 主要实现输入框标签浮动效果, 创作灵感来自 Dribbble, 已出现多个移植版本\n* <a href=\"https://github.com/CEWendel/SWTableViewCell\">SWTableViewCell</a>\nUITableViewCell 的子类, 实现了左右滑动显示信息视图并调出按钮\n* <a href=\"https://github.com/levey/AwesomeMenu\">AwesomeMenu</a>\n作者是一位中国人, 该项目主要是使用 CoreAnimation 还原了 Path menu 的动画效果\n* <a href=\"https://github.com/tonymillion/Reachability\">Reachability</a>\nReachablity 是用于检测 iOS 设备网络环境的库,Beeframeowrk中使用过的库\n* <a href=\"https://github.com/onevcat/VVDocumenter-Xcode\"> VVDocumenter-Xcode</a>\n作者是王巍国内著名的 iOS 开发者, 人称喵神, 目前在日本 LINE 公司工作, 该项目帮助开发者轻松的生成注释文档, 节省了不少工作量, 赞\n* <a href=\"https://github.com/google/physical-web\">The Physical Web</a>\n由 Chrome 团队主导的一个项目, 意在用 URL 连接世界, 方便用户接受数据, 目前尚处在实验阶段\n* <a href=\"https://github.com/samuelclay/NewsBlur\">NewsBlur</a>\n作者独自一个人 Samuel Clay 做出来的一款名为 NewsBlur 的新闻阅读器, 很多人都称其为 Google Reader 的替代品, 这是它的源码\n* <a href=\"https://github.com/cocos2d/cocos2d-objc\">Cocos2D-SpriteBuilder</a>\n一个可用于在 iOS, Mac 和 Android 上制作 2D 游戏或其它图形/交互应用的框架, 之前的项目名称为 Cocos Swift, 目前该项目在 GitHub 上更新较为频繁\n* <a href=\"https://github.com/TTTAttributedLabel/TTTAttributedLabel\">TTTAttributedLabel</a>\nUILabel 的替代品, 使 iOS 上的 Label 功能更加丰富, 可支持链接植入等功能\n* <a href=\"https://github.com/robbiehanson/CocoaAsyncSocket\">CocoaAsyncSocket</a>\n一个功能强大、简单易用的异步 socket 通讯类库, 支持 TCP 和 UDP 协议, 可用于 Mac 和 iOS 设备上, 作者 Robbie Hanson 是 Deusty 的首席软件工程师\n* <a href=\"https://github.com/devinross/tapkulibrary\">TapkuLibrary</a>\n作者是 Devin Ross, 这是在 iOS 上一款功能强大的 UI 效果类库, 可以实现多种酷炫的效果, 目前仍在更新中</a>\n* <a href=\"https://github.com/CanvasPod/Canvas\">Canvas</a>\n无需编码实现牛逼的动画效果的库, 连设计师都可以快速上手\n* <a href=\"https://github.com/square/SocketRocket\">SocketRocket</a>\nSquare 公司开源的一个 WebSocket 客户端, 稳定并且易用, 做实时应用常会用到, 受广大开发者喜爱\n* <a href=\"https://github.com/ECSlidingViewController/ECSlidingViewController\">ECSlidingViewController</a>\n一个视图控制器容器, 将子视图处理成两层, 通过滑动来处理层的切换, 创作灵感来自 Facebook 和 Path的 App, 作者是 Cleveland 的员工\n* <a href=\"https://github.com/stig/json-framework\">Json Framework</a>\n用于解析 JSON 数据的一个框架, 但是在 iOS5 以上版本大多数人都选择使用 NSJSONSerialization 来解析 JSON, 该项目现在在 GitHub 上也几乎没怎么更新了\n* <a href=\"https://github.com/facebook/Tweaks\">Tweaks</a>\nFacebook 开源的一款工具, 旨在帮助 iOS 开发者更快的迭代应用, 方便用户动态的调整参数, 是的, Paper 这个项目也用到了\n* <a href=\"https://github.com/realm/realm-cocoa\">realm-cocoa</a>\nRealm-Cocoa 是 Realm 公司推出一款移动端数据库, 可以运行在手机、平板和可穿戴设备之上, 其目标是取代 CoreData 和 SQLite 数据库\n* <a href=\"https://github.com/icanzilb/JSONModel\">JSONModel</a>\n一个能迅速解析服务器返回的 Json 数据的库, 方便数据的类型转换\n* <a href=\"https://github.com/facebook/KVOController\">KVOController</a>\n一个简单安全的 KVO(Key-value Observing, 键-值 观察)工具, 提供简单方便、线程安全的API, Facebook 的开源项目之一\n* <a href=\"https://github.com/mwaterfall/MWPhotoBrowser\">MWPhotoBrowser</a>\n一款简单的 iOS 照片浏览控件\n* <a href=\"https://github.com/samvermette/SVPullToRefresh\">SVPullToRefresh</a>\n<b>一款只需一行代码便可集成上拉刷新和下拉加载的组件</b>\n* <a href=\"https://github.com/facebook/pop\">POP</a>\nfacebook出品的paper，动画效果太好了，赶超apple的原生app一大截。pop就是paper的动画库！\n* <a href=\"https://github.com/dennisreimann/ioctocat\">ioctocat</a>\ngithub的iOS客户端，目前开源代码是V1版本，V2版本在appstore上可以下载\n* <a href=\"https://github.com/ChatSecure/ChatSecure-iOS\">ChatSecure</a>\n使用XMPP协议的IM开源软件，很强大，在appstore上可以下载\n* [FDFullscreenPopGesture](https://github.com/forkingdog/FDFullscreenPopGesture)\n一个丝滑的全屏滑动返回手势,相关博客文章点击[这里](http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/)\n* [TKSubmitTransition](https://github.com/Jvaeyhcd/TKSubmitTransition)\n非常漂亮的一个登录转场动画\n* [DZNEmptyDataSet](https://github.com/dzenbot/DZNEmptyDataSet)\n非常方便的对一些没有数据的UITableView或者UIScrollView加上提示图片和文字。\n\n* [iRate](https://github.com/nicklockwood/iRate)\n一个开源的评分控件，能够非常友好的设置提醒用户去评论我们的app\n\n* [iVersion](https://github.com/nicklockwood/iVersion)\n和iRate一样出自同一个人之手，，这个是提示用户更新版本。\n\n* [PureLayout](https://github.com/PureLayout/PureLayout)\n自动布局\n\n# 文本相关\n\n* [SlackTextViewController](https://github.com/slackhq/SlackTextViewController)\n你曾经用过Slack iOS应用吗？如果你在较大的软件公司工作，也许会用过。对那些没用过的人呢？—?Slack令人激动。用到Slack的应用也是这样，尤其是用作极佳、定制的文本输入控制时。这时你有了一个现成可用在应用中的代码。自适应文本区域？试一下。手势识别、自动填充、多媒体合并？试一下。快速drop-in解决方案？试一下。其他还想要什么？SlackTextViewController 可以替代 UITableViewController & UICollectionViewController。\n\n* [RTLabel](https://github.com/honcheng/RTLabel)\n用于显示html的Label\n\n* [Shimmer](https://github.com/facebook/Shimmer)\n滑动解锁效果的界面\n\n* [DDRichText](https://github.com/daiweilai/DDRichText)\n为图文混排提供了一个思路\n\n# 进度条\n\n* [NJKWebViewProgress](https://github.com/ninjinkun/NJKWebViewProgress)\nweb界面加载进度条\n\n* [MBProgressHUD](https://github.com/jdg/MBProgressHUD)\nMBProgressHUD 使用非常广泛，网上很多基于ta的封装\n\n* [SVProgressHUD](https://github.com/SVProgressHUD/SVProgressHUD)\nNavigation的扩展，强烈推荐\n\n* [Toast](https://github.com/scalessec/Toast)\n\n# 导航栏\n\n* [LTNavigationbar](https://github.com/ltebean/LTNavigationbar)\n上下滑动动态改变导航栏颜色\n\n* [JZNavigationExtension](https://github.com/JazysYu/JZNavigationExtension)\n\n# 键盘类\n\n* [IQKeyboardManager](https://github.com/hackiftekhar/IQKeyboardManager)\n\n* [TPKeyboardAvoiding](https://github.com/michaeltyson/TPKeyboardAvoiding)\n这个我用得很多，界面上如果有输入框可以界面会跟着键盘动，而不被键盘挡住。\n\n# 基础工具类以及Category\n\n* [BFKit OC版本](https://github.com/FabrizioBrancati/BFKit)\n国外的一个大神写的很好用的分类，比较齐全\n\n* [DateTools](https://github.com/MatthewYork/DateTools)\n很强大的日期工具类\n\n* [iOS-Categories](https://github.com/shaojiankui/iOS-Categories)\n很是全面的一个扩展 iOS中的各种objc Category, a collection of useful objc Categories extending iOS Frameworks such as Foundation,UIKit,CoreData,QuartzCore,CoreLocation,MapKit Etc.\n\n* [Material-Controls-For-iOS](https://github.com/fpt-software/Material-Controls-For-iOS)\n大神模仿谷歌做的iOS原生特效控件\n\n* [BlocksKit](https://github.com/zwaldowski/BlocksKit)\n为基础类提供Block支持，很好用\n\n# 弹出框\n\n* [STPopup](https://github.com/kevin0571/STPopup)\n很方便的弹出框\n\n* [MMPopupView](https://github.com/adad184/MMPopupView)\n里脊串的弹出框\n\n* [NYAlertViewController](https://github.com/nealyoung/NYAlertViewController)\n非常强大的弹出框\n\n* [TYAlertController](https://github.com/12207480/TYAlertController)\n很好很强大的弹出框，多种样式满足你的需求\n\n* [JKPopMenuView](https://github.com/UncleJoke/JKPopMenuView)\n一个简单的弹出菜单\n\n# 其它\n\n* [SWTableViewCell](https://github.com/CEWendel/SWTableViewCell)\n自定义侧滑\n\n* [MGSwipeTableCell](https://github.com/MortimerGoro/MGSwipeTableCell)\n同上自定义侧滑\n\n* [FDFullscreenPopGesture](https://github.com/forkingdog/FDFullscreenPopGesture)\n全屏滑动返回上级页面\n\n* [PDTSimpleCalendar](https://github.com/jivesoftware/PDTSimpleCalendar)\n一款日历控件，可以看看\n\n# Xcode插件\n\n* <a href=\"https://github.com/kattrali/cocoapods-xcode-plugin\">cocoapods-xcode-plugin</a>\nDependency management helper for your CocoaPods, right in Xcode.\n用于在Xcode中管理CocoaPods依赖库。\n![\"\"](http://wangzz.github.io/images/article1/plugin_cocoapods_menu.png)\n* <a href=\"https://github.com/qfish/XAlign\">XAlign</a>\nAn amazing Xcode plugin to align regular code. it can align Xnything in any way you want.\n方便实现代码对其功能，使代码风格统一。\n![\"\"](http://wangzz.github.io/images/article1/plugin_align.gif)\n* <a href=\"https://github.com/supermarin/Alcatraz\">Alcatraz</a>\nAlcatraz is an open-source package manager for Xcode 5+. It lets you discover and install plugins, templates and color schemes without the need for manually cloning or copying files. It installs itself as a part of Xcode and it feels like home.---Xcode插件管理工具。\n![\"\"](https://camo.githubusercontent.com/919efe4e1e53237df51d7010c862bd5c04fd6a70/687474703a2f2f616c63617472617a2e696f2f696d616765732f73637265656e73686f744032782e706e67)\n* <a href=\"https://github.com/onevcat/VVDocumenter-Xcode\">VVDocumenter-Xcode</a>\n提供了为代码增加注视的最快捷方式,非常好的Xcode插件。\n![\"\"](https://camo.githubusercontent.com/ca5518c9872e15b8a95b9d8c5f44bc331977d710/68747470733a2f2f7261772e6769746875622e636f6d2f6f6e65766361742f5656446f63756d656e7465722d58636f64652f6d61737465722f53637265656e53686f742e676966)\n并且支持了Swift的注释，太棒了！\n![\"\"](https://camo.githubusercontent.com/58e452b57245cd79c2e59ac7926609be4dffbfd8/68747470733a2f2f7261772e6769746875622e636f6d2f6f6e65766361742f5656446f63756d656e7465722d58636f64652f6d61737465722f7676646f63756d656e7465722d73776966742e676966)\n* <a href=\"https://github.com/ksuther/KSImageNamed-Xcode\">KSImageNamed-Xcode</a>\n当输入[NSImage imageNamed: 或者[UIImage imageNamed:时，会自动补全工程中可用的图片名称，同时能提供选中图片的预览。\n![\"\"](http://foggry.com/images/article1/plugin_image_named.gif)\n\n自己做个笔记，方便以后工作遇到问题能够得到快速的解决","slug":"Github上优秀的Objective-C项目简介","published":1,"updated":"2016-06-02T06:25:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcks002b29we3l5wt7s6"},{"title":"Failed to Locate or Generate Matchin Signing Assets","date":"2016-04-18T08:58:38.000Z","_content":"\n## 发现问题\n\n刚开始还是好好的，突然就出现了标题的提示错误，首先签名是正确的，App ID也没有被占用的，但是在导出ipa的时候一直出现“Failed to locate or generate matchin signing assets”的提示信息。我也是醉得不行，有时能成功，有时不行，不知道苹果在搞什么鬼（不管他在搞什么，出现问题，还是不要一味的去抱怨，找解决办法才是真的）。\n\n{% asset_img problem.png 问题详情%}\n\n<!-- more -->\n\n## 如何解决\n\n还是Google大法好，一下就找到了解决办法。\n\n以下是我在网上找到了解决办法的详细步骤：\n\n* 首先创建一个文件夹，名字就叫Payload，<a style=\"color:#4cc190\">一定要是Payload</a>（如果你不信，可以换一个名字试试）。\n\n* 然后在Organizer中然后把 archive 出来的那个在 finder 打开。\n{% asset_img export.png Organizer中显示%}\n\n* 然后点击显示包内容。\n{% asset_img show_in_finder.png 在Finder中显示%}\n\n* 把app 和 dsym 那两个文件拷贝到 Payload文件夹中。\n{% asset_img product.png product文件目录%}\n{% asset_img dSYMs.png dSYMs文件目录%}\n\n* 然后对Payload压缩\n{% asset_img zip.png Payload压缩%}\n\n* 最后将Playload.zip的后缀名改成ipa即可。\n\n以上的方法完全可以解决无法导出ipa的问题，但是导出ipa比export出来的包要大一些。","source":"_posts/Failed-to-locate-or-generate-matchin-signing-assets.md","raw":"---\ntitle: Failed to locate or generate matchin signing assets\ndate: 2016-04-18 16:58:38\ntags:\n---\n\n## 发现问题\n\n刚开始还是好好的，突然就出现了标题的提示错误，首先签名是正确的，App ID也没有被占用的，但是在导出ipa的时候一直出现“Failed to locate or generate matchin signing assets”的提示信息。我也是醉得不行，有时能成功，有时不行，不知道苹果在搞什么鬼（不管他在搞什么，出现问题，还是不要一味的去抱怨，找解决办法才是真的）。\n\n{% asset_img problem.png 问题详情%}\n\n<!-- more -->\n\n## 如何解决\n\n还是Google大法好，一下就找到了解决办法。\n\n以下是我在网上找到了解决办法的详细步骤：\n\n* 首先创建一个文件夹，名字就叫Payload，<a style=\"color:#4cc190\">一定要是Payload</a>（如果你不信，可以换一个名字试试）。\n\n* 然后在Organizer中然后把 archive 出来的那个在 finder 打开。\n{% asset_img export.png Organizer中显示%}\n\n* 然后点击显示包内容。\n{% asset_img show_in_finder.png 在Finder中显示%}\n\n* 把app 和 dsym 那两个文件拷贝到 Payload文件夹中。\n{% asset_img product.png product文件目录%}\n{% asset_img dSYMs.png dSYMs文件目录%}\n\n* 然后对Payload压缩\n{% asset_img zip.png Payload压缩%}\n\n* 最后将Playload.zip的后缀名改成ipa即可。\n\n以上的方法完全可以解决无法导出ipa的问题，但是导出ipa比export出来的包要大一些。","slug":"Failed-to-locate-or-generate-matchin-signing-assets","published":1,"updated":"2016-04-27T11:33:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcli002c29wecff1g36r"},{"title":"CocosPods使用过程中遇到的一些问题，以及解决办法","date":"2016-06-16T07:21:30.000Z","_content":"\n经常会遇到很多莫名其妙的问题，这次遇到了，下次可能依然还会遇到，常常因为自己没有做什么记录，所以下次遇到了还是不知道如何解决。所以在这里我想记录一些我在使用CocosPods的过程中遇到过的一些问题。\n\n## library not found for -lPods ##\n### 问题描述\n这是一个很奇葩的问题，我在使用Cocoapods管理项目，编译Debug运行没有任何问题，但是就是在Archive的时候，报错如下\n``` bash\nld: library not found for -lPods\n```\n<!-- more -->\n\n### 解决办法\n于是在网上搜索了一番找打了一篇帖子：http://www.cocoachina.com/bbs/read.php?tid-253614.html\n\n各种各样的回复都有，我最终的解决步骤如下：\n1. 更新cocospods到最新版本，注：gem的最新的镜像地址：https://gems.ruby-china.org/，淘宝的好像不能访问了。（也有说将版本降到0.37的，但是我是不想退步的，要用就用最新的）。\n2. 在Build Setting > Other Linker Flag 中删除所有，只留下$(inherited)轻松解决。 \n\n其实还有一个原因就是我的工程目录名称和Finder工程目录的文件夹不一致造成的。\n","source":"_posts/CocosPods使用过程中遇到的一些问题，以及解决办法.md","raw":"---\ntitle: CocosPods使用过程中遇到的一些问题，以及解决办法\ndate: 2016-06-16 15:21:30\ntags:\n---\n\n经常会遇到很多莫名其妙的问题，这次遇到了，下次可能依然还会遇到，常常因为自己没有做什么记录，所以下次遇到了还是不知道如何解决。所以在这里我想记录一些我在使用CocosPods的过程中遇到过的一些问题。\n\n## library not found for -lPods ##\n### 问题描述\n这是一个很奇葩的问题，我在使用Cocoapods管理项目，编译Debug运行没有任何问题，但是就是在Archive的时候，报错如下\n``` bash\nld: library not found for -lPods\n```\n<!-- more -->\n\n### 解决办法\n于是在网上搜索了一番找打了一篇帖子：http://www.cocoachina.com/bbs/read.php?tid-253614.html\n\n各种各样的回复都有，我最终的解决步骤如下：\n1. 更新cocospods到最新版本，注：gem的最新的镜像地址：https://gems.ruby-china.org/，淘宝的好像不能访问了。（也有说将版本降到0.37的，但是我是不想退步的，要用就用最新的）。\n2. 在Build Setting > Other Linker Flag 中删除所有，只留下$(inherited)轻松解决。 \n\n其实还有一个原因就是我的工程目录名称和Finder工程目录的文件夹不一致造成的。\n","slug":"CocosPods使用过程中遇到的一些问题，以及解决办法","published":1,"updated":"2016-06-17T06:37:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcm0002d29weow2h6e7f"},{"title":"CocoaPods的制作过程","date":"2016-07-08T09:14:00.000Z","_content":"\n最新项目不算太忙，于是抽出了一点时间将以前项目中的使用的AVPlayer视频播放器做了一个简单的封装。现在我想把它做成CocoaPods方便以后的使用。下面我要详细的记录下我的制作过程。\n\n### 创建仓库\n\n#### 本地仓库\n使用Xcode创建一个叫做HcdCachePlayer的工程，然后将相关的封装全部编写完毕。\n\n#### 远程仓库\n在github上同样创建一个`HcdCachePlayer`,最好保持同名,需要注意的是,在创建仓库的时候需要添加`license`类型,这里我使用`license`类型为`MIT`。这个很简单就不再啰嗦了。\n<!-- more -->\n#### 关联本地仓库到远程仓库\n进入本地仓库目录\n``` bash\ncd ~/github/HcdCachePlayer/\n```\n关联远程仓库\n``` bash\ngit init\ngit remote add origin https://github.com/Jvaeyhcd/HcdCachePlayer.git\ngit push -u origin master\n```\n\n### 添加Pods依赖库所需文件\n依赖库所需的文件格式为`{project}.podspec`格式，每个Pods依赖库必须有这个描述文件。\n\n#### 添加{project}.podspec文件\n\n使用pod命令创建\n``` bash\npod spec create HcdCachePlayer\n```\n这样就生成了HcdCachePlayer.podspec文件，打开该文件添加内容，并删除不需要的后就像这样：\n``` bash\nPod::Spec.new do |s|\n  s.name         = \"HcdCachePlayer\"\n  s.version      = \"0.0.1\"\n  s.summary      = \"一个带缓存的视频播放器HcdCachePlayer\"\n  s.description  = <<-DESC\n  一个使用AVPlayer封装的带缓存的视频播放器,支持全屏，可以左右滑动手势快进快退，上下滑动手势调节屏幕亮度\n                   DESC\n  s.homepage     = \"https://github.com/Jvaeyhcd/HcdCachePlayer\"\n  s.license      = { :type => \"MIT\", :file => \"LICENSE\" }\n  s.author             = { \"Jvaeyhcd\" => \"chedahuang@icloud.com\" }\n  s.platform     = :ios, '7.0'\n  s.source       = { :git => \"https://github.com/Jvaeyhcd/HcdCachePlayer.git\", :tag => s.version.to_s }\n  s.source_files  = \"hcdCachePlayer/**/*.{h,m}\"\n  s.resource  = \"hcdCachePlayer/hcdCachePlayer.bundle\"\n  s.frameworks = \"UIKit\", \"AVFoundation\", \"MobileCoreServices\", \"Foundation\"\n  s.requires_arc = true\n  s.dependency \"Masonry\"\nend\n\n```\ns.source_files指向循环滚动的核心代码放在项目的s.hcdCachePlayer/**/*.{h,m},所以这里最好将库代码都放在同一个目录下。\n\n### 提交到github\n此时编码已经完成了，并且配置好了相关文件我们可以先将代码提交到github上了。\n\n#### Pods验证\n提交之前我们需要先验证一下HcdCachePlayer.podspec文件。在HcdCachePlayer.podspec所在目录运行如下命令：\n``` bash\npod lib lint\n```\n如果出现ERROR和WARING都会失败，如果失败会明确指明哪个地方出错了，按提示修改就可以了。\n\n#### 提交代码到Github\n\n``` bash\ngit add .\ngit commit -m \"version 0.0.1\"\ngit push origin master\n```\n\n打上标签\n``` bash\ngit tag 0.0.1\ngit push --tags\n```\n不出问题的话,就可以在github上看到最新提交的内容了。\n\n### 上传{project}.podspec到CocoaPods官方仓库中\n要想一个HcdCachePlayer真正可以用,就得把生成的HcdCachePlayer.podspec文件提交到Cocoapods官方的[Specs](https://github.com/CocoaPods/Specs)仓库中,才能被search到并使用。\n\n> 之前的提交方式是先将[Specs](https://github.com/CocoaPods/Specs)仓库fork一份，添加修改，然后push，等待审核，这种显示是不安全的，所以现在不能使用了。也就是这篇文章：[《CocoaPods详解之----制作篇》](http://blog.csdn.net/wzzvictory/article/details/20067595)中说提到的方法，注意这个方法已经不能使用了。\n\nCocoaPods为我们提供了另外一个更加安全的方法[Trunk](http://blog.cocoapods.org/CocoaPods-Trunk/#transition)。\n\n#### Trunk的Register\n如果第一次使用的话那么就需要注册了，需要CocoaPods0.33版本以上才支持\n``` bash\npod trunk register *youremail* *yourname* --description='iMac' --verbose\n```\n以上命令是注册所需的,替换你的邮箱,用户名,以及描述内容, --verbose可以输入详细的debug。\n\n注册完成后可以使用一下命令查看注册信息\n``` bash\npod trunk me\n```\n#### 提交{project}.podspec\n在{project}.podspec文件的路径下执行\n``` bash\npod trunk push HcdCachePlayer.podspec\n```\n这条命令做了如下三件事:\n* 验证本地的podspec文件,也可以使用 pod lib lint验证\n* 上传podspec文件到trunk服务\n* 将{project}.podspec文件转为{poject}.podspec.json文件\n\n如果没有报错那么就成功了。\n\n#### 使用\n终端执行 pod search HcdCachePlayer就可以找到了,如果没有找到 pod setup再试一下。\n``` bash\n-> HcdCachePlayer (0.0.1)\n   一个带缓存的视频播放器HcdCachePlayer\n   pod 'HcdCachePlayer', '~> 0.0.1'\n   - Homepage: https://github.com/Jvaeyhcd/HcdCachePlayer\n   - Source:   https://github.com/Jvaeyhcd/HcdCachePlayer.git\n   - Versions: 0.0.1 [master repo]\n(END)\n```\n> 这里遇到一个问题创建成功了，但是另外一台电脑却收不到。\n\n#### 协同工作\n当需要其他人来共同维护你的代码,需要提供权限。\n``` bash\npod trunk add-owner HcdCachePlayer *email*\n```\n\n参考文章：\n\n[CocoaPods 详解之----更新篇](http://foggry.com/blog/2016/03/23/cocoapods-xiang-jie-zhi-geng-xin-pian/)\n","source":"_posts/CocoaPods的制作过程.md","raw":"---\ntitle: CocoaPods的制作过程\ndate: 2016-07-08 17:14:00\ntags:\n  - CocoaPods\n---\n\n最新项目不算太忙，于是抽出了一点时间将以前项目中的使用的AVPlayer视频播放器做了一个简单的封装。现在我想把它做成CocoaPods方便以后的使用。下面我要详细的记录下我的制作过程。\n\n### 创建仓库\n\n#### 本地仓库\n使用Xcode创建一个叫做HcdCachePlayer的工程，然后将相关的封装全部编写完毕。\n\n#### 远程仓库\n在github上同样创建一个`HcdCachePlayer`,最好保持同名,需要注意的是,在创建仓库的时候需要添加`license`类型,这里我使用`license`类型为`MIT`。这个很简单就不再啰嗦了。\n<!-- more -->\n#### 关联本地仓库到远程仓库\n进入本地仓库目录\n``` bash\ncd ~/github/HcdCachePlayer/\n```\n关联远程仓库\n``` bash\ngit init\ngit remote add origin https://github.com/Jvaeyhcd/HcdCachePlayer.git\ngit push -u origin master\n```\n\n### 添加Pods依赖库所需文件\n依赖库所需的文件格式为`{project}.podspec`格式，每个Pods依赖库必须有这个描述文件。\n\n#### 添加{project}.podspec文件\n\n使用pod命令创建\n``` bash\npod spec create HcdCachePlayer\n```\n这样就生成了HcdCachePlayer.podspec文件，打开该文件添加内容，并删除不需要的后就像这样：\n``` bash\nPod::Spec.new do |s|\n  s.name         = \"HcdCachePlayer\"\n  s.version      = \"0.0.1\"\n  s.summary      = \"一个带缓存的视频播放器HcdCachePlayer\"\n  s.description  = <<-DESC\n  一个使用AVPlayer封装的带缓存的视频播放器,支持全屏，可以左右滑动手势快进快退，上下滑动手势调节屏幕亮度\n                   DESC\n  s.homepage     = \"https://github.com/Jvaeyhcd/HcdCachePlayer\"\n  s.license      = { :type => \"MIT\", :file => \"LICENSE\" }\n  s.author             = { \"Jvaeyhcd\" => \"chedahuang@icloud.com\" }\n  s.platform     = :ios, '7.0'\n  s.source       = { :git => \"https://github.com/Jvaeyhcd/HcdCachePlayer.git\", :tag => s.version.to_s }\n  s.source_files  = \"hcdCachePlayer/**/*.{h,m}\"\n  s.resource  = \"hcdCachePlayer/hcdCachePlayer.bundle\"\n  s.frameworks = \"UIKit\", \"AVFoundation\", \"MobileCoreServices\", \"Foundation\"\n  s.requires_arc = true\n  s.dependency \"Masonry\"\nend\n\n```\ns.source_files指向循环滚动的核心代码放在项目的s.hcdCachePlayer/**/*.{h,m},所以这里最好将库代码都放在同一个目录下。\n\n### 提交到github\n此时编码已经完成了，并且配置好了相关文件我们可以先将代码提交到github上了。\n\n#### Pods验证\n提交之前我们需要先验证一下HcdCachePlayer.podspec文件。在HcdCachePlayer.podspec所在目录运行如下命令：\n``` bash\npod lib lint\n```\n如果出现ERROR和WARING都会失败，如果失败会明确指明哪个地方出错了，按提示修改就可以了。\n\n#### 提交代码到Github\n\n``` bash\ngit add .\ngit commit -m \"version 0.0.1\"\ngit push origin master\n```\n\n打上标签\n``` bash\ngit tag 0.0.1\ngit push --tags\n```\n不出问题的话,就可以在github上看到最新提交的内容了。\n\n### 上传{project}.podspec到CocoaPods官方仓库中\n要想一个HcdCachePlayer真正可以用,就得把生成的HcdCachePlayer.podspec文件提交到Cocoapods官方的[Specs](https://github.com/CocoaPods/Specs)仓库中,才能被search到并使用。\n\n> 之前的提交方式是先将[Specs](https://github.com/CocoaPods/Specs)仓库fork一份，添加修改，然后push，等待审核，这种显示是不安全的，所以现在不能使用了。也就是这篇文章：[《CocoaPods详解之----制作篇》](http://blog.csdn.net/wzzvictory/article/details/20067595)中说提到的方法，注意这个方法已经不能使用了。\n\nCocoaPods为我们提供了另外一个更加安全的方法[Trunk](http://blog.cocoapods.org/CocoaPods-Trunk/#transition)。\n\n#### Trunk的Register\n如果第一次使用的话那么就需要注册了，需要CocoaPods0.33版本以上才支持\n``` bash\npod trunk register *youremail* *yourname* --description='iMac' --verbose\n```\n以上命令是注册所需的,替换你的邮箱,用户名,以及描述内容, --verbose可以输入详细的debug。\n\n注册完成后可以使用一下命令查看注册信息\n``` bash\npod trunk me\n```\n#### 提交{project}.podspec\n在{project}.podspec文件的路径下执行\n``` bash\npod trunk push HcdCachePlayer.podspec\n```\n这条命令做了如下三件事:\n* 验证本地的podspec文件,也可以使用 pod lib lint验证\n* 上传podspec文件到trunk服务\n* 将{project}.podspec文件转为{poject}.podspec.json文件\n\n如果没有报错那么就成功了。\n\n#### 使用\n终端执行 pod search HcdCachePlayer就可以找到了,如果没有找到 pod setup再试一下。\n``` bash\n-> HcdCachePlayer (0.0.1)\n   一个带缓存的视频播放器HcdCachePlayer\n   pod 'HcdCachePlayer', '~> 0.0.1'\n   - Homepage: https://github.com/Jvaeyhcd/HcdCachePlayer\n   - Source:   https://github.com/Jvaeyhcd/HcdCachePlayer.git\n   - Versions: 0.0.1 [master repo]\n(END)\n```\n> 这里遇到一个问题创建成功了，但是另外一台电脑却收不到。\n\n#### 协同工作\n当需要其他人来共同维护你的代码,需要提供权限。\n``` bash\npod trunk add-owner HcdCachePlayer *email*\n```\n\n参考文章：\n\n[CocoaPods 详解之----更新篇](http://foggry.com/blog/2016/03/23/cocoapods-xiang-jie-zhi-geng-xin-pian/)\n","slug":"CocoaPods的制作过程","published":1,"updated":"2016-07-08T10:25:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcm3002e29wetchpue6b"},{"title":"CocoaPods安装和使用教程","date":"2016-02-20T01:14:02.000Z","_content":"\n## CocosPods是什么\n\nCocoaPods是iOS项目的依赖管理工具，该项目源码在Github上管理。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和第三方开源库的时间。\n在使用CocoaPods之前，开发项目需要用到第三方开源库的时候，我们需要\n1.把开源库的源代码复制到项目中\n2.添加一些依赖框架和动态库\n3.设置-ObjC，-fno-objc-arc等参数\n4.管理他们的更新\n在使用CocoaPods后，我们只需要把用到的开源库放到一个名为Podfile的文件中，然后执行pod install.Cocoapods就会自动将这些第三方开源库的源码下载下来，并且为我们的工程设置好响应的系统依赖和编译参数。\n\n<!-- more -->\n\n## CocoaPods的原理##\n\nCocoaPods的原理是将所有的依赖库都放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。\n\n## CocoaPods的安装##\n\nCocoaPods可以方便地通过Mac自带的RubyGems安装。\n打开Terminal，然后键入以下命令：\n``` bash\n$ sudo gem install cocoapods\n```\n执行完这句如果报告以下错误：\n``` bash\nERROR: Could not find a valid gem 'cocoapods' (>= 0), here is why:\nUnable to download data from https://rubygems.org/ - Errno::ETIMEDOUT: Operation timed out - connect(2) (https://rubygems.org/latest_specs.4.8.gz)\nERROR: Possible alternatives: cocoapods\n```\n这是因为ruby的软件源rubygems.org因为使用亚马逊的云服务，被我天朝屏蔽了，需要更新一下ruby的源，过程如下：\n``` bash\n$ gem sources -l (查看当前ruby的源)\n$ gem sources --remove https://rubygems.org/\n$ gem sources -a https://ruby.taobao.org/\n$ gem sources -l\n```\n如果gem太老，可以尝试用如下命令升级gem\n``` bash\n$ sudo gem update --system\n```\n升级成功后会提示: RubyGems system software updated\n\n然后重新执行安装下载命令\n``` bash\n$ sudo gem install cocoapods\n```\n这时候应该没什么问题了\n\n接下来进行安装，执行：\n``` bash\n$ pod setup\n```\nTerminal会停留在 Setting up CocoaPods master repo 这个状态一段时间,是因为要进行下载安装,而且目录比较大,需要耐心等待一下.如果想加快速度,可使用cocoapods的镜像索引.（文章末尾附使用镜像索引的方法）\n\n## Cocoapods的使用\n\n进入工程所在的目录（工程根目录）\n执行命令 touch Podfile\n这句是说新建一个名为Podfile的文件（不能写成别的名字，也可以自己在工程根目录里面直接新建）\n\n然后对改文件进行编辑，执行命令 open -e Podfile\n第一次执行这个命令,会有一个空白文件打开，可以先放在一边，\nPodfile文件的格式应该如下：\n``` bash\nplatform :ios, '7.0'\npod 'AMap2DMap', '~> 2.5.0'\npod 'AFNetworking', '~> 2.5.3'\npod 'SDWebImage', '~> 3.7.2'\n```\n需要注意的几点：platform那一行，ios三个字母都要小写，而且与前面的冒号之间不能有间隔，后面的版本号也可以不写，但是有些开源库对版本是有要求的，比如要在6.0以上才能运行，遇到这样的开源库就需要写上版本号。\n\nplatform下面就是Cocoapods需要集成的开源库，根据你的需要确定集成那些库。\n\n举个例子：\n我要集成AFNetworking这个库类，需要在Cocoapods里面先搜索是否有需要的库，可以在Terminal中输入：\n``` bash\npod search AFNetworking\n```\n回车之后就可以看到和你搜索的关键字相关的一些库类。\n\n其中第一个就是我们需要的，把pod ‘AFNetworking’， ‘~>2.5.3’\n那一行复制到我们的Podfile文件中，保存修改。\n然后在Terminal中执行 ：\n``` bash\npod install\n```\n这样，AFNetworking就已经下载完成并且设置好了编译参数和依赖，以后使用的时候切记如下两点：\n1.从此以后需要使用Cocoapods生成的 .xcworkspace文件来打开工程，而不是使用以前的.xcodeproj文件\n2.每次更改了Podfile文件，都需要重新执行一次pod update命令\n\nps:当执行pod install之后，除了Podfile，还会生成一个名为Podfile.lock的文件，它会锁定当前各依赖库的版本，之后即使多次执行pod install也不会更改版本，只有执行pod update才会改变Podfile.lock.在多人协作的时候，这样可以防止第三方库升级时候造成大家各自的第三方库版本不一致。所以在提交版本的时候不能把它落下，也不要添加到.gitignore中.\n","source":"_posts/CocoaPods安装和使用教程.md","raw":"---\ntitle: CocoaPods安装和使用教程\ndate: 2016-02-20 09:14:02\ntags:\n---\n\n## CocosPods是什么\n\nCocoaPods是iOS项目的依赖管理工具，该项目源码在Github上管理。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和第三方开源库的时间。\n在使用CocoaPods之前，开发项目需要用到第三方开源库的时候，我们需要\n1.把开源库的源代码复制到项目中\n2.添加一些依赖框架和动态库\n3.设置-ObjC，-fno-objc-arc等参数\n4.管理他们的更新\n在使用CocoaPods后，我们只需要把用到的开源库放到一个名为Podfile的文件中，然后执行pod install.Cocoapods就会自动将这些第三方开源库的源码下载下来，并且为我们的工程设置好响应的系统依赖和编译参数。\n\n<!-- more -->\n\n## CocoaPods的原理##\n\nCocoaPods的原理是将所有的依赖库都放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。\n\n## CocoaPods的安装##\n\nCocoaPods可以方便地通过Mac自带的RubyGems安装。\n打开Terminal，然后键入以下命令：\n``` bash\n$ sudo gem install cocoapods\n```\n执行完这句如果报告以下错误：\n``` bash\nERROR: Could not find a valid gem 'cocoapods' (>= 0), here is why:\nUnable to download data from https://rubygems.org/ - Errno::ETIMEDOUT: Operation timed out - connect(2) (https://rubygems.org/latest_specs.4.8.gz)\nERROR: Possible alternatives: cocoapods\n```\n这是因为ruby的软件源rubygems.org因为使用亚马逊的云服务，被我天朝屏蔽了，需要更新一下ruby的源，过程如下：\n``` bash\n$ gem sources -l (查看当前ruby的源)\n$ gem sources --remove https://rubygems.org/\n$ gem sources -a https://ruby.taobao.org/\n$ gem sources -l\n```\n如果gem太老，可以尝试用如下命令升级gem\n``` bash\n$ sudo gem update --system\n```\n升级成功后会提示: RubyGems system software updated\n\n然后重新执行安装下载命令\n``` bash\n$ sudo gem install cocoapods\n```\n这时候应该没什么问题了\n\n接下来进行安装，执行：\n``` bash\n$ pod setup\n```\nTerminal会停留在 Setting up CocoaPods master repo 这个状态一段时间,是因为要进行下载安装,而且目录比较大,需要耐心等待一下.如果想加快速度,可使用cocoapods的镜像索引.（文章末尾附使用镜像索引的方法）\n\n## Cocoapods的使用\n\n进入工程所在的目录（工程根目录）\n执行命令 touch Podfile\n这句是说新建一个名为Podfile的文件（不能写成别的名字，也可以自己在工程根目录里面直接新建）\n\n然后对改文件进行编辑，执行命令 open -e Podfile\n第一次执行这个命令,会有一个空白文件打开，可以先放在一边，\nPodfile文件的格式应该如下：\n``` bash\nplatform :ios, '7.0'\npod 'AMap2DMap', '~> 2.5.0'\npod 'AFNetworking', '~> 2.5.3'\npod 'SDWebImage', '~> 3.7.2'\n```\n需要注意的几点：platform那一行，ios三个字母都要小写，而且与前面的冒号之间不能有间隔，后面的版本号也可以不写，但是有些开源库对版本是有要求的，比如要在6.0以上才能运行，遇到这样的开源库就需要写上版本号。\n\nplatform下面就是Cocoapods需要集成的开源库，根据你的需要确定集成那些库。\n\n举个例子：\n我要集成AFNetworking这个库类，需要在Cocoapods里面先搜索是否有需要的库，可以在Terminal中输入：\n``` bash\npod search AFNetworking\n```\n回车之后就可以看到和你搜索的关键字相关的一些库类。\n\n其中第一个就是我们需要的，把pod ‘AFNetworking’， ‘~>2.5.3’\n那一行复制到我们的Podfile文件中，保存修改。\n然后在Terminal中执行 ：\n``` bash\npod install\n```\n这样，AFNetworking就已经下载完成并且设置好了编译参数和依赖，以后使用的时候切记如下两点：\n1.从此以后需要使用Cocoapods生成的 .xcworkspace文件来打开工程，而不是使用以前的.xcodeproj文件\n2.每次更改了Podfile文件，都需要重新执行一次pod update命令\n\nps:当执行pod install之后，除了Podfile，还会生成一个名为Podfile.lock的文件，它会锁定当前各依赖库的版本，之后即使多次执行pod install也不会更改版本，只有执行pod update才会改变Podfile.lock.在多人协作的时候，这样可以防止第三方库升级时候造成大家各自的第三方库版本不一致。所以在提交版本的时候不能把它落下，也不要添加到.gitignore中.\n","slug":"CocoaPods安装和使用教程","published":1,"updated":"2016-06-02T04:27:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcm6002h29wempzhpcos"},{"title":"Block正确使用避免Cycle Retain和Crash","date":"2016-02-24T01:28:26.000Z","_content":"\n>本文只介绍了MRC时的情况，有些细节不适用于ARC。比如MRC下__block不会增加引用计数，但ARC会，ARC下必须用__weak指明不增加引用计数；ARC下block内存分配机制也与MRC不一样，所以文中的一些例子在ARC下测试结果可能与文中描述的不一样\n\n## Block简介\n\nBlock作为C语言的扩展，并不是高新技术，和其他语言的闭包或lambda表达式是一回事。需要注意的是由于objc在iOS中不支持GC机制，使用Block必须自己管理内存，而内存管理正是使用Block坑最多的地方，错误的内存管理 要么导致return cycle内存泄漏要么内存被提前释放导致crash。 Block的使用很像函数指针，不过与函数最大的不同是：Block可以访问函数以外、词法作用域以内的外部变量的值。换句话说，Block不仅 实现函数的功能，还能携带函数的执行环境。\n\n可以这样理解，Block其实包含两个部分内容\n\n* Block执行的代码，这是在编译的时候已经生成好的；\n* 一个包含Block执行时需要的所有外部变量值的数据结构。 Block将使用到的、作用域附近到的变量的值建立一份快照拷贝到栈上。\n\nBlock与函数另一个不同是，Block类似ObjC的对象，可以使用自动释放池管理内存（但Block并不完全等同于ObjC对象，后面将详细说明）。\n\n<!-- more -->\n\n## Block基本语法\n\n``` objc\n// 声明一个Block变量\nlong (^sum) (int, int) = nil;\n// sum是个Block变量，该Block类型有两个int型参数，返回类型是long。\n\n// 定义Block并赋给变量sum\nsum = ^ long (int a, int b) {\n  return a + b;\n};\n\n// 调用Block：\nlong s = sum(1, 2);\n```\n定义一个实例函数，该函数返回Block：\n``` objc\n- (long (^)(int, int)) sumBlock {\n    int base = 100;\n    return [[ ^ long (int a, int b) {\n      return base + a + b;\n    } copy] autorelease];\n  }\n\n// 调用Block\n[self sumBlock](1,2);\n```\n是不是感觉很怪？为了看的舒服，我们把Block类型typedef一下\n``` objc\ntypedef long (^BlkSum)(int, int);\n\n- (BlkSum) sumBlock {\n    int base = 100;\n    BlkSum blk = ^ long (int a, int b) {\n      return base + a + b;\n    }\n    return [[blk copy] autorelease];\n}\n\n```\n## Block在内存中的位置\n\n根据Block在内存中的位置分为三种类型NSGlobalBlock，NSStackBlock, NSMallocBlock。\n* NSGlobalBlock：类似函数，位于text段；\n* NSStackBlock：位于栈内存，函数返回后Block将无效；\n* NSMallocBlock：位于堆内存。\n\n来看下面一段代码\n``` objc\nBlkSum blk1 = ^ long (int a, int b) {\n  return a + b;\n};\nNSLog(@\"blk1 = %@\", blk1);// blk1 = <__NSGlobalBlock__: 0x47d0>\n\n\nint base = 100;\nBlkSum blk2 = ^ long (int a, int b) {\n  return base + a + b;\n};\nNSLog(@\"blk2 = %@\", blk2); // blk2 = <__NSStackBlock__: 0xbfffddf8>\n\nBlkSum blk3 = [[blk2 copy] autorelease];\nNSLog(@\"blk3 = %@\", blk3); // blk3 = <__NSMallocBlock__: 0x902fda0>\n```\n为什么blk1类型是NSGlobalBlock，而blk2类型是NSStackBlock？blk1和blk2的区别在于，blk1没有使用Block以外的任何外部变量，Block不需要建立局部变量值的快照，这使blk1与函数没有任何区别，从blk1所在内存地址0x47d0猜测编译器把blk1放到了text代码段。blk2与blk1唯一不同是的使用了局部变量base，在定义（注意是定义，不是运行）blk2时，局部变量base当前值被copy到栈上，作为常量供Block使用。执行下面代码，结果是203，而不是204。\n``` objc\nint base = 100;\nbase += 100;\nBlkSum sum = ^ long (int a, int b) {\n    return base + a + b;\n};\nbase++;\nprintf(\"%ld\",sum(1,2));\n```\n\n>在Block内变量base是只读的，如果想在Block内改变base的值，在定义base时要用 __block修饰：__block int base = 100;\n\n``` objc\n__block int base = 100;\nbase += 100;\nBlkSum sum = ^ long (int a, int b) {\n    base += 10;\n    return base + a + b;\n};\nbase++;\nprintf(\"%ld\\n\",sum(1,2));\nprintf(\"%d\\n\",base);\n```\n上方的代码输出将是214,211。Block中使用__block修饰的变量时，将取变量此刻运行时的值，而不是定义时的快照。这个例子中，执行sum(1,2)时，base将取base++之后的值，也就是201，再执行Blockbase+=10; base+a+b，运行结果是214。执行完Block时，base已经变成211了。\n\n## Block的copy、retain、release操作\n\n不同于NSObjec的copy、retain、release操作：\n* Block_copy与copy等效，Block_release与release等效；\n* 对Block不管是retain、copy、release都不会改变引用计数retainCount，retainCount始终是1；\n* NSGlobalBlock：retain、copy、release操作都无效；\n* NSStackBlock：retain、release操作无效，必须注意的是，NSStackBlock在函数返回后，Block内存将被回收。即使retain也没用。容易犯的错误是[[mutableAarry addObject:stackBlock]，在函数出栈后，从mutableAarry中取到的stackBlock已经被回收，变成了野指针。正确的做法是先将stackBlock copy到堆上，然后加入数组：[mutableAarry addObject:[[stackBlock copy] autorelease]]。支持copy，copy之后生成新的NSMallocBlock类型对象。\n* NSMallocBlock支持retain、release，虽然retainCount始终是1，但内存管理器中仍然会增加、减少计数。copy之后不会生成新的对象，只是增加了一次引用，类似retain；\n* 尽量不要对Block使用retain操作。\n\n## Block对不同类型的变量的存取\n\n** 基本类型 **\n* 局部自动变量，在Block中只读。Block定义时copy变量的值，在Block中作为常量使用，所以即使变量的值在Block外改变，也不影响他在Block中的值。\n``` objc\nint base = 100;\nBlkSum sum = ^ long (int a, int b) {\n  // base++; 编译错误，只读\n  return base + a + b;\n};\nbase = 0;\nprintf(\"%ld\\n\",sum(1,2)); // 这里输出是103，而不是3\n```\n* static变量、全局变量。如果把上个例子的base改成全局的、或static。Block就可以对他进行读写了。因为全局变量或静态变量在内存中的地址是固定的，Block在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量。\n如下所示的一段代码输出结果是0 3 1，表明Block外部对base的更新会影响Block中的base的取值，同样Block对base的更新也会影响Block外部的base值。\n``` objc\nstatic int base = 100;\nBlkSum sum = ^ long (int a, int b) {\n  base++;\n  return base + a + b;\n};\nbase = 0;\nprintf(\"%d\\n\", base);\nprintf(\"%ld\\n\",sum(1,2)); // 这里输出是3，而不是103\nprintf(\"%d\\n\", base);\n```\n\n* Block变量，被__block修饰的变量称作Block变量。 基本类型的Block变量等效于全局变量、或静态变量。Block被另一个Block使用时，另一个Block被copy到堆上时，被使用的Block也会被copy。但作为参数的Block是不会发生copy的。\n``` objc\nvoid foo() {\n  int base = 100;\n  BlkSum blk = ^ long (int a, int b) {\n    return  base + a + b;\n  };\n  NSLog(@\"%@\", blk); // <__NSStackBlock__: 0xbfffdb40>\n  bar(blk);\n}\n\nvoid bar(BlkSum sum_blk) {\n  NSLog(@\"%@\",sum_blk); // 与上面一样，说明作为参数传递时，并不会发生copy\n\n  void (^blk) (BlkSum) = ^ (BlkSum sum) {\n    NSLog(@\"%@\",sum);     // 无论blk在堆上还是栈上，作为参数的Block不会发生copy。\n    NSLog(@\"%@\",sum_blk); // 当blk copy到堆上时，sum_blk也被copy了一分到堆上上。\n  };\n  blk(sum_blk); // blk在栈上\n\n  blk = [[blk copy] autorelease];\n  blk(sum_blk); // blk在堆上\n}\n```\n\n* ObjC对象，不同于基本类型，Block会引起对象的引用计数变化。\n先看下面代码\n执行结果为1 1 1 2 1。\n__globalObj和__staticObj在内存中的位置是确定的，所以Block copy时不会retain对象。\n_instanceObj在Block copy时也没有直接retain _instanceObj对象本身，但会retain self。所以在Block中可以直接读写_instanceObj变量。\nlocalObj在Block copy时，系统自动retain对象，增加其引用计数。\nblockObj在Block copy时也不会retain。\n``` objc\n@interface MyClass : NSObject {\n    NSObject* _instanceObj;\n}\n@end\n\n@implementation MyClass\n\nNSObject* __globalObj = nil;\n\n- (id) init {\n    if (self = [super init]) {\n        _instanceObj = [[NSObject alloc] init];\n    }\n    return self;\n}\n\n- (void) test {\n    static NSObject* __staticObj = nil;\n    __globalObj = [[NSObject alloc] init];\n    __staticObj = [[NSObject alloc] init];\n\n    NSObject* localObj = [[NSObject alloc] init];\n    __block NSObject* blockObj = [[NSObject alloc] init];\n\n    typedef void (^MyBlock)(void) ;\n    MyBlock aBlock = ^{\n        NSLog(@\"%@\", __globalObj);\n        NSLog(@\"%@\", __staticObj);\n        NSLog(@\"%@\", _instanceObj);\n        NSLog(@\"%@\", localObj);\n        NSLog(@\"%@\", blockObj);\n    };\n    aBlock = [[aBlock copy] autorelease];\n    aBlock();\n\n    NSLog(@\"%d\", [__globalObj retainCount]);\n    NSLog(@\"%d\", [__staticObj retainCount]);\n    NSLog(@\"%d\", [_instanceObj retainCount]);\n    NSLog(@\"%d\", [localObj retainCount]);\n    NSLog(@\"%d\", [blockObj retainCount]);\n}\n@end\n\nint main(int argc, char *argv[]) {\n    @autoreleasepool {\n        MyClass* obj = [[[MyClass alloc] init] autorelease];\n        [obj test];\n        return 0;\n    }\n}\n```\n* 非ObjC对象，如GCD队列dispatch_queue_t。Block copy时并不会自动增加他的引用计数，这点要非常小心。\n\n## Block中使用的ObjC对象的行为\n\n``` objc\n@property (nonatomic, copy) void(^myBlock)(void);\n\nMyClass* obj = [[[MyClass alloc] init] autorelease];\nself.myBlock = ^ {\n  [obj doSomething];\n};\n```\n对象obj在Block被copy到堆上的时候自动retain了一次。因为Block不知道obj什么时候被释放，为了不在Block使用obj前被释放，Block retain了obj一次，在Block被释放的时候，obj被release一次。\n\n## retain cycle\n\nretain cycle问题的根源在于Block和obj可能会互相强引用，互相retain对方，这样就导致了retain cycle，最后这个Block和obj就变成了孤岛，谁也释放不了谁。比如：\n``` objc\nASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];\n[request setCompletionBlock:^{\n  NSString* string = [request responseString];\n}];\n```\n``` bash\n       +-----------+           +-----------+\n       | request   |           |   Block   |\n  ---> |           | --------> |           |\n       | retain 2  | <-------- | retain 1  |\n       |           |           |           |\n       +-----------+           +-----------+\n```\n解决这个问题的办法是使用弱引用打断retain cycle：\n``` objc\n__block ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];\n[request setCompletionBlock:^{\n  NSString* string = [request responseString];\n}];\n```\n``` bash\n      +-----------+           +-----------+\n      | request   |           |   Block   |\n ---->|           | --------> |           |\n      | retain 1  | < - - - - | retain 1  |\n      |           |   weak    |           |\n      +-----------+           +-----------+\n```\nrequest被持有者释放后。request 的retainCount变成0,request被dealloc，request释放持有的Block，导致Block的retainCount变成0，也被销毁。这样这两个对象内存都被回收。\n``` bash\n      +-----------+           +-----------+\n      | request   |           |   Block   |\n --X->|           | ----X---> |           |\n      | retain 0  | < - - - - | retain 0  |\n      |           |   weak    |           |\n      +-----------+           +-----------+\n```\n与上面情况类似的陷阱：\n``` objc\nself.myBlock = ^ {\n  [self doSomething];\n};\n```\n这里self和myBlock循环引用，解决办法同上：\n``` objc\n__block MyClass* weakSelf = self;\nself.myBlock = ^ {\n  [weakSelf doSomething];\n};\n```\n``` objc\n@property (nonatomic, retain) NSString* someVar;\n\nself.myBlock = ^ {\n  NSLog(@\"%@\", _someVer);\n};\n```\n这里在Block中虽然没直接使用self，但使用了成员变量。在Block中使用成员变量，retain的不是这个变量，而会retain self。解决办法也和上面一样。\n``` objc\n@property (nonatomic, retain) NSString* someVar;\n\n__block MyClass* weakSelf = self;\nself.myBlock = ^ {\n  NSLog(@\"%@\", self.someVer);\n};\n```\n或者\n``` objc\nNSString* str = _someVer;\nself.myBlock = ^ {\n  NSLog(@\"%@\", str);\n};\n```\nretain cycle不只发生在两个对象之间，也可能发生在多个对象之间，这样问题更复杂，更难发现\n``` objc\nClassA* objA = [[[ClassA alloc] init] autorelease];\nobjA.myBlock = ^{\n    [self doSomething];\n};\nself.objA = objA;\n```\n``` bash\n  +-----------+           +-----------+           +-----------+\n  |   self    |           |   objA    |           |   Block   |\n  |           | --------> |           | --------> |           |\n  | retain 1  |           | retain 1  |           | retain 1  |\n  |           |           |           |           |           |\n  +-----------+           +-----------+           +-----------+\n       ^                                                |\n       |                                                |\n       +------------------------------------------------+\n```\n解决办法同样是用__block打破循环引用\n``` objc\nClassA* objA = [[[ClassA alloc] init] autorelease];\n\nMyClass* weakSelf = self;\nobjA.myBlock = ^{\n  [weakSelf doSomething];\n};\nself.objA = objA;\n```\n>注意：MRC中__block是不会引起retain；但在ARC中__block则会引起retain。ARC中应该使用__weak或__unsafe_unretained弱引用。__weak只能在iOS5以后使用。\n\n## Block使用对象被提前释放\n看下面例子，有这种情况，如果不只是request持有了Block，另一个对象也持有了Block。\n``` bash\n      +-----------+           +-----------+\n      | request   |           |   Block   |   objA\n ---->|           | --------> |           |<--------\n      | retain 1  | < - - - - | retain 2  |\n      |           |   weak    |           |\n      +-----------+           +-----------+\n```\n这时如果request 被持有者释放。\n``` bash\n      +-----------+           +-----------+\n      | request   |           |   Block   |   objA\n --X->|           | --------> |           |<--------\n      | retain 0  | < - - - - | retain 1  |\n      |           |   weak    |           |\n      +-----------+           +-----------+\n```\n这时request已被完全释放，但Block仍被objA持有，没有释放，如果这时触发了Block，在Block中将访问已经销毁的request，这将导致程序crash。为了避免这种情况，开发者必须要注意对象和Block的生命周期。\n\n另一个常见错误使用是，开发者担心retain cycle错误的使用__block。比如\n``` objc\n__block kkProducView* weakSelf = self;\ndispatch_async(dispatch_get_main_queue(), ^{\n  weakSelf.xx = xx;\n});\n```\n将Block作为参数传给dispatch_async时，系统会将Block拷贝到堆上，如果Block中使用了实例变量，还将retain self，因为dispatch_async并不知道self会在什么时候被释放，为了确保系统调度执行Block中的任务时self没有被意外释放掉，dispatch_async必须自己retain一次self，任务完成后再release self。但这里使用__block，使dispatch_async没有增加self的引用计数，这使得在系统在调度执行Block之前，self可能已被销毁，但系统并不知道这个情况，导致Block被调度执行时self已经被释放导致crash。\n``` objc\n// MyClass.m\n- (void) test {\n  __block MyClass* weakSelf = self;\n  double delayInSeconds = 10.0;\n  dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));\n  dispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n    NSLog(@\"%@\", weakSelf);\n});\n\n// other.m\nMyClass* obj = [[[MyClass alloc] init] autorelease];\n[obj test];\n```\n这里用dispatch_after模拟了一个异步任务，10秒后执行Block。但执行Block的时候MyClass* obj已经被释放了，导致crash。解决办法是不要使用__block。","source":"_posts/Block正确使用避免Cycle-Retain和Crash.md","raw":"---\ntitle: Block正确使用避免Cycle Retain和Crash\ndate: 2016-02-24 09:28:26\ntags:\n---\n\n>本文只介绍了MRC时的情况，有些细节不适用于ARC。比如MRC下__block不会增加引用计数，但ARC会，ARC下必须用__weak指明不增加引用计数；ARC下block内存分配机制也与MRC不一样，所以文中的一些例子在ARC下测试结果可能与文中描述的不一样\n\n## Block简介\n\nBlock作为C语言的扩展，并不是高新技术，和其他语言的闭包或lambda表达式是一回事。需要注意的是由于objc在iOS中不支持GC机制，使用Block必须自己管理内存，而内存管理正是使用Block坑最多的地方，错误的内存管理 要么导致return cycle内存泄漏要么内存被提前释放导致crash。 Block的使用很像函数指针，不过与函数最大的不同是：Block可以访问函数以外、词法作用域以内的外部变量的值。换句话说，Block不仅 实现函数的功能，还能携带函数的执行环境。\n\n可以这样理解，Block其实包含两个部分内容\n\n* Block执行的代码，这是在编译的时候已经生成好的；\n* 一个包含Block执行时需要的所有外部变量值的数据结构。 Block将使用到的、作用域附近到的变量的值建立一份快照拷贝到栈上。\n\nBlock与函数另一个不同是，Block类似ObjC的对象，可以使用自动释放池管理内存（但Block并不完全等同于ObjC对象，后面将详细说明）。\n\n<!-- more -->\n\n## Block基本语法\n\n``` objc\n// 声明一个Block变量\nlong (^sum) (int, int) = nil;\n// sum是个Block变量，该Block类型有两个int型参数，返回类型是long。\n\n// 定义Block并赋给变量sum\nsum = ^ long (int a, int b) {\n  return a + b;\n};\n\n// 调用Block：\nlong s = sum(1, 2);\n```\n定义一个实例函数，该函数返回Block：\n``` objc\n- (long (^)(int, int)) sumBlock {\n    int base = 100;\n    return [[ ^ long (int a, int b) {\n      return base + a + b;\n    } copy] autorelease];\n  }\n\n// 调用Block\n[self sumBlock](1,2);\n```\n是不是感觉很怪？为了看的舒服，我们把Block类型typedef一下\n``` objc\ntypedef long (^BlkSum)(int, int);\n\n- (BlkSum) sumBlock {\n    int base = 100;\n    BlkSum blk = ^ long (int a, int b) {\n      return base + a + b;\n    }\n    return [[blk copy] autorelease];\n}\n\n```\n## Block在内存中的位置\n\n根据Block在内存中的位置分为三种类型NSGlobalBlock，NSStackBlock, NSMallocBlock。\n* NSGlobalBlock：类似函数，位于text段；\n* NSStackBlock：位于栈内存，函数返回后Block将无效；\n* NSMallocBlock：位于堆内存。\n\n来看下面一段代码\n``` objc\nBlkSum blk1 = ^ long (int a, int b) {\n  return a + b;\n};\nNSLog(@\"blk1 = %@\", blk1);// blk1 = <__NSGlobalBlock__: 0x47d0>\n\n\nint base = 100;\nBlkSum blk2 = ^ long (int a, int b) {\n  return base + a + b;\n};\nNSLog(@\"blk2 = %@\", blk2); // blk2 = <__NSStackBlock__: 0xbfffddf8>\n\nBlkSum blk3 = [[blk2 copy] autorelease];\nNSLog(@\"blk3 = %@\", blk3); // blk3 = <__NSMallocBlock__: 0x902fda0>\n```\n为什么blk1类型是NSGlobalBlock，而blk2类型是NSStackBlock？blk1和blk2的区别在于，blk1没有使用Block以外的任何外部变量，Block不需要建立局部变量值的快照，这使blk1与函数没有任何区别，从blk1所在内存地址0x47d0猜测编译器把blk1放到了text代码段。blk2与blk1唯一不同是的使用了局部变量base，在定义（注意是定义，不是运行）blk2时，局部变量base当前值被copy到栈上，作为常量供Block使用。执行下面代码，结果是203，而不是204。\n``` objc\nint base = 100;\nbase += 100;\nBlkSum sum = ^ long (int a, int b) {\n    return base + a + b;\n};\nbase++;\nprintf(\"%ld\",sum(1,2));\n```\n\n>在Block内变量base是只读的，如果想在Block内改变base的值，在定义base时要用 __block修饰：__block int base = 100;\n\n``` objc\n__block int base = 100;\nbase += 100;\nBlkSum sum = ^ long (int a, int b) {\n    base += 10;\n    return base + a + b;\n};\nbase++;\nprintf(\"%ld\\n\",sum(1,2));\nprintf(\"%d\\n\",base);\n```\n上方的代码输出将是214,211。Block中使用__block修饰的变量时，将取变量此刻运行时的值，而不是定义时的快照。这个例子中，执行sum(1,2)时，base将取base++之后的值，也就是201，再执行Blockbase+=10; base+a+b，运行结果是214。执行完Block时，base已经变成211了。\n\n## Block的copy、retain、release操作\n\n不同于NSObjec的copy、retain、release操作：\n* Block_copy与copy等效，Block_release与release等效；\n* 对Block不管是retain、copy、release都不会改变引用计数retainCount，retainCount始终是1；\n* NSGlobalBlock：retain、copy、release操作都无效；\n* NSStackBlock：retain、release操作无效，必须注意的是，NSStackBlock在函数返回后，Block内存将被回收。即使retain也没用。容易犯的错误是[[mutableAarry addObject:stackBlock]，在函数出栈后，从mutableAarry中取到的stackBlock已经被回收，变成了野指针。正确的做法是先将stackBlock copy到堆上，然后加入数组：[mutableAarry addObject:[[stackBlock copy] autorelease]]。支持copy，copy之后生成新的NSMallocBlock类型对象。\n* NSMallocBlock支持retain、release，虽然retainCount始终是1，但内存管理器中仍然会增加、减少计数。copy之后不会生成新的对象，只是增加了一次引用，类似retain；\n* 尽量不要对Block使用retain操作。\n\n## Block对不同类型的变量的存取\n\n** 基本类型 **\n* 局部自动变量，在Block中只读。Block定义时copy变量的值，在Block中作为常量使用，所以即使变量的值在Block外改变，也不影响他在Block中的值。\n``` objc\nint base = 100;\nBlkSum sum = ^ long (int a, int b) {\n  // base++; 编译错误，只读\n  return base + a + b;\n};\nbase = 0;\nprintf(\"%ld\\n\",sum(1,2)); // 这里输出是103，而不是3\n```\n* static变量、全局变量。如果把上个例子的base改成全局的、或static。Block就可以对他进行读写了。因为全局变量或静态变量在内存中的地址是固定的，Block在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量。\n如下所示的一段代码输出结果是0 3 1，表明Block外部对base的更新会影响Block中的base的取值，同样Block对base的更新也会影响Block外部的base值。\n``` objc\nstatic int base = 100;\nBlkSum sum = ^ long (int a, int b) {\n  base++;\n  return base + a + b;\n};\nbase = 0;\nprintf(\"%d\\n\", base);\nprintf(\"%ld\\n\",sum(1,2)); // 这里输出是3，而不是103\nprintf(\"%d\\n\", base);\n```\n\n* Block变量，被__block修饰的变量称作Block变量。 基本类型的Block变量等效于全局变量、或静态变量。Block被另一个Block使用时，另一个Block被copy到堆上时，被使用的Block也会被copy。但作为参数的Block是不会发生copy的。\n``` objc\nvoid foo() {\n  int base = 100;\n  BlkSum blk = ^ long (int a, int b) {\n    return  base + a + b;\n  };\n  NSLog(@\"%@\", blk); // <__NSStackBlock__: 0xbfffdb40>\n  bar(blk);\n}\n\nvoid bar(BlkSum sum_blk) {\n  NSLog(@\"%@\",sum_blk); // 与上面一样，说明作为参数传递时，并不会发生copy\n\n  void (^blk) (BlkSum) = ^ (BlkSum sum) {\n    NSLog(@\"%@\",sum);     // 无论blk在堆上还是栈上，作为参数的Block不会发生copy。\n    NSLog(@\"%@\",sum_blk); // 当blk copy到堆上时，sum_blk也被copy了一分到堆上上。\n  };\n  blk(sum_blk); // blk在栈上\n\n  blk = [[blk copy] autorelease];\n  blk(sum_blk); // blk在堆上\n}\n```\n\n* ObjC对象，不同于基本类型，Block会引起对象的引用计数变化。\n先看下面代码\n执行结果为1 1 1 2 1。\n__globalObj和__staticObj在内存中的位置是确定的，所以Block copy时不会retain对象。\n_instanceObj在Block copy时也没有直接retain _instanceObj对象本身，但会retain self。所以在Block中可以直接读写_instanceObj变量。\nlocalObj在Block copy时，系统自动retain对象，增加其引用计数。\nblockObj在Block copy时也不会retain。\n``` objc\n@interface MyClass : NSObject {\n    NSObject* _instanceObj;\n}\n@end\n\n@implementation MyClass\n\nNSObject* __globalObj = nil;\n\n- (id) init {\n    if (self = [super init]) {\n        _instanceObj = [[NSObject alloc] init];\n    }\n    return self;\n}\n\n- (void) test {\n    static NSObject* __staticObj = nil;\n    __globalObj = [[NSObject alloc] init];\n    __staticObj = [[NSObject alloc] init];\n\n    NSObject* localObj = [[NSObject alloc] init];\n    __block NSObject* blockObj = [[NSObject alloc] init];\n\n    typedef void (^MyBlock)(void) ;\n    MyBlock aBlock = ^{\n        NSLog(@\"%@\", __globalObj);\n        NSLog(@\"%@\", __staticObj);\n        NSLog(@\"%@\", _instanceObj);\n        NSLog(@\"%@\", localObj);\n        NSLog(@\"%@\", blockObj);\n    };\n    aBlock = [[aBlock copy] autorelease];\n    aBlock();\n\n    NSLog(@\"%d\", [__globalObj retainCount]);\n    NSLog(@\"%d\", [__staticObj retainCount]);\n    NSLog(@\"%d\", [_instanceObj retainCount]);\n    NSLog(@\"%d\", [localObj retainCount]);\n    NSLog(@\"%d\", [blockObj retainCount]);\n}\n@end\n\nint main(int argc, char *argv[]) {\n    @autoreleasepool {\n        MyClass* obj = [[[MyClass alloc] init] autorelease];\n        [obj test];\n        return 0;\n    }\n}\n```\n* 非ObjC对象，如GCD队列dispatch_queue_t。Block copy时并不会自动增加他的引用计数，这点要非常小心。\n\n## Block中使用的ObjC对象的行为\n\n``` objc\n@property (nonatomic, copy) void(^myBlock)(void);\n\nMyClass* obj = [[[MyClass alloc] init] autorelease];\nself.myBlock = ^ {\n  [obj doSomething];\n};\n```\n对象obj在Block被copy到堆上的时候自动retain了一次。因为Block不知道obj什么时候被释放，为了不在Block使用obj前被释放，Block retain了obj一次，在Block被释放的时候，obj被release一次。\n\n## retain cycle\n\nretain cycle问题的根源在于Block和obj可能会互相强引用，互相retain对方，这样就导致了retain cycle，最后这个Block和obj就变成了孤岛，谁也释放不了谁。比如：\n``` objc\nASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];\n[request setCompletionBlock:^{\n  NSString* string = [request responseString];\n}];\n```\n``` bash\n       +-----------+           +-----------+\n       | request   |           |   Block   |\n  ---> |           | --------> |           |\n       | retain 2  | <-------- | retain 1  |\n       |           |           |           |\n       +-----------+           +-----------+\n```\n解决这个问题的办法是使用弱引用打断retain cycle：\n``` objc\n__block ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];\n[request setCompletionBlock:^{\n  NSString* string = [request responseString];\n}];\n```\n``` bash\n      +-----------+           +-----------+\n      | request   |           |   Block   |\n ---->|           | --------> |           |\n      | retain 1  | < - - - - | retain 1  |\n      |           |   weak    |           |\n      +-----------+           +-----------+\n```\nrequest被持有者释放后。request 的retainCount变成0,request被dealloc，request释放持有的Block，导致Block的retainCount变成0，也被销毁。这样这两个对象内存都被回收。\n``` bash\n      +-----------+           +-----------+\n      | request   |           |   Block   |\n --X->|           | ----X---> |           |\n      | retain 0  | < - - - - | retain 0  |\n      |           |   weak    |           |\n      +-----------+           +-----------+\n```\n与上面情况类似的陷阱：\n``` objc\nself.myBlock = ^ {\n  [self doSomething];\n};\n```\n这里self和myBlock循环引用，解决办法同上：\n``` objc\n__block MyClass* weakSelf = self;\nself.myBlock = ^ {\n  [weakSelf doSomething];\n};\n```\n``` objc\n@property (nonatomic, retain) NSString* someVar;\n\nself.myBlock = ^ {\n  NSLog(@\"%@\", _someVer);\n};\n```\n这里在Block中虽然没直接使用self，但使用了成员变量。在Block中使用成员变量，retain的不是这个变量，而会retain self。解决办法也和上面一样。\n``` objc\n@property (nonatomic, retain) NSString* someVar;\n\n__block MyClass* weakSelf = self;\nself.myBlock = ^ {\n  NSLog(@\"%@\", self.someVer);\n};\n```\n或者\n``` objc\nNSString* str = _someVer;\nself.myBlock = ^ {\n  NSLog(@\"%@\", str);\n};\n```\nretain cycle不只发生在两个对象之间，也可能发生在多个对象之间，这样问题更复杂，更难发现\n``` objc\nClassA* objA = [[[ClassA alloc] init] autorelease];\nobjA.myBlock = ^{\n    [self doSomething];\n};\nself.objA = objA;\n```\n``` bash\n  +-----------+           +-----------+           +-----------+\n  |   self    |           |   objA    |           |   Block   |\n  |           | --------> |           | --------> |           |\n  | retain 1  |           | retain 1  |           | retain 1  |\n  |           |           |           |           |           |\n  +-----------+           +-----------+           +-----------+\n       ^                                                |\n       |                                                |\n       +------------------------------------------------+\n```\n解决办法同样是用__block打破循环引用\n``` objc\nClassA* objA = [[[ClassA alloc] init] autorelease];\n\nMyClass* weakSelf = self;\nobjA.myBlock = ^{\n  [weakSelf doSomething];\n};\nself.objA = objA;\n```\n>注意：MRC中__block是不会引起retain；但在ARC中__block则会引起retain。ARC中应该使用__weak或__unsafe_unretained弱引用。__weak只能在iOS5以后使用。\n\n## Block使用对象被提前释放\n看下面例子，有这种情况，如果不只是request持有了Block，另一个对象也持有了Block。\n``` bash\n      +-----------+           +-----------+\n      | request   |           |   Block   |   objA\n ---->|           | --------> |           |<--------\n      | retain 1  | < - - - - | retain 2  |\n      |           |   weak    |           |\n      +-----------+           +-----------+\n```\n这时如果request 被持有者释放。\n``` bash\n      +-----------+           +-----------+\n      | request   |           |   Block   |   objA\n --X->|           | --------> |           |<--------\n      | retain 0  | < - - - - | retain 1  |\n      |           |   weak    |           |\n      +-----------+           +-----------+\n```\n这时request已被完全释放，但Block仍被objA持有，没有释放，如果这时触发了Block，在Block中将访问已经销毁的request，这将导致程序crash。为了避免这种情况，开发者必须要注意对象和Block的生命周期。\n\n另一个常见错误使用是，开发者担心retain cycle错误的使用__block。比如\n``` objc\n__block kkProducView* weakSelf = self;\ndispatch_async(dispatch_get_main_queue(), ^{\n  weakSelf.xx = xx;\n});\n```\n将Block作为参数传给dispatch_async时，系统会将Block拷贝到堆上，如果Block中使用了实例变量，还将retain self，因为dispatch_async并不知道self会在什么时候被释放，为了确保系统调度执行Block中的任务时self没有被意外释放掉，dispatch_async必须自己retain一次self，任务完成后再release self。但这里使用__block，使dispatch_async没有增加self的引用计数，这使得在系统在调度执行Block之前，self可能已被销毁，但系统并不知道这个情况，导致Block被调度执行时self已经被释放导致crash。\n``` objc\n// MyClass.m\n- (void) test {\n  __block MyClass* weakSelf = self;\n  double delayInSeconds = 10.0;\n  dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));\n  dispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n    NSLog(@\"%@\", weakSelf);\n});\n\n// other.m\nMyClass* obj = [[[MyClass alloc] init] autorelease];\n[obj test];\n```\n这里用dispatch_after模拟了一个异步任务，10秒后执行Block。但执行Block的时候MyClass* obj已经被释放了，导致crash。解决办法是不要使用__block。","slug":"Block正确使用避免Cycle-Retain和Crash","published":1,"updated":"2016-06-02T03:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcmf002i29webq5s3e7i"},{"title":"App Store上线完整流程","date":"2016-03-05T09:25:33.000Z","_content":"\n经过一年的iOS开发，到现在一共上线了6款App到App Store。从iOS6到iOS9，每一次苹果系统的更新，App Store的上线流程都会有点相应的改变。对于上线App到App Store的这个流程现在已经是得心应手，现在利用周末这个闲暇的时间纪录一下完整的上传App到App Store的流程。\n\n## 预先准备\n\n在你开始将程序提交到App Store之前，您需要有一个开发者帐号、一个App ID、一个有效的证书以及一个有效的Provisioning Profiles。\n\n<!-- more -->\n\n### Step 1:申请开发者帐号\n\n如果您现在已有开发者帐号，那么恭喜您，您可以直接跳过此步骤直接进入下一步骤。苹果开发者帐号分为三种：个人开发者帐号、公司帐号、企业帐号。\n\n**个人帐号（Individual）:**\n* 费用：99美元一年\n* App Store上架：是\n* 最大uuid支持数：100\n* 协作人数：1人（开发者自己）\n\n说明：“个人”开发者可以申请升级“公司”，可以通过拨打苹果公司客服电话（400 6701 855）来咨询和办理。\n\n** 公司帐号（Company）: **\n* 费用：99美元一年\n* App Store上架：是\n* 最大uuid支持数：100\n* 协作人数：多人\n\n说明：允许多个开发者进行协作开发，比个人多一些帐号管理的设置，可设置多个Apple ID，分4种管理级别的权限。申请时需要填写公司的邓白氏编码（DUNS Number）。\n\n** 企业帐号（Enterprise）: **\n* 费用：299美元一年\n* App Store上架：否\n* 最大uuid支持数：不限制\n* 协作人数：多人\n\n说明：需要注意的是，企业账号开发的应用不能上线App Store，适合那些不希望公开发布应用的企业。同样，申请时也需要公司的邓白氏编码（DUNS Number）。\n\n### Step 2:App ID（应用ID）\nApp ID是识别不同应用程序的唯一标示符。每个app都需要一个App ID或者app标识。目前有两种类型的App标识：一个是精确的App ID（explicit App ID），一个是通配符App ID（wildcard App ID）。使用通配符的App ID可以用来构建和安装多个程序。尽管通配符App ID非常方便，但是一个精确的App ID也是需要的，尤其是当App使用iCloud 或者使用其他iOS功能的时候，比如Game Center、Push Notifications或者IAP。如果你已经申请开发者帐号，接下你需要登录https://developer.apple.com/membercenter/。\n登录成功后界面如下：\n{% asset_img developer_center.png Developer页面 %}\n点击“Certificates,Identifiers&Profiles”进入到\n{% asset_img Identifiers.png Identifiers%}\n选择Identifiers，然后点击“＋”注册你自己的应用的App Id\n{% asset_img create_app_id.png 创建App ID%}\n以上两项设置好后，点击下一步，然后注册即可，这样一个App Id就创建好了。接下来需要设置开发证书。\n\n### Step 3:Distribution Certificate(发布证书)\niOS应用都有一个安全证书用于验证开发者身份和签名。为了可以向App Store提交app，你需要创建一个iOS provisioning profile 。首先需要创建一个distribution certificate（发布证书），过程类似于创建一个development certificate（开发证书）。如果你已经在实体设备上测试你的App，那么你对创建development certificate就已经很熟悉了。\n\n首先选择Certificate,然后点击“＋”\n\n{% asset_img create_certificates_step1.png 创建Certificate证书第一步%}\n{% asset_img create_certificates_step2.png 创建Certificate证书第二步%}\n\n然后点击“下一步”来到如下界面：\n{% asset_img create_certificates_step3.png 创建Certificate证书第三步%}\n\n这里需要上传一个.certSigningRequest文件来生成相应的证书。下面简单讲一下.certSigningRequest文件的生成方法：\n首先打开“钥匙串访问”，在菜单中选择“钥匙串访问”->“证书助理”->“从证书颁发机构请求证书...”。\n{% asset_img create_certSigningRequest_step1.png 创建.certSigningRequest文件%}\n然后填写好相应的信息，注意：选择保存到磁盘。\n{% asset_img create_certSigningRequest_step2.png 填写.certSigningRequest文件信息%}\n点击继续，然后会生成一个.certSigningRequest文件。\n然后选择生成的.certSigningRequest文件，点击下一步即可生成相应的证书。\n\n### Step 4:Provisioning Profile(配置文件)\n一旦你创建了App ID和distribution certificate，你可以创建一个iOS provisioning profile以方便在App Store中销售你的App。Provisioning Profile主要分为开发配置文件和发布配置文件，发布配置文件中又分App Store配置文件和Ad Hoc配置文件。App Store类型的Provisioning Profile顾名思义是用于发布到App Store的配置文件。Ad Hoc的Provisioning Profile配置文件是用于发布应用内的测试包的，在应用还没有上线的时候需要发ipa给客户安装的时候需要用到，只需要获取到客户手机的UDID然后生成相应的Ad Hoc类型的Provisioning Profile文件然后打包发布即可。\n同样Provisioning Profile的创建方式如下：\n选择“Provisioning Profiles”，然后点击“➕”创建Provisioning Profiles文件\n\n{% asset_img create_pp_step1.png 创建Provisioning Profiles文件%}\n\n选择相应的Provisioning Profiles文件类型\n{% asset_img create_pp_step2.png 选择Provisioning Profiles文件类型%}\n\n选择您需要生成Provisioning Profiles文件的App ID\n{% asset_img create_pp_step3.png 选择Provisioning Profiles文件的App ID%}\n选择相应的证书\n{% asset_img create_pp_step4.png 选择相应的证书%}\n选择已注册的设备\n{% asset_img create_pp_step5.png 选择已注册的设备%}\n然后点击下一步即可生成Provisioning Profiles文件，点击下载，然后双击打开。\n\n### Step 5:Build Settings(生成设置)\n配置App ID、distribution certificate 和provisioning profile已经完成，是时候配置Xcode中target的build settings了。在Xcode Project  Navigator的targets列表中选择一个target，打开顶部的Build Settings选项，然后更新一下Code Signing来跟之前创建的distribution provisioning profile相匹配。最近添加的provisioning profiles有时候不会立马就在build settings的Code Signing中看到，重启一下Xcode就可以解决这个问题。\n{% asset_img build_setting.png Build Setting配置%}\n\n### Step 6:Deployment Target(部署目标)\n所有配置都已配好后，就可以开始打包了生成ipa了。\n{% asset_img archive.png 开始打包%}\n\n## iTunes Connect相关配置\n\n### Step 1:创建“我的App”\n\n首先用你自己的开发者帐号登录到[iTunes Connect](https://itunesconnect.apple.com/)。\n\n{% asset_img itunes_connect_step1.png iTunes Connect%}\n登录成功后点击“我的App”，然后点击“＋”->“新建App”\n{% asset_img itunes_connect_step2.png 在iTunes Connect上新建App%}\n其中平台选择iOS，名称为你的app的名词，主要语言为你的app的主要语言，套装ID为之前创建的App ID，也就是Xcode工程中的Bundle ID。\n点击下一步，创建成功后，选择你刚创建成功的应用，进行相关的设置。\n{% asset_img itunes_connect_step3.png 填写相关信息%}\n\n相关设置比较简单就不再多说。\n\n### Step 2:打包上传到iTunes Connect\n\n配置好了iTunes Connect的相关配置后，就可以将我们生成的ipa包上传到iTunes Connect上了。Xcode中配置完成后archive成功后Xcode会弹出如下界面：\n{% asset_img upload_itunes_connect.png 上传到iTunes Connect%}\n 上传到iTunes Connect有两种方法：\n\n** 方法一 **\n直接点击上图的“Upload to App Store”按钮直接上传到App Store。\n\n** 方法二 **\n先导出ipa，然后使用Application Loader上传到App Store。\n点击“Export”，会弹出如下界面，选择导出的类型，这里要上传App Store，所以选择第一种。\n{% asset_img archive_step_1.png 导出ipa文件%}\n点击“下一步”，默认回去检查你的证书，如果没有什么问题一直下一步，最后会在桌面生成一个ipa的包。然后在Xcode中打开Application Loader。\n{% asset_img application_loader_1.png Application Loader%}\n用你自己的开发者帐号登录Application Loader，\n{% asset_img application_loader_login.png Application Loader登录%}\n登录成功后选取你刚刚生成的ipa\n{% asset_img application_loader_step2.png Application Loader上传%}\n然后上传提交到App Store。\n\n### Step 3:提交给苹果审核\n完成上面的步骤后，返回到iTunes Connect界面，选择你先前创建的App，在它的活动页面下可以看到所有已上传过的ipa版本。\n{% asset_img itunes_connect_step4.png 上传成功后%}\n选择App信息配置界面，找到“构建版本”，然后选择你刚刚上传的构建版本，然后提交审核即可\n{% asset_img itunes_connect_step5.png 提交审核%}","source":"_posts/App-Store上线完整流程.md","raw":"---\ntitle: App Store上线完整流程\ndate: 2016-03-05 17:25:33\ntags:\n  - App Store\ncategories: iOS学习笔记\n---\n\n经过一年的iOS开发，到现在一共上线了6款App到App Store。从iOS6到iOS9，每一次苹果系统的更新，App Store的上线流程都会有点相应的改变。对于上线App到App Store的这个流程现在已经是得心应手，现在利用周末这个闲暇的时间纪录一下完整的上传App到App Store的流程。\n\n## 预先准备\n\n在你开始将程序提交到App Store之前，您需要有一个开发者帐号、一个App ID、一个有效的证书以及一个有效的Provisioning Profiles。\n\n<!-- more -->\n\n### Step 1:申请开发者帐号\n\n如果您现在已有开发者帐号，那么恭喜您，您可以直接跳过此步骤直接进入下一步骤。苹果开发者帐号分为三种：个人开发者帐号、公司帐号、企业帐号。\n\n**个人帐号（Individual）:**\n* 费用：99美元一年\n* App Store上架：是\n* 最大uuid支持数：100\n* 协作人数：1人（开发者自己）\n\n说明：“个人”开发者可以申请升级“公司”，可以通过拨打苹果公司客服电话（400 6701 855）来咨询和办理。\n\n** 公司帐号（Company）: **\n* 费用：99美元一年\n* App Store上架：是\n* 最大uuid支持数：100\n* 协作人数：多人\n\n说明：允许多个开发者进行协作开发，比个人多一些帐号管理的设置，可设置多个Apple ID，分4种管理级别的权限。申请时需要填写公司的邓白氏编码（DUNS Number）。\n\n** 企业帐号（Enterprise）: **\n* 费用：299美元一年\n* App Store上架：否\n* 最大uuid支持数：不限制\n* 协作人数：多人\n\n说明：需要注意的是，企业账号开发的应用不能上线App Store，适合那些不希望公开发布应用的企业。同样，申请时也需要公司的邓白氏编码（DUNS Number）。\n\n### Step 2:App ID（应用ID）\nApp ID是识别不同应用程序的唯一标示符。每个app都需要一个App ID或者app标识。目前有两种类型的App标识：一个是精确的App ID（explicit App ID），一个是通配符App ID（wildcard App ID）。使用通配符的App ID可以用来构建和安装多个程序。尽管通配符App ID非常方便，但是一个精确的App ID也是需要的，尤其是当App使用iCloud 或者使用其他iOS功能的时候，比如Game Center、Push Notifications或者IAP。如果你已经申请开发者帐号，接下你需要登录https://developer.apple.com/membercenter/。\n登录成功后界面如下：\n{% asset_img developer_center.png Developer页面 %}\n点击“Certificates,Identifiers&Profiles”进入到\n{% asset_img Identifiers.png Identifiers%}\n选择Identifiers，然后点击“＋”注册你自己的应用的App Id\n{% asset_img create_app_id.png 创建App ID%}\n以上两项设置好后，点击下一步，然后注册即可，这样一个App Id就创建好了。接下来需要设置开发证书。\n\n### Step 3:Distribution Certificate(发布证书)\niOS应用都有一个安全证书用于验证开发者身份和签名。为了可以向App Store提交app，你需要创建一个iOS provisioning profile 。首先需要创建一个distribution certificate（发布证书），过程类似于创建一个development certificate（开发证书）。如果你已经在实体设备上测试你的App，那么你对创建development certificate就已经很熟悉了。\n\n首先选择Certificate,然后点击“＋”\n\n{% asset_img create_certificates_step1.png 创建Certificate证书第一步%}\n{% asset_img create_certificates_step2.png 创建Certificate证书第二步%}\n\n然后点击“下一步”来到如下界面：\n{% asset_img create_certificates_step3.png 创建Certificate证书第三步%}\n\n这里需要上传一个.certSigningRequest文件来生成相应的证书。下面简单讲一下.certSigningRequest文件的生成方法：\n首先打开“钥匙串访问”，在菜单中选择“钥匙串访问”->“证书助理”->“从证书颁发机构请求证书...”。\n{% asset_img create_certSigningRequest_step1.png 创建.certSigningRequest文件%}\n然后填写好相应的信息，注意：选择保存到磁盘。\n{% asset_img create_certSigningRequest_step2.png 填写.certSigningRequest文件信息%}\n点击继续，然后会生成一个.certSigningRequest文件。\n然后选择生成的.certSigningRequest文件，点击下一步即可生成相应的证书。\n\n### Step 4:Provisioning Profile(配置文件)\n一旦你创建了App ID和distribution certificate，你可以创建一个iOS provisioning profile以方便在App Store中销售你的App。Provisioning Profile主要分为开发配置文件和发布配置文件，发布配置文件中又分App Store配置文件和Ad Hoc配置文件。App Store类型的Provisioning Profile顾名思义是用于发布到App Store的配置文件。Ad Hoc的Provisioning Profile配置文件是用于发布应用内的测试包的，在应用还没有上线的时候需要发ipa给客户安装的时候需要用到，只需要获取到客户手机的UDID然后生成相应的Ad Hoc类型的Provisioning Profile文件然后打包发布即可。\n同样Provisioning Profile的创建方式如下：\n选择“Provisioning Profiles”，然后点击“➕”创建Provisioning Profiles文件\n\n{% asset_img create_pp_step1.png 创建Provisioning Profiles文件%}\n\n选择相应的Provisioning Profiles文件类型\n{% asset_img create_pp_step2.png 选择Provisioning Profiles文件类型%}\n\n选择您需要生成Provisioning Profiles文件的App ID\n{% asset_img create_pp_step3.png 选择Provisioning Profiles文件的App ID%}\n选择相应的证书\n{% asset_img create_pp_step4.png 选择相应的证书%}\n选择已注册的设备\n{% asset_img create_pp_step5.png 选择已注册的设备%}\n然后点击下一步即可生成Provisioning Profiles文件，点击下载，然后双击打开。\n\n### Step 5:Build Settings(生成设置)\n配置App ID、distribution certificate 和provisioning profile已经完成，是时候配置Xcode中target的build settings了。在Xcode Project  Navigator的targets列表中选择一个target，打开顶部的Build Settings选项，然后更新一下Code Signing来跟之前创建的distribution provisioning profile相匹配。最近添加的provisioning profiles有时候不会立马就在build settings的Code Signing中看到，重启一下Xcode就可以解决这个问题。\n{% asset_img build_setting.png Build Setting配置%}\n\n### Step 6:Deployment Target(部署目标)\n所有配置都已配好后，就可以开始打包了生成ipa了。\n{% asset_img archive.png 开始打包%}\n\n## iTunes Connect相关配置\n\n### Step 1:创建“我的App”\n\n首先用你自己的开发者帐号登录到[iTunes Connect](https://itunesconnect.apple.com/)。\n\n{% asset_img itunes_connect_step1.png iTunes Connect%}\n登录成功后点击“我的App”，然后点击“＋”->“新建App”\n{% asset_img itunes_connect_step2.png 在iTunes Connect上新建App%}\n其中平台选择iOS，名称为你的app的名词，主要语言为你的app的主要语言，套装ID为之前创建的App ID，也就是Xcode工程中的Bundle ID。\n点击下一步，创建成功后，选择你刚创建成功的应用，进行相关的设置。\n{% asset_img itunes_connect_step3.png 填写相关信息%}\n\n相关设置比较简单就不再多说。\n\n### Step 2:打包上传到iTunes Connect\n\n配置好了iTunes Connect的相关配置后，就可以将我们生成的ipa包上传到iTunes Connect上了。Xcode中配置完成后archive成功后Xcode会弹出如下界面：\n{% asset_img upload_itunes_connect.png 上传到iTunes Connect%}\n 上传到iTunes Connect有两种方法：\n\n** 方法一 **\n直接点击上图的“Upload to App Store”按钮直接上传到App Store。\n\n** 方法二 **\n先导出ipa，然后使用Application Loader上传到App Store。\n点击“Export”，会弹出如下界面，选择导出的类型，这里要上传App Store，所以选择第一种。\n{% asset_img archive_step_1.png 导出ipa文件%}\n点击“下一步”，默认回去检查你的证书，如果没有什么问题一直下一步，最后会在桌面生成一个ipa的包。然后在Xcode中打开Application Loader。\n{% asset_img application_loader_1.png Application Loader%}\n用你自己的开发者帐号登录Application Loader，\n{% asset_img application_loader_login.png Application Loader登录%}\n登录成功后选取你刚刚生成的ipa\n{% asset_img application_loader_step2.png Application Loader上传%}\n然后上传提交到App Store。\n\n### Step 3:提交给苹果审核\n完成上面的步骤后，返回到iTunes Connect界面，选择你先前创建的App，在它的活动页面下可以看到所有已上传过的ipa版本。\n{% asset_img itunes_connect_step4.png 上传成功后%}\n选择App信息配置界面，找到“构建版本”，然后选择你刚刚上传的构建版本，然后提交审核即可\n{% asset_img itunes_connect_step5.png 提交审核%}","slug":"App-Store上线完整流程","published":1,"updated":"2016-06-02T03:54:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cird7gcmi002j29we14f235vv"}],"PostAsset":[{"_id":"source/_posts/关闭iOS系统自动更新提示的方法/thumb_IMG_0889_1024.jpg","post":"cird7gchd000d29weg05tmswh","slug":"thumb_IMG_0889_1024.jpg","modified":1},{"_id":"source/_posts/关闭iOS系统自动更新提示的方法/thumb_IMG_0890_1024.jpg","post":"cird7gchd000d29weg05tmswh","slug":"thumb_IMG_0890_1024.jpg","modified":1},{"_id":"source/_posts/iOS上完美编译FFmpeg/1.png","post":"cird7gci6001529wec85ab83u","slug":"1.png","modified":1},{"_id":"source/_posts/RXSwift基础/catch.png","post":"cird7gcip001o29we7kwzslne","slug":"catch.png","modified":1},{"_id":"source/_posts/RXSwift基础/create.png","post":"cird7gcip001o29we7kwzslne","slug":"create.png","modified":1},{"_id":"source/_posts/RXSwift基础/deferred.png","post":"cird7gcip001o29we7kwzslne","slug":"deferred.png","modified":1},{"_id":"source/_posts/RXSwift基础/doOn.png","post":"cird7gcip001o29we7kwzslne","slug":"doOn.png","modified":1},{"_id":"source/_posts/RXSwift基础/empty.png","post":"cird7gcip001o29we7kwzslne","slug":"empty.png","modified":1},{"_id":"source/_posts/RXSwift基础/flatMap.png","post":"cird7gcip001o29we7kwzslne","slug":"flatMap.png","modified":1},{"_id":"source/_posts/RXSwift基础/just.png","post":"cird7gcip001o29we7kwzslne","slug":"just.png","modified":1},{"_id":"source/_posts/RXSwift基础/never.png","post":"cird7gcip001o29we7kwzslne","slug":"never.png","modified":1},{"_id":"source/_posts/RXSwift基础/publish.png","post":"cird7gcip001o29we7kwzslne","slug":"publish.png","modified":1},{"_id":"source/_posts/RXSwift基础/replay.png","post":"cird7gcip001o29we7kwzslne","slug":"replay.png","modified":1},{"_id":"source/_posts/RXSwift基础/retry.png","post":"cird7gcip001o29we7kwzslne","slug":"retry.png","modified":1},{"_id":"source/_posts/RXSwift基础/skipWhile.png","post":"cird7gcip001o29we7kwzslne","slug":"skipWhile.png","modified":1},{"_id":"source/_posts/RXSwift基础/switch.png","post":"cird7gcip001o29we7kwzslne","slug":"switch.png","modified":1},{"_id":"source/_posts/RXSwift基础/takeWhile.png","post":"cird7gcip001o29we7kwzslne","slug":"takeWhile.png","modified":1},{"_id":"source/_posts/RXSwift基础/toArray.png","post":"cird7gcip001o29we7kwzslne","slug":"toArray.png","modified":1},{"_id":"source/_posts/Mac基础：如何让Finder显示隐藏文件和文件夹/bash.png","post":"cird7gck1002429we25q2fjen","slug":"bash.png","modified":1},{"_id":"source/_posts/Mac基础：如何让Finder显示隐藏文件和文件夹/finder.png","post":"cird7gck1002429we25q2fjen","slug":"finder.png","modified":1},{"_id":"source/_posts/Mac基础：如何让Finder显示隐藏文件和文件夹/hidefinder.png","post":"cird7gck1002429we25q2fjen","slug":"hidefinder.png","modified":1},{"_id":"source/_posts/Mac基础：如何让Finder显示隐藏文件和文件夹/show.png","post":"cird7gck1002429we25q2fjen","slug":"show.png","modified":1},{"_id":"source/_posts/Hexo安装新主题apollo/apollo.png","post":"cird7gcke002929wefyouwme8","slug":"apollo.png","modified":1},{"_id":"source/_posts/Hexo在github上构建免费的博客/github.png","post":"cird7gckj002a29we5psi3tg7","slug":"github.png","modified":1},{"_id":"source/_posts/Hexo在github上构建免费的博客/hexo-dict.png","post":"cird7gckj002a29we5psi3tg7","slug":"hexo-dict.png","modified":1},{"_id":"source/_posts/Hexo在github上构建免费的博客/hexo-new.png","post":"cird7gckj002a29we5psi3tg7","slug":"hexo-new.png","modified":1},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/dSYMs.png","post":"cird7gcli002c29wecff1g36r","slug":"dSYMs.png","modified":1},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/export.png","post":"cird7gcli002c29wecff1g36r","slug":"export.png","modified":1},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/problem.png","post":"cird7gcli002c29wecff1g36r","slug":"problem.png","modified":1},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/product.png","post":"cird7gcli002c29wecff1g36r","slug":"product.png","modified":1},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/show_in_finder.png","post":"cird7gcli002c29wecff1g36r","slug":"show_in_finder.png","modified":1},{"_id":"source/_posts/Failed-to-locate-or-generate-matchin-signing-assets/zip.png","post":"cird7gcli002c29wecff1g36r","slug":"zip.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/Identifiers.png","post":"cird7gcmi002j29we14f235vv","slug":"Identifiers.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/application_loader_1.png","post":"cird7gcmi002j29we14f235vv","slug":"application_loader_1.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/application_loader_login.png","post":"cird7gcmi002j29we14f235vv","slug":"application_loader_login.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/application_loader_step2.png","post":"cird7gcmi002j29we14f235vv","slug":"application_loader_step2.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/archive.png","post":"cird7gcmi002j29we14f235vv","slug":"archive.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/archive_step_1.png","post":"cird7gcmi002j29we14f235vv","slug":"archive_step_1.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/build_setting.png","post":"cird7gcmi002j29we14f235vv","slug":"build_setting.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/create_app_id.png","post":"cird7gcmi002j29we14f235vv","slug":"create_app_id.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/create_certSigningRequest_step1.png","post":"cird7gcmi002j29we14f235vv","slug":"create_certSigningRequest_step1.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/create_certSigningRequest_step2.png","post":"cird7gcmi002j29we14f235vv","slug":"create_certSigningRequest_step2.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/create_certificates_step1.png","post":"cird7gcmi002j29we14f235vv","slug":"create_certificates_step1.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/create_certificates_step2.png","post":"cird7gcmi002j29we14f235vv","slug":"create_certificates_step2.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/create_certificates_step3.png","post":"cird7gcmi002j29we14f235vv","slug":"create_certificates_step3.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/create_pp_step1.png","post":"cird7gcmi002j29we14f235vv","slug":"create_pp_step1.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/create_pp_step2.png","post":"cird7gcmi002j29we14f235vv","slug":"create_pp_step2.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/create_pp_step3.png","post":"cird7gcmi002j29we14f235vv","slug":"create_pp_step3.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/create_pp_step4.png","post":"cird7gcmi002j29we14f235vv","slug":"create_pp_step4.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/create_pp_step5.png","post":"cird7gcmi002j29we14f235vv","slug":"create_pp_step5.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/developer_center.png","post":"cird7gcmi002j29we14f235vv","slug":"developer_center.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/itunes_connect_step1.png","post":"cird7gcmi002j29we14f235vv","slug":"itunes_connect_step1.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/itunes_connect_step2.png","post":"cird7gcmi002j29we14f235vv","slug":"itunes_connect_step2.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/itunes_connect_step3.png","post":"cird7gcmi002j29we14f235vv","slug":"itunes_connect_step3.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/itunes_connect_step4.png","post":"cird7gcmi002j29we14f235vv","slug":"itunes_connect_step4.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/itunes_connect_step5.png","post":"cird7gcmi002j29we14f235vv","slug":"itunes_connect_step5.png","modified":1},{"_id":"source/_posts/App-Store上线完整流程/upload_itunes_connect.png","post":"cird7gcmi002j29we14f235vv","slug":"upload_itunes_connect.png","modified":1}],"PostCategory":[{"post_id":"cird7gchd000d29weg05tmswh","category_id":"cird7gche000e29weglpvjygj","_id":"cird7gchf000h29we4mn04lpb"},{"post_id":"cird7gchp000i29we8crezyg2","category_id":"cird7gchr000j29webv9h5l7a","_id":"cird7gchs000m29we62vx5b8j"},{"post_id":"cird7gchu000p29we82yzuqsg","category_id":"cird7gchr000j29webv9h5l7a","_id":"cird7gchv000q29wer2u12r6f"},{"post_id":"cird7gchw000t29we1yv7u11m","category_id":"cird7gchy000u29wei5squ6n5","_id":"cird7gchy000x29weiwqscbx7"},{"post_id":"cird7gcih001c29weqo440j03","category_id":"cird7gcih001d29webcfqz2ff","_id":"cird7gcii001g29wewkd91i9p"},{"post_id":"cird7gcij001i29weeqfnb1f5","category_id":"cird7gcih001d29webcfqz2ff","_id":"cird7gcil001j29weucm0ilke"},{"post_id":"cird7gcim001l29wezqeyp32f","category_id":"cird7gcih001d29webcfqz2ff","_id":"cird7gcin001m29wepvkxcrnj"},{"post_id":"cird7gcjx001y29we06apojdm","category_id":"cird7gcjy001z29wefjbaaiyt","_id":"cird7gcjy002229wedi3op85s"},{"post_id":"cird7gck1002429we25q2fjen","category_id":"cird7gck2002529wehw2xdceg","_id":"cird7gck3002829we5sgd4qe8"},{"post_id":"cird7gcmi002j29we14f235vv","category_id":"cird7gchr000j29webv9h5l7a","_id":"cird7gcmi002k29we4jpofmnq"}],"PostTag":[{"post_id":"cird7gcg9000a29weu0ltc7um","tag_id":"cird7gcgh000b29wecwx2slul","_id":"cird7gcgk000c29web9htgz3i"},{"post_id":"cird7gchd000d29weg05tmswh","tag_id":"cird7gche000f29we38kwyln7","_id":"cird7gchf000g29weaygn03e8"},{"post_id":"cird7gchp000i29we8crezyg2","tag_id":"cird7gchr000k29we4c8egio8","_id":"cird7gchs000n29wef1kb3ae7"},{"post_id":"cird7gchp000i29we8crezyg2","tag_id":"cird7gchr000l29we1muglgq7","_id":"cird7gchs000o29weyj1n9ivq"},{"post_id":"cird7gchu000p29we82yzuqsg","tag_id":"cird7gchr000k29we4c8egio8","_id":"cird7gchv000r29wewvx4nw7l"},{"post_id":"cird7gchu000p29we82yzuqsg","tag_id":"cird7gchr000l29we1muglgq7","_id":"cird7gchv000s29weiqwgc921"},{"post_id":"cird7gchw000t29we1yv7u11m","tag_id":"cird7gchy000v29wehhwuhzfx","_id":"cird7gchy000w29we5lch3cnz"},{"post_id":"cird7gci0000y29wey49njots","tag_id":"cird7gci1000z29we8q1y9m7p","_id":"cird7gci1001029weise1v4x0"},{"post_id":"cird7gci2001129we9ls6n292","tag_id":"cird7gchr000k29we4c8egio8","_id":"cird7gci3001229wejimh1obp"},{"post_id":"cird7gci2001129we9ls6n292","tag_id":"cird7gchr000l29we1muglgq7","_id":"cird7gci3001329we93puyjih"},{"post_id":"cird7gcic001729we70midtax","tag_id":"cird7gchr000k29we4c8egio8","_id":"cird7gcie001929we08maodmy"},{"post_id":"cird7gcic001729we70midtax","tag_id":"cird7gcid001829wee7pq086z","_id":"cird7gcie001a29wencda8m51"},{"post_id":"cird7gcih001c29weqo440j03","tag_id":"cird7gcid001829wee7pq086z","_id":"cird7gcii001f29wedwvp8r6q"},{"post_id":"cird7gcih001c29weqo440j03","tag_id":"cird7gcih001e29wextygdvaw","_id":"cird7gcii001h29we60jtj4n7"},{"post_id":"cird7gcij001i29weeqfnb1f5","tag_id":"cird7gcid001829wee7pq086z","_id":"cird7gcil001k29we3wergras"},{"post_id":"cird7gcim001l29wezqeyp32f","tag_id":"cird7gcid001829wee7pq086z","_id":"cird7gcin001n29wepuripej7"},{"post_id":"cird7gcip001o29we7kwzslne","tag_id":"cird7gciq001p29weir6o87d7","_id":"cird7gciq001q29we9wxzmphv"},{"post_id":"cird7gcjq001s29werqj0nlq5","tag_id":"cird7gcjr001t29wee7oyt0lm","_id":"cird7gcjr001u29wek4wmvex5"},{"post_id":"cird7gcjv001w29wetxxl900o","tag_id":"cird7gcjr001t29wee7oyt0lm","_id":"cird7gcjw001x29weq8jzphbk"},{"post_id":"cird7gcjx001y29we06apojdm","tag_id":"cird7gcjy002029we5z592ewi","_id":"cird7gcjy002129wewl6v9u0z"},{"post_id":"cird7gck1002429we25q2fjen","tag_id":"cird7gck3002629we94wxtwmq","_id":"cird7gck3002729we7i32hjk4"},{"post_id":"cird7gcm3002e29wetchpue6b","tag_id":"cird7gcm3002f29wee2czkraa","_id":"cird7gcm4002g29we6ts4asms"},{"post_id":"cird7gcmi002j29we14f235vv","tag_id":"cird7gcmi002l29wemtzbbbq2","_id":"cird7gcmj002m29we8njhzky7"}],"Tag":[{"name":"ReactiveCocoa","_id":"cird7gcgh000b29wecwx2slul"},{"name":"iOS系统","_id":"cird7gche000f29we38kwyln7"},{"name":"iOS","_id":"cird7gchr000k29we4c8egio8"},{"name":"笔记","_id":"cird7gchr000l29we1muglgq7"},{"name":"StatusBar","_id":"cird7gchy000v29wehhwuhzfx"},{"name":"Jenkins","_id":"cird7gci1000z29we8q1y9m7p"},{"name":"Swift","_id":"cird7gcid001829wee7pq086z"},{"name":"闭包","_id":"cird7gcih001e29wextygdvaw"},{"name":"RXSwift","_id":"cird7gciq001p29weir6o87d7"},{"name":"objc","_id":"cird7gcjr001t29wee7oyt0lm"},{"name":"常见错误","_id":"cird7gcjy002029we5z592ewi"},{"name":"Mac","_id":"cird7gck3002629we94wxtwmq"},{"name":"CocoaPods","_id":"cird7gcm3002f29wee2czkraa"},{"name":"App Store","_id":"cird7gcmi002l29wemtzbbbq2"}]}}